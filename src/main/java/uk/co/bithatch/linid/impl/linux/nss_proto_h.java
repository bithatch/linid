// Generated by jextract

package uk.co.bithatch.linid.impl.linux;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class nss_proto_h extends nss_proto_h_1 {

    nss_proto_h() {
        // Should not be called directly
    }

    private static class toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int toupper(int __c)
     * }
     */
    public static FunctionDescriptor toupper$descriptor() {
        return toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int toupper(int __c)
     * }
     */
    public static MethodHandle toupper$handle() {
        return toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int toupper(int __c)
     * }
     */
    public static MemorySegment toupper$address() {
        return toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int toupper(int __c)
     * }
     */
    public static int toupper(int __c) {
        var mh$ = toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("toupper", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isblank {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isblank");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isblank(int)
     * }
     */
    public static FunctionDescriptor isblank$descriptor() {
        return isblank.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isblank(int)
     * }
     */
    public static MethodHandle isblank$handle() {
        return isblank.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isblank(int)
     * }
     */
    public static MemorySegment isblank$address() {
        return isblank.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isblank(int)
     * }
     */
    public static int isblank(int x0) {
        var mh$ = isblank.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isblank", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isascii(int __c)
     * }
     */
    public static FunctionDescriptor isascii$descriptor() {
        return isascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isascii(int __c)
     * }
     */
    public static MethodHandle isascii$handle() {
        return isascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isascii(int __c)
     * }
     */
    public static MemorySegment isascii$address() {
        return isascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isascii(int __c)
     * }
     */
    public static int isascii(int __c) {
        var mh$ = isascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isascii", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class toascii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("toascii");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int toascii(int __c)
     * }
     */
    public static FunctionDescriptor toascii$descriptor() {
        return toascii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int toascii(int __c)
     * }
     */
    public static MethodHandle toascii$handle() {
        return toascii.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int toascii(int __c)
     * }
     */
    public static MemorySegment toascii$address() {
        return toascii.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int toascii(int __c)
     * }
     */
    public static int toascii(int __c) {
        var mh$ = toascii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("toascii", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _toupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("_toupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _toupper(int)
     * }
     */
    public static FunctionDescriptor _toupper$descriptor() {
        return _toupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _toupper(int)
     * }
     */
    public static MethodHandle _toupper$handle() {
        return _toupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _toupper(int)
     * }
     */
    public static MemorySegment _toupper$address() {
        return _toupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _toupper(int)
     * }
     */
    public static int _toupper(int x0) {
        var mh$ = _toupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_toupper", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("_tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _tolower(int)
     * }
     */
    public static FunctionDescriptor _tolower$descriptor() {
        return _tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _tolower(int)
     * }
     */
    public static MethodHandle _tolower$handle() {
        return _tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _tolower(int)
     * }
     */
    public static MemorySegment _tolower$address() {
        return _tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _tolower(int)
     * }
     */
    public static int _tolower(int x0) {
        var mh$ = _tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_tolower", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = nss_proto_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = nss_proto_h.C_POINTER;

    private static class isalnum_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isalnum_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isalnum_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor isalnum_l$descriptor() {
        return isalnum_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isalnum_l(int, locale_t)
     * }
     */
    public static MethodHandle isalnum_l$handle() {
        return isalnum_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isalnum_l(int, locale_t)
     * }
     */
    public static MemorySegment isalnum_l$address() {
        return isalnum_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isalnum_l(int, locale_t)
     * }
     */
    public static int isalnum_l(int x0, MemorySegment x1) {
        var mh$ = isalnum_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isalnum_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isalpha_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isalpha_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isalpha_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor isalpha_l$descriptor() {
        return isalpha_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isalpha_l(int, locale_t)
     * }
     */
    public static MethodHandle isalpha_l$handle() {
        return isalpha_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isalpha_l(int, locale_t)
     * }
     */
    public static MemorySegment isalpha_l$address() {
        return isalpha_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isalpha_l(int, locale_t)
     * }
     */
    public static int isalpha_l(int x0, MemorySegment x1) {
        var mh$ = isalpha_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isalpha_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iscntrl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("iscntrl_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int iscntrl_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor iscntrl_l$descriptor() {
        return iscntrl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int iscntrl_l(int, locale_t)
     * }
     */
    public static MethodHandle iscntrl_l$handle() {
        return iscntrl_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int iscntrl_l(int, locale_t)
     * }
     */
    public static MemorySegment iscntrl_l$address() {
        return iscntrl_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int iscntrl_l(int, locale_t)
     * }
     */
    public static int iscntrl_l(int x0, MemorySegment x1) {
        var mh$ = iscntrl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iscntrl_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isdigit_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor isdigit_l$descriptor() {
        return isdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isdigit_l(int, locale_t)
     * }
     */
    public static MethodHandle isdigit_l$handle() {
        return isdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isdigit_l(int, locale_t)
     * }
     */
    public static MemorySegment isdigit_l$address() {
        return isdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isdigit_l(int, locale_t)
     * }
     */
    public static int isdigit_l(int x0, MemorySegment x1) {
        var mh$ = isdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isdigit_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class islower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("islower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int islower_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor islower_l$descriptor() {
        return islower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int islower_l(int, locale_t)
     * }
     */
    public static MethodHandle islower_l$handle() {
        return islower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int islower_l(int, locale_t)
     * }
     */
    public static MemorySegment islower_l$address() {
        return islower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int islower_l(int, locale_t)
     * }
     */
    public static int islower_l(int x0, MemorySegment x1) {
        var mh$ = islower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("islower_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isgraph_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isgraph_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isgraph_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor isgraph_l$descriptor() {
        return isgraph_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isgraph_l(int, locale_t)
     * }
     */
    public static MethodHandle isgraph_l$handle() {
        return isgraph_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isgraph_l(int, locale_t)
     * }
     */
    public static MemorySegment isgraph_l$address() {
        return isgraph_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isgraph_l(int, locale_t)
     * }
     */
    public static int isgraph_l(int x0, MemorySegment x1) {
        var mh$ = isgraph_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isgraph_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isprint_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isprint_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isprint_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor isprint_l$descriptor() {
        return isprint_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isprint_l(int, locale_t)
     * }
     */
    public static MethodHandle isprint_l$handle() {
        return isprint_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isprint_l(int, locale_t)
     * }
     */
    public static MemorySegment isprint_l$address() {
        return isprint_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isprint_l(int, locale_t)
     * }
     */
    public static int isprint_l(int x0, MemorySegment x1) {
        var mh$ = isprint_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isprint_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ispunct_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ispunct_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ispunct_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor ispunct_l$descriptor() {
        return ispunct_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ispunct_l(int, locale_t)
     * }
     */
    public static MethodHandle ispunct_l$handle() {
        return ispunct_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ispunct_l(int, locale_t)
     * }
     */
    public static MemorySegment ispunct_l$address() {
        return ispunct_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ispunct_l(int, locale_t)
     * }
     */
    public static int ispunct_l(int x0, MemorySegment x1) {
        var mh$ = ispunct_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ispunct_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isspace_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isspace_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isspace_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor isspace_l$descriptor() {
        return isspace_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isspace_l(int, locale_t)
     * }
     */
    public static MethodHandle isspace_l$handle() {
        return isspace_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isspace_l(int, locale_t)
     * }
     */
    public static MemorySegment isspace_l$address() {
        return isspace_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isspace_l(int, locale_t)
     * }
     */
    public static int isspace_l(int x0, MemorySegment x1) {
        var mh$ = isspace_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isspace_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isupper_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor isupper_l$descriptor() {
        return isupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isupper_l(int, locale_t)
     * }
     */
    public static MethodHandle isupper_l$handle() {
        return isupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isupper_l(int, locale_t)
     * }
     */
    public static MemorySegment isupper_l$address() {
        return isupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isupper_l(int, locale_t)
     * }
     */
    public static int isupper_l(int x0, MemorySegment x1) {
        var mh$ = isupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isupper_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isxdigit_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isxdigit_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isxdigit_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor isxdigit_l$descriptor() {
        return isxdigit_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isxdigit_l(int, locale_t)
     * }
     */
    public static MethodHandle isxdigit_l$handle() {
        return isxdigit_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isxdigit_l(int, locale_t)
     * }
     */
    public static MemorySegment isxdigit_l$address() {
        return isxdigit_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isxdigit_l(int, locale_t)
     * }
     */
    public static int isxdigit_l(int x0, MemorySegment x1) {
        var mh$ = isxdigit_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isxdigit_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isblank_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isblank_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isblank_l(int, locale_t)
     * }
     */
    public static FunctionDescriptor isblank_l$descriptor() {
        return isblank_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isblank_l(int, locale_t)
     * }
     */
    public static MethodHandle isblank_l$handle() {
        return isblank_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isblank_l(int, locale_t)
     * }
     */
    public static MemorySegment isblank_l$address() {
        return isblank_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isblank_l(int, locale_t)
     * }
     */
    public static int isblank_l(int x0, MemorySegment x1) {
        var mh$ = isblank_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isblank_l", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tolower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__tolower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __tolower_l(int __c, locale_t __l)
     * }
     */
    public static FunctionDescriptor __tolower_l$descriptor() {
        return __tolower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __tolower_l(int __c, locale_t __l)
     * }
     */
    public static MethodHandle __tolower_l$handle() {
        return __tolower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __tolower_l(int __c, locale_t __l)
     * }
     */
    public static MemorySegment __tolower_l$address() {
        return __tolower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __tolower_l(int __c, locale_t __l)
     * }
     */
    public static int __tolower_l(int __c, MemorySegment __l) {
        var mh$ = __tolower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tolower_l", __c, __l);
            }
            return (int)mh$.invokeExact(__c, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tolower_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("tolower_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int tolower_l(int __c, locale_t __l)
     * }
     */
    public static FunctionDescriptor tolower_l$descriptor() {
        return tolower_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int tolower_l(int __c, locale_t __l)
     * }
     */
    public static MethodHandle tolower_l$handle() {
        return tolower_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int tolower_l(int __c, locale_t __l)
     * }
     */
    public static MemorySegment tolower_l$address() {
        return tolower_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int tolower_l(int __c, locale_t __l)
     * }
     */
    public static int tolower_l(int __c, MemorySegment __l) {
        var mh$ = tolower_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tolower_l", __c, __l);
            }
            return (int)mh$.invokeExact(__c, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __toupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__toupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __toupper_l(int __c, locale_t __l)
     * }
     */
    public static FunctionDescriptor __toupper_l$descriptor() {
        return __toupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __toupper_l(int __c, locale_t __l)
     * }
     */
    public static MethodHandle __toupper_l$handle() {
        return __toupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __toupper_l(int __c, locale_t __l)
     * }
     */
    public static MemorySegment __toupper_l$address() {
        return __toupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __toupper_l(int __c, locale_t __l)
     * }
     */
    public static int __toupper_l(int __c, MemorySegment __l) {
        var mh$ = __toupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__toupper_l", __c, __l);
            }
            return (int)mh$.invokeExact(__c, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class toupper_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("toupper_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int toupper_l(int __c, locale_t __l)
     * }
     */
    public static FunctionDescriptor toupper_l$descriptor() {
        return toupper_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int toupper_l(int __c, locale_t __l)
     * }
     */
    public static MethodHandle toupper_l$handle() {
        return toupper_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int toupper_l(int __c, locale_t __l)
     * }
     */
    public static MemorySegment toupper_l$address() {
        return toupper_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int toupper_l(int __c, locale_t __l)
     * }
     */
    public static int toupper_l(int __c, MemorySegment __l) {
        var mh$ = toupper_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("toupper_l", __c, __l);
            }
            return (int)mh$.invokeExact(__c, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optarg$constants {
        public static final AddressLayout LAYOUT = nss_proto_h.C_POINTER;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("optarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static AddressLayout optarg$layout() {
        return optarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg$segment() {
        return optarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg() {
        return optarg$constants.SEGMENT.get(optarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static void optarg(MemorySegment varValue) {
        optarg$constants.SEGMENT.set(optarg$constants.LAYOUT, 0L, varValue);
    }

    private static class optind$constants {
        public static final OfInt LAYOUT = nss_proto_h.C_INT;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("optind").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static OfInt optind$layout() {
        return optind$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static MemorySegment optind$segment() {
        return optind$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static int optind() {
        return optind$constants.SEGMENT.get(optind$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static void optind(int varValue) {
        optind$constants.SEGMENT.set(optind$constants.LAYOUT, 0L, varValue);
    }

    private static class opterr$constants {
        public static final OfInt LAYOUT = nss_proto_h.C_INT;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("opterr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static OfInt opterr$layout() {
        return opterr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static MemorySegment opterr$segment() {
        return opterr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static int opterr() {
        return opterr$constants.SEGMENT.get(opterr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static void opterr(int varValue) {
        opterr$constants.SEGMENT.set(opterr$constants.LAYOUT, 0L, varValue);
    }

    private static class optopt$constants {
        public static final OfInt LAYOUT = nss_proto_h.C_INT;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("optopt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static OfInt optopt$layout() {
        return optopt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static MemorySegment optopt$segment() {
        return optopt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static int optopt() {
        return optopt$constants.SEGMENT.get(optopt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static void optopt(int varValue) {
        optopt$constants.SEGMENT.set(optopt$constants.LAYOUT, 0L, varValue);
    }

    private static class getopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static FunctionDescriptor getopt$descriptor() {
        return getopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static MethodHandle getopt$handle() {
        return getopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static MemorySegment getopt$address() {
        return getopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getopt(int ___argc, char *const *___argv, const char *__shortopts)
     * }
     */
    public static int getopt(int ___argc, MemorySegment ___argv, MemorySegment __shortopts) {
        var mh$ = getopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt", ___argc, ___argv, __shortopts);
            }
            return (int)mh$.invokeExact(___argc, ___argv, __shortopts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getopt_long {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getopt_long");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getopt_long(int ___argc, char *const *___argv, const char *__shortopts, const struct option *__longopts, int *__longind)
     * }
     */
    public static FunctionDescriptor getopt_long$descriptor() {
        return getopt_long.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getopt_long(int ___argc, char *const *___argv, const char *__shortopts, const struct option *__longopts, int *__longind)
     * }
     */
    public static MethodHandle getopt_long$handle() {
        return getopt_long.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getopt_long(int ___argc, char *const *___argv, const char *__shortopts, const struct option *__longopts, int *__longind)
     * }
     */
    public static MemorySegment getopt_long$address() {
        return getopt_long.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getopt_long(int ___argc, char *const *___argv, const char *__shortopts, const struct option *__longopts, int *__longind)
     * }
     */
    public static int getopt_long(int ___argc, MemorySegment ___argv, MemorySegment __shortopts, MemorySegment __longopts, MemorySegment __longind) {
        var mh$ = getopt_long.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt_long", ___argc, ___argv, __shortopts, __longopts, __longind);
            }
            return (int)mh$.invokeExact(___argc, ___argv, __shortopts, __longopts, __longind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getopt_long_only {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getopt_long_only");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getopt_long_only(int ___argc, char *const *___argv, const char *__shortopts, const struct option *__longopts, int *__longind)
     * }
     */
    public static FunctionDescriptor getopt_long_only$descriptor() {
        return getopt_long_only.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getopt_long_only(int ___argc, char *const *___argv, const char *__shortopts, const struct option *__longopts, int *__longind)
     * }
     */
    public static MethodHandle getopt_long_only$handle() {
        return getopt_long_only.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getopt_long_only(int ___argc, char *const *___argv, const char *__shortopts, const struct option *__longopts, int *__longind)
     * }
     */
    public static MemorySegment getopt_long_only$address() {
        return getopt_long_only.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getopt_long_only(int ___argc, char *const *___argv, const char *__shortopts, const struct option *__longopts, int *__longind)
     * }
     */
    public static int getopt_long_only(int ___argc, MemorySegment ___argv, MemorySegment __shortopts, MemorySegment __longopts, MemorySegment __longind) {
        var mh$ = getopt_long_only.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt_long_only", ___argc, ___argv, __shortopts, __longopts, __longind);
            }
            return (int)mh$.invokeExact(___argc, ___argv, __shortopts, __longopts, __longind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __errno_location {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__errno_location");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static FunctionDescriptor __errno_location$descriptor() {
        return __errno_location.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MethodHandle __errno_location$handle() {
        return __errno_location.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location$address() {
        return __errno_location.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__errno_location()
     * }
     */
    public static MemorySegment __errno_location() {
        var mh$ = __errno_location.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__errno_location");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int error_t
     * }
     */
    public static final OfInt error_t = nss_proto_h.C_INT;

    private static class argp_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("argp_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern error_t argp_parse(const struct argp *restrict __argp, int __argc, char **restrict __argv, unsigned int __flags, int *restrict __arg_index, void *restrict __input)
     * }
     */
    public static FunctionDescriptor argp_parse$descriptor() {
        return argp_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern error_t argp_parse(const struct argp *restrict __argp, int __argc, char **restrict __argv, unsigned int __flags, int *restrict __arg_index, void *restrict __input)
     * }
     */
    public static MethodHandle argp_parse$handle() {
        return argp_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern error_t argp_parse(const struct argp *restrict __argp, int __argc, char **restrict __argv, unsigned int __flags, int *restrict __arg_index, void *restrict __input)
     * }
     */
    public static MemorySegment argp_parse$address() {
        return argp_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern error_t argp_parse(const struct argp *restrict __argp, int __argc, char **restrict __argv, unsigned int __flags, int *restrict __arg_index, void *restrict __input)
     * }
     */
    public static int argp_parse(MemorySegment __argp, int __argc, MemorySegment __argv, int __flags, MemorySegment __arg_index, MemorySegment __input) {
        var mh$ = argp_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("argp_parse", __argp, __argc, __argv, __flags, __arg_index, __input);
            }
            return (int)mh$.invokeExact(__argp, __argc, __argv, __flags, __arg_index, __input);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __argp_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__argp_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern error_t __argp_parse(const struct argp *restrict __argp, int __argc, char **restrict __argv, unsigned int __flags, int *restrict __arg_index, void *restrict __input)
     * }
     */
    public static FunctionDescriptor __argp_parse$descriptor() {
        return __argp_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern error_t __argp_parse(const struct argp *restrict __argp, int __argc, char **restrict __argv, unsigned int __flags, int *restrict __arg_index, void *restrict __input)
     * }
     */
    public static MethodHandle __argp_parse$handle() {
        return __argp_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern error_t __argp_parse(const struct argp *restrict __argp, int __argc, char **restrict __argv, unsigned int __flags, int *restrict __arg_index, void *restrict __input)
     * }
     */
    public static MemorySegment __argp_parse$address() {
        return __argp_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern error_t __argp_parse(const struct argp *restrict __argp, int __argc, char **restrict __argv, unsigned int __flags, int *restrict __arg_index, void *restrict __input)
     * }
     */
    public static int __argp_parse(MemorySegment __argp, int __argc, MemorySegment __argv, int __flags, MemorySegment __arg_index, MemorySegment __input) {
        var mh$ = __argp_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__argp_parse", __argp, __argc, __argv, __flags, __arg_index, __input);
            }
            return (int)mh$.invokeExact(__argp, __argc, __argv, __flags, __arg_index, __input);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class argp_program_version$constants {
        public static final AddressLayout LAYOUT = nss_proto_h.C_POINTER;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("argp_program_version").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *argp_program_version
     * }
     */
    public static AddressLayout argp_program_version$layout() {
        return argp_program_version$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *argp_program_version
     * }
     */
    public static MemorySegment argp_program_version$segment() {
        return argp_program_version$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *argp_program_version
     * }
     */
    public static MemorySegment argp_program_version() {
        return argp_program_version$constants.SEGMENT.get(argp_program_version$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *argp_program_version
     * }
     */
    public static void argp_program_version(MemorySegment varValue) {
        argp_program_version$constants.SEGMENT.set(argp_program_version$constants.LAYOUT, 0L, varValue);
    }

    private static class argp_program_version_hook$constants {
        public static final AddressLayout LAYOUT = nss_proto_h.C_POINTER;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("argp_program_version_hook").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern void (*argp_program_version_hook)(FILE *restrict, struct argp_state *restrict)
     * }
     */
    public static AddressLayout argp_program_version_hook$layout() {
        return argp_program_version_hook$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern void (*argp_program_version_hook)(FILE *restrict, struct argp_state *restrict)
     * }
     */
    public static MemorySegment argp_program_version_hook$segment() {
        return argp_program_version_hook$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern void (*argp_program_version_hook)(FILE *restrict, struct argp_state *restrict)
     * }
     */
    public static MemorySegment argp_program_version_hook() {
        return argp_program_version_hook$constants.SEGMENT.get(argp_program_version_hook$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern void (*argp_program_version_hook)(FILE *restrict, struct argp_state *restrict)
     * }
     */
    public static void argp_program_version_hook(MemorySegment varValue) {
        argp_program_version_hook$constants.SEGMENT.set(argp_program_version_hook$constants.LAYOUT, 0L, varValue);
    }

    private static class argp_program_bug_address$constants {
        public static final AddressLayout LAYOUT = nss_proto_h.C_POINTER;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("argp_program_bug_address").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *argp_program_bug_address
     * }
     */
    public static AddressLayout argp_program_bug_address$layout() {
        return argp_program_bug_address$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *argp_program_bug_address
     * }
     */
    public static MemorySegment argp_program_bug_address$segment() {
        return argp_program_bug_address$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *argp_program_bug_address
     * }
     */
    public static MemorySegment argp_program_bug_address() {
        return argp_program_bug_address$constants.SEGMENT.get(argp_program_bug_address$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *argp_program_bug_address
     * }
     */
    public static void argp_program_bug_address(MemorySegment varValue) {
        argp_program_bug_address$constants.SEGMENT.set(argp_program_bug_address$constants.LAYOUT, 0L, varValue);
    }

    private static class argp_err_exit_status$constants {
        public static final OfInt LAYOUT = nss_proto_h.C_INT;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("argp_err_exit_status").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern error_t argp_err_exit_status
     * }
     */
    public static OfInt argp_err_exit_status$layout() {
        return argp_err_exit_status$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern error_t argp_err_exit_status
     * }
     */
    public static MemorySegment argp_err_exit_status$segment() {
        return argp_err_exit_status$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern error_t argp_err_exit_status
     * }
     */
    public static int argp_err_exit_status() {
        return argp_err_exit_status$constants.SEGMENT.get(argp_err_exit_status$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern error_t argp_err_exit_status
     * }
     */
    public static void argp_err_exit_status(int varValue) {
        argp_err_exit_status$constants.SEGMENT.set(argp_err_exit_status$constants.LAYOUT, 0L, varValue);
    }

    private static class argp_help {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("argp_help");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void argp_help(const struct argp *restrict __argp, FILE *restrict __stream, unsigned int __flags, char *restrict __name)
     * }
     */
    public static FunctionDescriptor argp_help$descriptor() {
        return argp_help.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void argp_help(const struct argp *restrict __argp, FILE *restrict __stream, unsigned int __flags, char *restrict __name)
     * }
     */
    public static MethodHandle argp_help$handle() {
        return argp_help.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void argp_help(const struct argp *restrict __argp, FILE *restrict __stream, unsigned int __flags, char *restrict __name)
     * }
     */
    public static MemorySegment argp_help$address() {
        return argp_help.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void argp_help(const struct argp *restrict __argp, FILE *restrict __stream, unsigned int __flags, char *restrict __name)
     * }
     */
    public static void argp_help(MemorySegment __argp, MemorySegment __stream, int __flags, MemorySegment __name) {
        var mh$ = argp_help.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("argp_help", __argp, __stream, __flags, __name);
            }
            mh$.invokeExact(__argp, __stream, __flags, __name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __argp_help {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__argp_help");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __argp_help(const struct argp *restrict __argp, FILE *restrict __stream, unsigned int __flags, char *__name)
     * }
     */
    public static FunctionDescriptor __argp_help$descriptor() {
        return __argp_help.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __argp_help(const struct argp *restrict __argp, FILE *restrict __stream, unsigned int __flags, char *__name)
     * }
     */
    public static MethodHandle __argp_help$handle() {
        return __argp_help.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __argp_help(const struct argp *restrict __argp, FILE *restrict __stream, unsigned int __flags, char *__name)
     * }
     */
    public static MemorySegment __argp_help$address() {
        return __argp_help.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __argp_help(const struct argp *restrict __argp, FILE *restrict __stream, unsigned int __flags, char *__name)
     * }
     */
    public static void __argp_help(MemorySegment __argp, MemorySegment __stream, int __flags, MemorySegment __name) {
        var mh$ = __argp_help.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__argp_help", __argp, __stream, __flags, __name);
            }
            mh$.invokeExact(__argp, __stream, __flags, __name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class argp_state_help {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("argp_state_help");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void argp_state_help(const struct argp_state *restrict __state, FILE *restrict __stream, unsigned int __flags)
     * }
     */
    public static FunctionDescriptor argp_state_help$descriptor() {
        return argp_state_help.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void argp_state_help(const struct argp_state *restrict __state, FILE *restrict __stream, unsigned int __flags)
     * }
     */
    public static MethodHandle argp_state_help$handle() {
        return argp_state_help.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void argp_state_help(const struct argp_state *restrict __state, FILE *restrict __stream, unsigned int __flags)
     * }
     */
    public static MemorySegment argp_state_help$address() {
        return argp_state_help.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void argp_state_help(const struct argp_state *restrict __state, FILE *restrict __stream, unsigned int __flags)
     * }
     */
    public static void argp_state_help(MemorySegment __state, MemorySegment __stream, int __flags) {
        var mh$ = argp_state_help.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("argp_state_help", __state, __stream, __flags);
            }
            mh$.invokeExact(__state, __stream, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __argp_state_help {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__argp_state_help");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __argp_state_help(const struct argp_state *restrict __state, FILE *restrict __stream, unsigned int __flags)
     * }
     */
    public static FunctionDescriptor __argp_state_help$descriptor() {
        return __argp_state_help.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __argp_state_help(const struct argp_state *restrict __state, FILE *restrict __stream, unsigned int __flags)
     * }
     */
    public static MethodHandle __argp_state_help$handle() {
        return __argp_state_help.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __argp_state_help(const struct argp_state *restrict __state, FILE *restrict __stream, unsigned int __flags)
     * }
     */
    public static MemorySegment __argp_state_help$address() {
        return __argp_state_help.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __argp_state_help(const struct argp_state *restrict __state, FILE *restrict __stream, unsigned int __flags)
     * }
     */
    public static void __argp_state_help(MemorySegment __state, MemorySegment __stream, int __flags) {
        var mh$ = __argp_state_help.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__argp_state_help", __state, __stream, __flags);
            }
            mh$.invokeExact(__state, __stream, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class argp_usage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("argp_usage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void argp_usage(const struct argp_state *__state)
     * }
     */
    public static FunctionDescriptor argp_usage$descriptor() {
        return argp_usage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void argp_usage(const struct argp_state *__state)
     * }
     */
    public static MethodHandle argp_usage$handle() {
        return argp_usage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void argp_usage(const struct argp_state *__state)
     * }
     */
    public static MemorySegment argp_usage$address() {
        return argp_usage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void argp_usage(const struct argp_state *__state)
     * }
     */
    public static void argp_usage(MemorySegment __state) {
        var mh$ = argp_usage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("argp_usage", __state);
            }
            mh$.invokeExact(__state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __argp_usage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__argp_usage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __argp_usage(const struct argp_state *__state)
     * }
     */
    public static FunctionDescriptor __argp_usage$descriptor() {
        return __argp_usage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __argp_usage(const struct argp_state *__state)
     * }
     */
    public static MethodHandle __argp_usage$handle() {
        return __argp_usage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __argp_usage(const struct argp_state *__state)
     * }
     */
    public static MemorySegment __argp_usage$address() {
        return __argp_usage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __argp_usage(const struct argp_state *__state)
     * }
     */
    public static void __argp_usage(MemorySegment __state) {
        var mh$ = __argp_usage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__argp_usage", __state);
            }
            mh$.invokeExact(__state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void argp_error(const struct argp_state *restrict __state, const char *restrict __fmt, ...)
     * }
     */
    public static class argp_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                nss_proto_h.C_POINTER,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("argp_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private argp_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void argp_error(const struct argp_state *restrict __state, const char *restrict __fmt, ...)
         * }
         */
        public static argp_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new argp_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment __state, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("argp_error", __state, __fmt, x2);
                }
                 spreader.invokeExact(__state, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void __argp_error(const struct argp_state *restrict __state, const char *restrict __fmt, ...)
     * }
     */
    public static class __argp_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                nss_proto_h.C_POINTER,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("__argp_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __argp_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void __argp_error(const struct argp_state *restrict __state, const char *restrict __fmt, ...)
         * }
         */
        public static __argp_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __argp_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment __state, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__argp_error", __state, __fmt, x2);
                }
                 spreader.invokeExact(__state, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void argp_failure(const struct argp_state *restrict __state, int __status, int __errnum, const char *restrict __fmt, ...)
     * }
     */
    public static class argp_failure {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                nss_proto_h.C_POINTER,
                nss_proto_h.C_INT,
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("argp_failure");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private argp_failure(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void argp_failure(const struct argp_state *restrict __state, int __status, int __errnum, const char *restrict __fmt, ...)
         * }
         */
        public static argp_failure makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new argp_failure(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment __state, int __status, int __errnum, MemorySegment __fmt, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("argp_failure", __state, __status, __errnum, __fmt, x4);
                }
                 spreader.invokeExact(__state, __status, __errnum, __fmt, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern void __argp_failure(const struct argp_state *restrict __state, int __status, int __errnum, const char *restrict __fmt, ...)
     * }
     */
    public static class __argp_failure {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                nss_proto_h.C_POINTER,
                nss_proto_h.C_INT,
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("__argp_failure");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __argp_failure(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern void __argp_failure(const struct argp_state *restrict __state, int __status, int __errnum, const char *restrict __fmt, ...)
         * }
         */
        public static __argp_failure makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __argp_failure(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment __state, int __status, int __errnum, MemorySegment __fmt, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__argp_failure", __state, __status, __errnum, __fmt, x4);
                }
                 spreader.invokeExact(__state, __status, __errnum, __fmt, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class _option_is_short {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("_option_is_short");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _option_is_short(const struct argp_option *__opt)
     * }
     */
    public static FunctionDescriptor _option_is_short$descriptor() {
        return _option_is_short.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _option_is_short(const struct argp_option *__opt)
     * }
     */
    public static MethodHandle _option_is_short$handle() {
        return _option_is_short.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _option_is_short(const struct argp_option *__opt)
     * }
     */
    public static MemorySegment _option_is_short$address() {
        return _option_is_short.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _option_is_short(const struct argp_option *__opt)
     * }
     */
    public static int _option_is_short(MemorySegment __opt) {
        var mh$ = _option_is_short.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_option_is_short", __opt);
            }
            return (int)mh$.invokeExact(__opt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __option_is_short {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__option_is_short");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __option_is_short(const struct argp_option *__opt)
     * }
     */
    public static FunctionDescriptor __option_is_short$descriptor() {
        return __option_is_short.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __option_is_short(const struct argp_option *__opt)
     * }
     */
    public static MethodHandle __option_is_short$handle() {
        return __option_is_short.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __option_is_short(const struct argp_option *__opt)
     * }
     */
    public static MemorySegment __option_is_short$address() {
        return __option_is_short.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __option_is_short(const struct argp_option *__opt)
     * }
     */
    public static int __option_is_short(MemorySegment __opt) {
        var mh$ = __option_is_short.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__option_is_short", __opt);
            }
            return (int)mh$.invokeExact(__opt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _option_is_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("_option_is_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int _option_is_end(const struct argp_option *__opt)
     * }
     */
    public static FunctionDescriptor _option_is_end$descriptor() {
        return _option_is_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int _option_is_end(const struct argp_option *__opt)
     * }
     */
    public static MethodHandle _option_is_end$handle() {
        return _option_is_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int _option_is_end(const struct argp_option *__opt)
     * }
     */
    public static MemorySegment _option_is_end$address() {
        return _option_is_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int _option_is_end(const struct argp_option *__opt)
     * }
     */
    public static int _option_is_end(MemorySegment __opt) {
        var mh$ = _option_is_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_option_is_end", __opt);
            }
            return (int)mh$.invokeExact(__opt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __option_is_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__option_is_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __option_is_end(const struct argp_option *__opt)
     * }
     */
    public static FunctionDescriptor __option_is_end$descriptor() {
        return __option_is_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __option_is_end(const struct argp_option *__opt)
     * }
     */
    public static MethodHandle __option_is_end$handle() {
        return __option_is_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __option_is_end(const struct argp_option *__opt)
     * }
     */
    public static MemorySegment __option_is_end$address() {
        return __option_is_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __option_is_end(const struct argp_option *__opt)
     * }
     */
    public static int __option_is_end(MemorySegment __opt) {
        var mh$ = __option_is_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__option_is_end", __opt);
            }
            return (int)mh$.invokeExact(__opt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _argp_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("_argp_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *_argp_input(const struct argp *restrict __argp, const struct argp_state *restrict __state)
     * }
     */
    public static FunctionDescriptor _argp_input$descriptor() {
        return _argp_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *_argp_input(const struct argp *restrict __argp, const struct argp_state *restrict __state)
     * }
     */
    public static MethodHandle _argp_input$handle() {
        return _argp_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *_argp_input(const struct argp *restrict __argp, const struct argp_state *restrict __state)
     * }
     */
    public static MemorySegment _argp_input$address() {
        return _argp_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *_argp_input(const struct argp *restrict __argp, const struct argp_state *restrict __state)
     * }
     */
    public static MemorySegment _argp_input(MemorySegment __argp, MemorySegment __state) {
        var mh$ = _argp_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_argp_input", __argp, __state);
            }
            return (MemorySegment)mh$.invokeExact(__argp, __state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __argp_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__argp_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *__argp_input(const struct argp *restrict __argp, const struct argp_state *restrict __state)
     * }
     */
    public static FunctionDescriptor __argp_input$descriptor() {
        return __argp_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *__argp_input(const struct argp *restrict __argp, const struct argp_state *restrict __state)
     * }
     */
    public static MethodHandle __argp_input$handle() {
        return __argp_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *__argp_input(const struct argp *restrict __argp, const struct argp_state *restrict __state)
     * }
     */
    public static MemorySegment __argp_input$address() {
        return __argp_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *__argp_input(const struct argp *restrict __argp, const struct argp_state *restrict __state)
     * }
     */
    public static MemorySegment __argp_input(MemorySegment __argp, MemorySegment __state) {
        var mh$ = __argp_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__argp_input", __argp, __state);
            }
            return (MemorySegment)mh$.invokeExact(__argp, __state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setgrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setgrent()
     * }
     */
    public static FunctionDescriptor setgrent$descriptor() {
        return setgrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setgrent()
     * }
     */
    public static MethodHandle setgrent$handle() {
        return setgrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setgrent()
     * }
     */
    public static MemorySegment setgrent$address() {
        return setgrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setgrent()
     * }
     */
    public static void setgrent() {
        var mh$ = setgrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgrent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endgrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endgrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endgrent()
     * }
     */
    public static FunctionDescriptor endgrent$descriptor() {
        return endgrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endgrent()
     * }
     */
    public static MethodHandle endgrent$handle() {
        return endgrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endgrent()
     * }
     */
    public static MemorySegment endgrent$address() {
        return endgrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endgrent()
     * }
     */
    public static void endgrent() {
        var mh$ = endgrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endgrent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getgrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct group *getgrent()
     * }
     */
    public static FunctionDescriptor getgrent$descriptor() {
        return getgrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct group *getgrent()
     * }
     */
    public static MethodHandle getgrent$handle() {
        return getgrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct group *getgrent()
     * }
     */
    public static MemorySegment getgrent$address() {
        return getgrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct group *getgrent()
     * }
     */
    public static MemorySegment getgrent() {
        var mh$ = getgrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetgrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetgrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct group *fgetgrent(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetgrent$descriptor() {
        return fgetgrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct group *fgetgrent(FILE *__stream)
     * }
     */
    public static MethodHandle fgetgrent$handle() {
        return fgetgrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct group *fgetgrent(FILE *__stream)
     * }
     */
    public static MemorySegment fgetgrent$address() {
        return fgetgrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct group *fgetgrent(FILE *__stream)
     * }
     */
    public static MemorySegment fgetgrent(MemorySegment __stream) {
        var mh$ = fgetgrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetgrent", __stream);
            }
            return (MemorySegment)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getgrgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct group *getgrgid(__gid_t __gid)
     * }
     */
    public static FunctionDescriptor getgrgid$descriptor() {
        return getgrgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct group *getgrgid(__gid_t __gid)
     * }
     */
    public static MethodHandle getgrgid$handle() {
        return getgrgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct group *getgrgid(__gid_t __gid)
     * }
     */
    public static MemorySegment getgrgid$address() {
        return getgrgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct group *getgrgid(__gid_t __gid)
     * }
     */
    public static MemorySegment getgrgid(int __gid) {
        var mh$ = getgrgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrgid", __gid);
            }
            return (MemorySegment)mh$.invokeExact(__gid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getgrnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct group *getgrnam(const char *__name)
     * }
     */
    public static FunctionDescriptor getgrnam$descriptor() {
        return getgrnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct group *getgrnam(const char *__name)
     * }
     */
    public static MethodHandle getgrnam$handle() {
        return getgrnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct group *getgrnam(const char *__name)
     * }
     */
    public static MemorySegment getgrnam$address() {
        return getgrnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct group *getgrnam(const char *__name)
     * }
     */
    public static MemorySegment getgrnam(MemorySegment __name) {
        var mh$ = getgrnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrnam", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrgid_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getgrgid_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getgrgid_r(__gid_t __gid, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static FunctionDescriptor getgrgid_r$descriptor() {
        return getgrgid_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getgrgid_r(__gid_t __gid, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static MethodHandle getgrgid_r$handle() {
        return getgrgid_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getgrgid_r(__gid_t __gid, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static MemorySegment getgrgid_r$address() {
        return getgrgid_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getgrgid_r(__gid_t __gid, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static int getgrgid_r(int __gid, MemorySegment __resultbuf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getgrgid_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrgid_r", __gid, __resultbuf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__gid, __resultbuf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getgrnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getgrnam_r(const char *restrict __name, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static FunctionDescriptor getgrnam_r$descriptor() {
        return getgrnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getgrnam_r(const char *restrict __name, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static MethodHandle getgrnam_r$handle() {
        return getgrnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getgrnam_r(const char *restrict __name, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static MemorySegment getgrnam_r$address() {
        return getgrnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getgrnam_r(const char *restrict __name, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static int getgrnam_r(MemorySegment __name, MemorySegment __resultbuf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getgrnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrnam_r", __name, __resultbuf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__name, __resultbuf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetgrent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetgrent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetgrent_r(FILE *restrict __stream, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static FunctionDescriptor fgetgrent_r$descriptor() {
        return fgetgrent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetgrent_r(FILE *restrict __stream, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static MethodHandle fgetgrent_r$handle() {
        return fgetgrent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetgrent_r(FILE *restrict __stream, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static MemorySegment fgetgrent_r$address() {
        return fgetgrent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetgrent_r(FILE *restrict __stream, struct group *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct group **restrict __result)
     * }
     */
    public static int fgetgrent_r(MemorySegment __stream, MemorySegment __resultbuf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = fgetgrent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetgrent_r", __stream, __resultbuf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__stream, __resultbuf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setgroups(size_t __n, const __gid_t *__groups)
     * }
     */
    public static FunctionDescriptor setgroups$descriptor() {
        return setgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setgroups(size_t __n, const __gid_t *__groups)
     * }
     */
    public static MethodHandle setgroups$handle() {
        return setgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setgroups(size_t __n, const __gid_t *__groups)
     * }
     */
    public static MemorySegment setgroups$address() {
        return setgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setgroups(size_t __n, const __gid_t *__groups)
     * }
     */
    public static int setgroups(long __n, MemorySegment __groups) {
        var mh$ = setgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgroups", __n, __groups);
            }
            return (int)mh$.invokeExact(__n, __groups);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrouplist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getgrouplist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getgrouplist(const char *__user, __gid_t __group, __gid_t *__groups, int *__ngroups)
     * }
     */
    public static FunctionDescriptor getgrouplist$descriptor() {
        return getgrouplist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getgrouplist(const char *__user, __gid_t __group, __gid_t *__groups, int *__ngroups)
     * }
     */
    public static MethodHandle getgrouplist$handle() {
        return getgrouplist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getgrouplist(const char *__user, __gid_t __group, __gid_t *__groups, int *__ngroups)
     * }
     */
    public static MemorySegment getgrouplist$address() {
        return getgrouplist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getgrouplist(const char *__user, __gid_t __group, __gid_t *__groups, int *__ngroups)
     * }
     */
    public static int getgrouplist(MemorySegment __user, int __group, MemorySegment __groups, MemorySegment __ngroups) {
        var mh$ = getgrouplist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrouplist", __user, __group, __groups, __ngroups);
            }
            return (int)mh$.invokeExact(__user, __group, __groups, __ngroups);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("initgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initgroups(const char *__user, __gid_t __group)
     * }
     */
    public static FunctionDescriptor initgroups$descriptor() {
        return initgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initgroups(const char *__user, __gid_t __group)
     * }
     */
    public static MethodHandle initgroups$handle() {
        return initgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initgroups(const char *__user, __gid_t __group)
     * }
     */
    public static MemorySegment initgroups$address() {
        return initgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initgroups(const char *__user, __gid_t __group)
     * }
     */
    public static int initgroups(MemorySegment __user, int __group) {
        var mh$ = initgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initgroups", __user, __group);
            }
            return (int)mh$.invokeExact(__user, __group);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsgent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setsgent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setsgent()
     * }
     */
    public static FunctionDescriptor setsgent$descriptor() {
        return setsgent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setsgent()
     * }
     */
    public static MethodHandle setsgent$handle() {
        return setsgent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setsgent()
     * }
     */
    public static MemorySegment setsgent$address() {
        return setsgent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setsgent()
     * }
     */
    public static void setsgent() {
        var mh$ = setsgent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsgent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endsgent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endsgent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endsgent()
     * }
     */
    public static FunctionDescriptor endsgent$descriptor() {
        return endsgent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endsgent()
     * }
     */
    public static MethodHandle endsgent$handle() {
        return endsgent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endsgent()
     * }
     */
    public static MemorySegment endsgent$address() {
        return endsgent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endsgent()
     * }
     */
    public static void endsgent() {
        var mh$ = endsgent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endsgent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsgent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getsgent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct sgrp *getsgent()
     * }
     */
    public static FunctionDescriptor getsgent$descriptor() {
        return getsgent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct sgrp *getsgent()
     * }
     */
    public static MethodHandle getsgent$handle() {
        return getsgent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct sgrp *getsgent()
     * }
     */
    public static MemorySegment getsgent$address() {
        return getsgent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct sgrp *getsgent()
     * }
     */
    public static MemorySegment getsgent() {
        var mh$ = getsgent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsgent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsgnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getsgnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct sgrp *getsgnam(const char *__name)
     * }
     */
    public static FunctionDescriptor getsgnam$descriptor() {
        return getsgnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct sgrp *getsgnam(const char *__name)
     * }
     */
    public static MethodHandle getsgnam$handle() {
        return getsgnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct sgrp *getsgnam(const char *__name)
     * }
     */
    public static MemorySegment getsgnam$address() {
        return getsgnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct sgrp *getsgnam(const char *__name)
     * }
     */
    public static MemorySegment getsgnam(MemorySegment __name) {
        var mh$ = getsgnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsgnam", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetsgent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("sgetsgent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct sgrp *sgetsgent(const char *__string)
     * }
     */
    public static FunctionDescriptor sgetsgent$descriptor() {
        return sgetsgent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct sgrp *sgetsgent(const char *__string)
     * }
     */
    public static MethodHandle sgetsgent$handle() {
        return sgetsgent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct sgrp *sgetsgent(const char *__string)
     * }
     */
    public static MemorySegment sgetsgent$address() {
        return sgetsgent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct sgrp *sgetsgent(const char *__string)
     * }
     */
    public static MemorySegment sgetsgent(MemorySegment __string) {
        var mh$ = sgetsgent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetsgent", __string);
            }
            return (MemorySegment)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetsgent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetsgent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct sgrp *fgetsgent(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetsgent$descriptor() {
        return fgetsgent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct sgrp *fgetsgent(FILE *__stream)
     * }
     */
    public static MethodHandle fgetsgent$handle() {
        return fgetsgent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct sgrp *fgetsgent(FILE *__stream)
     * }
     */
    public static MemorySegment fgetsgent$address() {
        return fgetsgent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct sgrp *fgetsgent(FILE *__stream)
     * }
     */
    public static MemorySegment fgetsgent(MemorySegment __stream) {
        var mh$ = fgetsgent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetsgent", __stream);
            }
            return (MemorySegment)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putsgent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("putsgent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putsgent(const struct sgrp *__g, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putsgent$descriptor() {
        return putsgent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putsgent(const struct sgrp *__g, FILE *__stream)
     * }
     */
    public static MethodHandle putsgent$handle() {
        return putsgent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putsgent(const struct sgrp *__g, FILE *__stream)
     * }
     */
    public static MemorySegment putsgent$address() {
        return putsgent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putsgent(const struct sgrp *__g, FILE *__stream)
     * }
     */
    public static int putsgent(MemorySegment __g, MemorySegment __stream) {
        var mh$ = putsgent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putsgent", __g, __stream);
            }
            return (int)mh$.invokeExact(__g, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsgent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getsgent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsgent_r(struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static FunctionDescriptor getsgent_r$descriptor() {
        return getsgent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsgent_r(struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static MethodHandle getsgent_r$handle() {
        return getsgent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsgent_r(struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static MemorySegment getsgent_r$address() {
        return getsgent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsgent_r(struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static int getsgent_r(MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getsgent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsgent_r", __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsgnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getsgnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsgnam_r(const char *__name, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static FunctionDescriptor getsgnam_r$descriptor() {
        return getsgnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsgnam_r(const char *__name, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static MethodHandle getsgnam_r$handle() {
        return getsgnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsgnam_r(const char *__name, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static MemorySegment getsgnam_r$address() {
        return getsgnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsgnam_r(const char *__name, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static int getsgnam_r(MemorySegment __name, MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getsgnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsgnam_r", __name, __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__name, __result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetsgent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("sgetsgent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sgetsgent_r(const char *__string, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static FunctionDescriptor sgetsgent_r$descriptor() {
        return sgetsgent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sgetsgent_r(const char *__string, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static MethodHandle sgetsgent_r$handle() {
        return sgetsgent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sgetsgent_r(const char *__string, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static MemorySegment sgetsgent_r$address() {
        return sgetsgent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sgetsgent_r(const char *__string, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static int sgetsgent_r(MemorySegment __string, MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = sgetsgent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetsgent_r", __string, __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__string, __result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetsgent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetsgent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetsgent_r(FILE *__stream, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static FunctionDescriptor fgetsgent_r$descriptor() {
        return fgetsgent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetsgent_r(FILE *__stream, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static MethodHandle fgetsgent_r$handle() {
        return fgetsgent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetsgent_r(FILE *__stream, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static MemorySegment fgetsgent_r$address() {
        return fgetsgent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetsgent_r(FILE *__stream, struct sgrp *__result_buf, char *__buffer, size_t __buflen, struct sgrp **__result)
     * }
     */
    public static int fgetsgent_r(MemorySegment __stream, MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = fgetsgent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetsgent_r", __stream, __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__stream, __result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = nss_proto_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __socklen_t socklen_t
     * }
     */
    public static final OfInt socklen_t = nss_proto_h.C_INT;
    private static final int SOCK_STREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_STREAM = 1
     * }
     */
    public static int SOCK_STREAM() {
        return SOCK_STREAM;
    }
    private static final int SOCK_DGRAM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DGRAM = 2
     * }
     */
    public static int SOCK_DGRAM() {
        return SOCK_DGRAM;
    }
    private static final int SOCK_RAW = (int)3L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RAW = 3
     * }
     */
    public static int SOCK_RAW() {
        return SOCK_RAW;
    }
    private static final int SOCK_RDM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_RDM = 4
     * }
     */
    public static int SOCK_RDM() {
        return SOCK_RDM;
    }
    private static final int SOCK_SEQPACKET = (int)5L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_SEQPACKET = 5
     * }
     */
    public static int SOCK_SEQPACKET() {
        return SOCK_SEQPACKET;
    }
    private static final int SOCK_DCCP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_DCCP = 6
     * }
     */
    public static int SOCK_DCCP() {
        return SOCK_DCCP;
    }
    private static final int SOCK_PACKET = (int)10L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_PACKET = 10
     * }
     */
    public static int SOCK_PACKET() {
        return SOCK_PACKET;
    }
    private static final int SOCK_CLOEXEC = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_CLOEXEC = 524288
     * }
     */
    public static int SOCK_CLOEXEC() {
        return SOCK_CLOEXEC;
    }
    private static final int SOCK_NONBLOCK = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum __socket_type.SOCK_NONBLOCK = 2048
     * }
     */
    public static int SOCK_NONBLOCK() {
        return SOCK_NONBLOCK;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned short sa_family_t
     * }
     */
    public static final OfShort sa_family_t = nss_proto_h.C_SHORT;
    private static final int MSG_OOB = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_OOB = 1
     * }
     */
    public static int MSG_OOB() {
        return MSG_OOB;
    }
    private static final int MSG_PEEK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PEEK = 2
     * }
     */
    public static int MSG_PEEK() {
        return MSG_PEEK;
    }
    private static final int MSG_DONTROUTE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTROUTE = 4
     * }
     */
    public static int MSG_DONTROUTE() {
        return MSG_DONTROUTE;
    }
    private static final int MSG_CTRUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CTRUNC = 8
     * }
     */
    public static int MSG_CTRUNC() {
        return MSG_CTRUNC;
    }
    private static final int MSG_PROXY = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_PROXY = 16
     * }
     */
    public static int MSG_PROXY() {
        return MSG_PROXY;
    }
    private static final int MSG_TRUNC = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_TRUNC = 32
     * }
     */
    public static int MSG_TRUNC() {
        return MSG_TRUNC;
    }
    private static final int MSG_DONTWAIT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_DONTWAIT = 64
     * }
     */
    public static int MSG_DONTWAIT() {
        return MSG_DONTWAIT;
    }
    private static final int MSG_EOR = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_EOR = 128
     * }
     */
    public static int MSG_EOR() {
        return MSG_EOR;
    }
    private static final int MSG_WAITALL = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITALL = 256
     * }
     */
    public static int MSG_WAITALL() {
        return MSG_WAITALL;
    }
    private static final int MSG_FIN = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FIN = 512
     * }
     */
    public static int MSG_FIN() {
        return MSG_FIN;
    }
    private static final int MSG_SYN = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_SYN = 1024
     * }
     */
    public static int MSG_SYN() {
        return MSG_SYN;
    }
    private static final int MSG_CONFIRM = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CONFIRM = 2048
     * }
     */
    public static int MSG_CONFIRM() {
        return MSG_CONFIRM;
    }
    private static final int MSG_RST = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_RST = 4096
     * }
     */
    public static int MSG_RST() {
        return MSG_RST;
    }
    private static final int MSG_ERRQUEUE = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ERRQUEUE = 8192
     * }
     */
    public static int MSG_ERRQUEUE() {
        return MSG_ERRQUEUE;
    }
    private static final int MSG_NOSIGNAL = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_NOSIGNAL = 16384
     * }
     */
    public static int MSG_NOSIGNAL() {
        return MSG_NOSIGNAL;
    }
    private static final int MSG_MORE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_MORE = 32768
     * }
     */
    public static int MSG_MORE() {
        return MSG_MORE;
    }
    private static final int MSG_WAITFORONE = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_WAITFORONE = 65536
     * }
     */
    public static int MSG_WAITFORONE() {
        return MSG_WAITFORONE;
    }
    private static final int MSG_BATCH = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_BATCH = 262144
     * }
     */
    public static int MSG_BATCH() {
        return MSG_BATCH;
    }
    private static final int MSG_ZEROCOPY = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_ZEROCOPY = 67108864
     * }
     */
    public static int MSG_ZEROCOPY() {
        return MSG_ZEROCOPY;
    }
    private static final int MSG_FASTOPEN = (int)536870912L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_FASTOPEN = 536870912
     * }
     */
    public static int MSG_FASTOPEN() {
        return MSG_FASTOPEN;
    }
    private static final int MSG_CMSG_CLOEXEC = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.MSG_CMSG_CLOEXEC = 1073741824
     * }
     */
    public static int MSG_CMSG_CLOEXEC() {
        return MSG_CMSG_CLOEXEC;
    }

    private static class __cmsg_nxthdr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__cmsg_nxthdr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static FunctionDescriptor __cmsg_nxthdr$descriptor() {
        return __cmsg_nxthdr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MethodHandle __cmsg_nxthdr$handle() {
        return __cmsg_nxthdr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr$address() {
        return __cmsg_nxthdr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr, struct cmsghdr *__cmsg)
     * }
     */
    public static MemorySegment __cmsg_nxthdr(MemorySegment __mhdr, MemorySegment __cmsg) {
        var mh$ = __cmsg_nxthdr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cmsg_nxthdr", __mhdr, __cmsg);
            }
            return (MemorySegment)mh$.invokeExact(__mhdr, __cmsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCM_RIGHTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCM_RIGHTS = 1
     * }
     */
    public static int SCM_RIGHTS() {
        return SCM_RIGHTS;
    }
    /**
     * {@snippet lang=c :
     * typedef int __kernel_key_t
     * }
     */
    public static final OfInt __kernel_key_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_mqd_t
     * }
     */
    public static final OfInt __kernel_mqd_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_uid_t
     * }
     */
    public static final OfShort __kernel_old_uid_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_old_gid_t
     * }
     */
    public static final OfShort __kernel_old_gid_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_old_dev_t
     * }
     */
    public static final OfLong __kernel_old_dev_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __kernel_long_t
     * }
     */
    public static final OfLong __kernel_long_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __kernel_ulong_t
     * }
     */
    public static final OfLong __kernel_ulong_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_ino_t
     * }
     */
    public static final OfLong __kernel_ino_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_mode_t
     * }
     */
    public static final OfInt __kernel_mode_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_pid_t
     * }
     */
    public static final OfInt __kernel_pid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_ipc_pid_t
     * }
     */
    public static final OfInt __kernel_ipc_pid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid_t
     * }
     */
    public static final OfInt __kernel_uid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid_t
     * }
     */
    public static final OfInt __kernel_gid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_suseconds_t
     * }
     */
    public static final OfLong __kernel_suseconds_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_daddr_t
     * }
     */
    public static final OfInt __kernel_daddr_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_uid32_t
     * }
     */
    public static final OfInt __kernel_uid32_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __kernel_gid32_t
     * }
     */
    public static final OfInt __kernel_gid32_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __kernel_ulong_t __kernel_size_t
     * }
     */
    public static final OfLong __kernel_size_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ssize_t
     * }
     */
    public static final OfLong __kernel_ssize_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_ptrdiff_t
     * }
     */
    public static final OfLong __kernel_ptrdiff_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_off_t
     * }
     */
    public static final OfLong __kernel_off_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_loff_t
     * }
     */
    public static final OfLong __kernel_loff_t = nss_proto_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_old_time_t
     * }
     */
    public static final OfLong __kernel_old_time_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_time_t
     * }
     */
    public static final OfLong __kernel_time_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __kernel_time64_t
     * }
     */
    public static final OfLong __kernel_time64_t = nss_proto_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __kernel_long_t __kernel_clock_t
     * }
     */
    public static final OfLong __kernel_clock_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_timer_t
     * }
     */
    public static final OfInt __kernel_timer_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __kernel_clockid_t
     * }
     */
    public static final OfInt __kernel_clockid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char *__kernel_caddr_t
     * }
     */
    public static final AddressLayout __kernel_caddr_t = nss_proto_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_uid16_t
     * }
     */
    public static final OfShort __kernel_uid16_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __kernel_gid16_t
     * }
     */
    public static final OfShort __kernel_gid16_t = nss_proto_h.C_SHORT;
    private static final int SHUT_RD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RD = 0
     * }
     */
    public static int SHUT_RD() {
        return SHUT_RD;
    }
    private static final int SHUT_WR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_WR = 1
     * }
     */
    public static int SHUT_WR() {
        return SHUT_WR;
    }
    private static final int SHUT_RDWR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SHUT_RDWR = 2
     * }
     */
    public static int SHUT_RDWR() {
        return SHUT_RDWR;
    }

    private static class socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("socket");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static MemorySegment socket$address() {
        return socket.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socket(int __domain, int __type, int __protocol)
     * }
     */
    public static int socket(int __domain, int __type, int __protocol) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", __domain, __type, __protocol);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socketpair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("socketpair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static FunctionDescriptor socketpair$descriptor() {
        return socketpair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MethodHandle socketpair$handle() {
        return socketpair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static MemorySegment socketpair$address() {
        return socketpair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int socketpair(int __domain, int __type, int __protocol, int __fds[2])
     * }
     */
    public static int socketpair(int __domain, int __type, int __protocol, MemorySegment __fds) {
        var mh$ = socketpair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socketpair", __domain, __type, __protocol, __fds);
            }
            return (int)mh$.invokeExact(__domain, __type, __protocol, __fds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("bind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment bind$address() {
        return bind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bind(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int bind(int __fd, MemorySegment __addr, int __len) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getsockname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getsockname$descriptor() {
        return getsockname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getsockname$handle() {
        return getsockname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getsockname$address() {
        return getsockname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockname(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getsockname(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getsockname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockname", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("connect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static FunctionDescriptor connect$descriptor() {
        return connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MethodHandle connect$handle() {
        return connect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static MemorySegment connect$address() {
        return connect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int connect(int __fd, const struct sockaddr *__addr, socklen_t __len)
     * }
     */
    public static int connect(int __fd, MemorySegment __addr, int __len) {
        var mh$ = connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connect", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeername {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getpeername");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static FunctionDescriptor getpeername$descriptor() {
        return getpeername.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MethodHandle getpeername$handle() {
        return getpeername.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static MemorySegment getpeername$address() {
        return getpeername.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpeername(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __len)
     * }
     */
    public static int getpeername(int __fd, MemorySegment __addr, MemorySegment __len) {
        var mh$ = getpeername.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeername", __fd, __addr, __len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("send");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor send$descriptor() {
        return send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle send$handle() {
        return send.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment send$address() {
        return send.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t send(int __fd, const void *__buf, size_t __n, int __flags)
     * }
     */
    public static long send(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("send", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("recv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static FunctionDescriptor recv$descriptor() {
        return recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MethodHandle recv$handle() {
        return recv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static MemorySegment recv$address() {
        return recv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recv(int __fd, void *__buf, size_t __n, int __flags)
     * }
     */
    public static long recv(int __fd, MemorySegment __buf, long __n, int __flags) {
        var mh$ = recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recv", __fd, __buf, __n, __flags);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("sendto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static FunctionDescriptor sendto$descriptor() {
        return sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MethodHandle sendto$handle() {
        return sendto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static MemorySegment sendto$address() {
        return sendto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendto(int __fd, const void *__buf, size_t __n, int __flags, const struct sockaddr *__addr, socklen_t __addr_len)
     * }
     */
    public static long sendto(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, int __addr_len) {
        var mh$ = sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendto", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvfrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("recvfrom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor recvfrom$descriptor() {
        return recvfrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle recvfrom$handle() {
        return recvfrom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment recvfrom$address() {
        return recvfrom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvfrom(int __fd, void *restrict __buf, size_t __n, int __flags, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static long recvfrom(int __fd, MemorySegment __buf, long __n, int __flags, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = recvfrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvfrom", __fd, __buf, __n, __flags, __addr, __addr_len);
            }
            return (long)mh$.invokeExact(__fd, __buf, __n, __flags, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("sendmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor sendmsg$descriptor() {
        return sendmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle sendmsg$handle() {
        return sendmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment sendmsg$address() {
        return sendmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t sendmsg(int __fd, const struct msghdr *__message, int __flags)
     * }
     */
    public static long sendmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = sendmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvmsg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("recvmsg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static FunctionDescriptor recvmsg$descriptor() {
        return recvmsg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MethodHandle recvmsg$handle() {
        return recvmsg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static MemorySegment recvmsg$address() {
        return recvmsg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ssize_t recvmsg(int __fd, struct msghdr *__message, int __flags)
     * }
     */
    public static long recvmsg(int __fd, MemorySegment __message, int __flags) {
        var mh$ = recvmsg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvmsg", __fd, __message, __flags);
            }
            return (long)mh$.invokeExact(__fd, __message, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static FunctionDescriptor getsockopt$descriptor() {
        return getsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MethodHandle getsockopt$handle() {
        return getsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static MemorySegment getsockopt$address() {
        return getsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsockopt(int __fd, int __level, int __optname, void *restrict __optval, socklen_t *restrict __optlen)
     * }
     */
    public static int getsockopt(int __fd, int __level, int __optname, MemorySegment __optval, MemorySegment __optlen) {
        var mh$ = getsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setsockopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static MemorySegment setsockopt$address() {
        return setsockopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setsockopt(int __fd, int __level, int __optname, const void *__optval, socklen_t __optlen)
     * }
     */
    public static int setsockopt(int __fd, int __level, int __optname, MemorySegment __optval, int __optlen) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", __fd, __level, __optname, __optval, __optlen);
            }
            return (int)mh$.invokeExact(__fd, __level, __optname, __optval, __optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("listen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static FunctionDescriptor listen$descriptor() {
        return listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MethodHandle listen$handle() {
        return listen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static MemorySegment listen$address() {
        return listen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int listen(int __fd, int __n)
     * }
     */
    public static int listen(int __fd, int __n) {
        var mh$ = listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listen", __fd, __n);
            }
            return (int)mh$.invokeExact(__fd, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static FunctionDescriptor accept$descriptor() {
        return accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MethodHandle accept$handle() {
        return accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static MemorySegment accept$address() {
        return accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int accept(int __fd, struct sockaddr *restrict __addr, socklen_t *restrict __addr_len)
     * }
     */
    public static int accept(int __fd, MemorySegment __addr, MemorySegment __addr_len) {
        var mh$ = accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accept", __fd, __addr, __addr_len);
            }
            return (int)mh$.invokeExact(__fd, __addr, __addr_len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("shutdown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static FunctionDescriptor shutdown$descriptor() {
        return shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MethodHandle shutdown$handle() {
        return shutdown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static MemorySegment shutdown$address() {
        return shutdown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int shutdown(int __fd, int __how)
     * }
     */
    public static int shutdown(int __fd, int __how) {
        var mh$ = shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shutdown", __fd, __how);
            }
            return (int)mh$.invokeExact(__fd, __how);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sockatmark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("sockatmark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static FunctionDescriptor sockatmark$descriptor() {
        return sockatmark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MethodHandle sockatmark$handle() {
        return sockatmark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static MemorySegment sockatmark$address() {
        return sockatmark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sockatmark(int __fd)
     * }
     */
    public static int sockatmark(int __fd) {
        var mh$ = sockatmark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sockatmark", __fd);
            }
            return (int)mh$.invokeExact(__fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isfdtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isfdtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static FunctionDescriptor isfdtype$descriptor() {
        return isfdtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MethodHandle isfdtype$handle() {
        return isfdtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static MemorySegment isfdtype$address() {
        return isfdtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isfdtype(int __fd, int __fdtype)
     * }
     */
    public static int isfdtype(int __fd, int __fdtype) {
        var mh$ = isfdtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isfdtype", __fd, __fdtype);
            }
            return (int)mh$.invokeExact(__fd, __fdtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = nss_proto_h.C_INT;
    private static final int IPPROTO_IP = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IP = 0
     * }
     */
    public static int IPPROTO_IP() {
        return IPPROTO_IP;
    }
    private static final int IPPROTO_ICMP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ICMP = 1
     * }
     */
    public static int IPPROTO_ICMP() {
        return IPPROTO_ICMP;
    }
    private static final int IPPROTO_IGMP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IGMP = 2
     * }
     */
    public static int IPPROTO_IGMP() {
        return IPPROTO_IGMP;
    }
    private static final int IPPROTO_IPIP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IPIP = 4
     * }
     */
    public static int IPPROTO_IPIP() {
        return IPPROTO_IPIP;
    }
    private static final int IPPROTO_TCP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_TCP = 6
     * }
     */
    public static int IPPROTO_TCP() {
        return IPPROTO_TCP;
    }
    private static final int IPPROTO_EGP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_EGP = 8
     * }
     */
    public static int IPPROTO_EGP() {
        return IPPROTO_EGP;
    }
    private static final int IPPROTO_PUP = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_PUP = 12
     * }
     */
    public static int IPPROTO_PUP() {
        return IPPROTO_PUP;
    }
    private static final int IPPROTO_UDP = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_UDP = 17
     * }
     */
    public static int IPPROTO_UDP() {
        return IPPROTO_UDP;
    }
    private static final int IPPROTO_IDP = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IDP = 22
     * }
     */
    public static int IPPROTO_IDP() {
        return IPPROTO_IDP;
    }
    private static final int IPPROTO_TP = (int)29L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_TP = 29
     * }
     */
    public static int IPPROTO_TP() {
        return IPPROTO_TP;
    }
    private static final int IPPROTO_DCCP = (int)33L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_DCCP = 33
     * }
     */
    public static int IPPROTO_DCCP() {
        return IPPROTO_DCCP;
    }
    private static final int IPPROTO_IPV6 = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_IPV6 = 41
     * }
     */
    public static int IPPROTO_IPV6() {
        return IPPROTO_IPV6;
    }
    private static final int IPPROTO_RSVP = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_RSVP = 46
     * }
     */
    public static int IPPROTO_RSVP() {
        return IPPROTO_RSVP;
    }
    private static final int IPPROTO_GRE = (int)47L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_GRE = 47
     * }
     */
    public static int IPPROTO_GRE() {
        return IPPROTO_GRE;
    }
    private static final int IPPROTO_ESP = (int)50L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ESP = 50
     * }
     */
    public static int IPPROTO_ESP() {
        return IPPROTO_ESP;
    }
    private static final int IPPROTO_AH = (int)51L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_AH = 51
     * }
     */
    public static int IPPROTO_AH() {
        return IPPROTO_AH;
    }
    private static final int IPPROTO_MTP = (int)92L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MTP = 92
     * }
     */
    public static int IPPROTO_MTP() {
        return IPPROTO_MTP;
    }
    private static final int IPPROTO_BEETPH = (int)94L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_BEETPH = 94
     * }
     */
    public static int IPPROTO_BEETPH() {
        return IPPROTO_BEETPH;
    }
    private static final int IPPROTO_ENCAP = (int)98L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ENCAP = 98
     * }
     */
    public static int IPPROTO_ENCAP() {
        return IPPROTO_ENCAP;
    }
    private static final int IPPROTO_PIM = (int)103L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_PIM = 103
     * }
     */
    public static int IPPROTO_PIM() {
        return IPPROTO_PIM;
    }
    private static final int IPPROTO_COMP = (int)108L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_COMP = 108
     * }
     */
    public static int IPPROTO_COMP() {
        return IPPROTO_COMP;
    }
    private static final int IPPROTO_L2TP = (int)115L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_L2TP = 115
     * }
     */
    public static int IPPROTO_L2TP() {
        return IPPROTO_L2TP;
    }
    private static final int IPPROTO_SCTP = (int)132L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_SCTP = 132
     * }
     */
    public static int IPPROTO_SCTP() {
        return IPPROTO_SCTP;
    }
    private static final int IPPROTO_UDPLITE = (int)136L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_UDPLITE = 136
     * }
     */
    public static int IPPROTO_UDPLITE() {
        return IPPROTO_UDPLITE;
    }
    private static final int IPPROTO_MPLS = (int)137L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MPLS = 137
     * }
     */
    public static int IPPROTO_MPLS() {
        return IPPROTO_MPLS;
    }
    private static final int IPPROTO_ETHERNET = (int)143L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ETHERNET = 143
     * }
     */
    public static int IPPROTO_ETHERNET() {
        return IPPROTO_ETHERNET;
    }
    private static final int IPPROTO_RAW = (int)255L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_RAW = 255
     * }
     */
    public static int IPPROTO_RAW() {
        return IPPROTO_RAW;
    }
    private static final int IPPROTO_MPTCP = (int)262L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MPTCP = 262
     * }
     */
    public static int IPPROTO_MPTCP() {
        return IPPROTO_MPTCP;
    }
    private static final int IPPROTO_MAX = (int)263L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MAX = 263
     * }
     */
    public static int IPPROTO_MAX() {
        return IPPROTO_MAX;
    }
    private static final int IPPROTO_HOPOPTS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_HOPOPTS = 0
     * }
     */
    public static int IPPROTO_HOPOPTS() {
        return IPPROTO_HOPOPTS;
    }
    private static final int IPPROTO_ROUTING = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ROUTING = 43
     * }
     */
    public static int IPPROTO_ROUTING() {
        return IPPROTO_ROUTING;
    }
    private static final int IPPROTO_FRAGMENT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_FRAGMENT = 44
     * }
     */
    public static int IPPROTO_FRAGMENT() {
        return IPPROTO_FRAGMENT;
    }
    private static final int IPPROTO_ICMPV6 = (int)58L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_ICMPV6 = 58
     * }
     */
    public static int IPPROTO_ICMPV6() {
        return IPPROTO_ICMPV6;
    }
    private static final int IPPROTO_NONE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_NONE = 59
     * }
     */
    public static int IPPROTO_NONE() {
        return IPPROTO_NONE;
    }
    private static final int IPPROTO_DSTOPTS = (int)60L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_DSTOPTS = 60
     * }
     */
    public static int IPPROTO_DSTOPTS() {
        return IPPROTO_DSTOPTS;
    }
    private static final int IPPROTO_MH = (int)135L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPROTO_MH = 135
     * }
     */
    public static int IPPROTO_MH() {
        return IPPROTO_MH;
    }
    /**
     * {@snippet lang=c :
     * typedef uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = nss_proto_h.C_SHORT;
    private static final int IPPORT_ECHO = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_ECHO = 7
     * }
     */
    public static int IPPORT_ECHO() {
        return IPPORT_ECHO;
    }
    private static final int IPPORT_DISCARD = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_DISCARD = 9
     * }
     */
    public static int IPPORT_DISCARD() {
        return IPPORT_DISCARD;
    }
    private static final int IPPORT_SYSTAT = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_SYSTAT = 11
     * }
     */
    public static int IPPORT_SYSTAT() {
        return IPPORT_SYSTAT;
    }
    private static final int IPPORT_DAYTIME = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_DAYTIME = 13
     * }
     */
    public static int IPPORT_DAYTIME() {
        return IPPORT_DAYTIME;
    }
    private static final int IPPORT_NETSTAT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_NETSTAT = 15
     * }
     */
    public static int IPPORT_NETSTAT() {
        return IPPORT_NETSTAT;
    }
    private static final int IPPORT_FTP = (int)21L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_FTP = 21
     * }
     */
    public static int IPPORT_FTP() {
        return IPPORT_FTP;
    }
    private static final int IPPORT_TELNET = (int)23L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TELNET = 23
     * }
     */
    public static int IPPORT_TELNET() {
        return IPPORT_TELNET;
    }
    private static final int IPPORT_SMTP = (int)25L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_SMTP = 25
     * }
     */
    public static int IPPORT_SMTP() {
        return IPPORT_SMTP;
    }
    private static final int IPPORT_TIMESERVER = (int)37L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TIMESERVER = 37
     * }
     */
    public static int IPPORT_TIMESERVER() {
        return IPPORT_TIMESERVER;
    }
    private static final int IPPORT_NAMESERVER = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_NAMESERVER = 42
     * }
     */
    public static int IPPORT_NAMESERVER() {
        return IPPORT_NAMESERVER;
    }
    private static final int IPPORT_WHOIS = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_WHOIS = 43
     * }
     */
    public static int IPPORT_WHOIS() {
        return IPPORT_WHOIS;
    }
    private static final int IPPORT_MTP = (int)57L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_MTP = 57
     * }
     */
    public static int IPPORT_MTP() {
        return IPPORT_MTP;
    }
    private static final int IPPORT_TFTP = (int)69L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TFTP = 69
     * }
     */
    public static int IPPORT_TFTP() {
        return IPPORT_TFTP;
    }
    private static final int IPPORT_RJE = (int)77L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_RJE = 77
     * }
     */
    public static int IPPORT_RJE() {
        return IPPORT_RJE;
    }
    private static final int IPPORT_FINGER = (int)79L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_FINGER = 79
     * }
     */
    public static int IPPORT_FINGER() {
        return IPPORT_FINGER;
    }
    private static final int IPPORT_TTYLINK = (int)87L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_TTYLINK = 87
     * }
     */
    public static int IPPORT_TTYLINK() {
        return IPPORT_TTYLINK;
    }
    private static final int IPPORT_SUPDUP = (int)95L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_SUPDUP = 95
     * }
     */
    public static int IPPORT_SUPDUP() {
        return IPPORT_SUPDUP;
    }
    private static final int IPPORT_EXECSERVER = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_EXECSERVER = 512
     * }
     */
    public static int IPPORT_EXECSERVER() {
        return IPPORT_EXECSERVER;
    }
    private static final int IPPORT_LOGINSERVER = (int)513L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_LOGINSERVER = 513
     * }
     */
    public static int IPPORT_LOGINSERVER() {
        return IPPORT_LOGINSERVER;
    }
    private static final int IPPORT_CMDSERVER = (int)514L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_CMDSERVER = 514
     * }
     */
    public static int IPPORT_CMDSERVER() {
        return IPPORT_CMDSERVER;
    }
    private static final int IPPORT_EFSSERVER = (int)520L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_EFSSERVER = 520
     * }
     */
    public static int IPPORT_EFSSERVER() {
        return IPPORT_EFSSERVER;
    }
    private static final int IPPORT_BIFFUDP = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_BIFFUDP = 512
     * }
     */
    public static int IPPORT_BIFFUDP() {
        return IPPORT_BIFFUDP;
    }
    private static final int IPPORT_WHOSERVER = (int)513L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_WHOSERVER = 513
     * }
     */
    public static int IPPORT_WHOSERVER() {
        return IPPORT_WHOSERVER;
    }
    private static final int IPPORT_ROUTESERVER = (int)520L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_ROUTESERVER = 520
     * }
     */
    public static int IPPORT_ROUTESERVER() {
        return IPPORT_ROUTESERVER;
    }
    private static final int IPPORT_USERRESERVED = (int)5000L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.IPPORT_USERRESERVED = 5000
     * }
     */
    public static int IPPORT_USERRESERVED() {
        return IPPORT_USERRESERVED;
    }

    private static class in6addr_any$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("in6addr_any").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static GroupLayout in6addr_any$layout() {
        return in6addr_any$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static MemorySegment in6addr_any() {
        return in6addr_any$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_any
     * }
     */
    public static void in6addr_any(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, in6addr_any$constants.SEGMENT, 0L, in6addr_any$constants.LAYOUT.byteSize());
    }

    private static class in6addr_loopback$constants {
        public static final GroupLayout LAYOUT = in6_addr.layout();
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("in6addr_loopback").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static GroupLayout in6addr_loopback$layout() {
        return in6addr_loopback$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static MemorySegment in6addr_loopback() {
        return in6addr_loopback$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const struct in6_addr in6addr_loopback
     * }
     */
    public static void in6addr_loopback(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, in6addr_loopback$constants.SEGMENT, 0L, in6addr_loopback$constants.LAYOUT.byteSize());
    }

    private static class ntohl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ntohl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static FunctionDescriptor ntohl$descriptor() {
        return ntohl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static MethodHandle ntohl$handle() {
        return ntohl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static MemorySegment ntohl$address() {
        return ntohl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint32_t ntohl(uint32_t __netlong)
     * }
     */
    public static int ntohl(int __netlong) {
        var mh$ = ntohl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohl", __netlong);
            }
            return (int)mh$.invokeExact(__netlong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntohs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_SHORT,
            nss_proto_h.C_SHORT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ntohs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static FunctionDescriptor ntohs$descriptor() {
        return ntohs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static MethodHandle ntohs$handle() {
        return ntohs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static MemorySegment ntohs$address() {
        return ntohs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint16_t ntohs(uint16_t __netshort)
     * }
     */
    public static short ntohs(short __netshort) {
        var mh$ = ntohs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohs", __netshort);
            }
            return (short)mh$.invokeExact(__netshort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htonl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("htonl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static FunctionDescriptor htonl$descriptor() {
        return htonl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static MethodHandle htonl$handle() {
        return htonl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static MemorySegment htonl$address() {
        return htonl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint32_t htonl(uint32_t __hostlong)
     * }
     */
    public static int htonl(int __hostlong) {
        var mh$ = htonl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htonl", __hostlong);
            }
            return (int)mh$.invokeExact(__hostlong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_SHORT,
            nss_proto_h.C_SHORT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("htons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static FunctionDescriptor htons$descriptor() {
        return htons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static MethodHandle htons$handle() {
        return htons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static MemorySegment htons$address() {
        return htons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint16_t htons(uint16_t __hostshort)
     * }
     */
    public static short htons(short __hostshort) {
        var mh$ = htons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htons", __hostshort);
            }
            return (short)mh$.invokeExact(__hostshort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("bindresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static FunctionDescriptor bindresvport$descriptor() {
        return bindresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static MethodHandle bindresvport$handle() {
        return bindresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static MemorySegment bindresvport$address() {
        return bindresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bindresvport(int __sockfd, struct sockaddr_in *__sock_in)
     * }
     */
    public static int bindresvport(int __sockfd, MemorySegment __sock_in) {
        var mh$ = bindresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport", __sockfd, __sock_in);
            }
            return (int)mh$.invokeExact(__sockfd, __sock_in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bindresvport6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("bindresvport6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static FunctionDescriptor bindresvport6$descriptor() {
        return bindresvport6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static MethodHandle bindresvport6$handle() {
        return bindresvport6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static MemorySegment bindresvport6$address() {
        return bindresvport6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bindresvport6(int __sockfd, struct sockaddr_in6 *__sock_in)
     * }
     */
    public static int bindresvport6(int __sockfd, MemorySegment __sock_in) {
        var mh$ = bindresvport6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bindresvport6", __sockfd, __sock_in);
            }
            return (int)mh$.invokeExact(__sockfd, __sock_in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrpcent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setrpcent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setrpcent(int __stayopen)
     * }
     */
    public static FunctionDescriptor setrpcent$descriptor() {
        return setrpcent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setrpcent(int __stayopen)
     * }
     */
    public static MethodHandle setrpcent$handle() {
        return setrpcent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setrpcent(int __stayopen)
     * }
     */
    public static MemorySegment setrpcent$address() {
        return setrpcent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setrpcent(int __stayopen)
     * }
     */
    public static void setrpcent(int __stayopen) {
        var mh$ = setrpcent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrpcent", __stayopen);
            }
            mh$.invokeExact(__stayopen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endrpcent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endrpcent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endrpcent()
     * }
     */
    public static FunctionDescriptor endrpcent$descriptor() {
        return endrpcent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endrpcent()
     * }
     */
    public static MethodHandle endrpcent$handle() {
        return endrpcent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endrpcent()
     * }
     */
    public static MemorySegment endrpcent$address() {
        return endrpcent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endrpcent()
     * }
     */
    public static void endrpcent() {
        var mh$ = endrpcent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endrpcent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrpcbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getrpcbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct rpcent *getrpcbyname(const char *__name)
     * }
     */
    public static FunctionDescriptor getrpcbyname$descriptor() {
        return getrpcbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct rpcent *getrpcbyname(const char *__name)
     * }
     */
    public static MethodHandle getrpcbyname$handle() {
        return getrpcbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct rpcent *getrpcbyname(const char *__name)
     * }
     */
    public static MemorySegment getrpcbyname$address() {
        return getrpcbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct rpcent *getrpcbyname(const char *__name)
     * }
     */
    public static MemorySegment getrpcbyname(MemorySegment __name) {
        var mh$ = getrpcbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrpcbyname", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrpcbynumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getrpcbynumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct rpcent *getrpcbynumber(int __number)
     * }
     */
    public static FunctionDescriptor getrpcbynumber$descriptor() {
        return getrpcbynumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct rpcent *getrpcbynumber(int __number)
     * }
     */
    public static MethodHandle getrpcbynumber$handle() {
        return getrpcbynumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct rpcent *getrpcbynumber(int __number)
     * }
     */
    public static MemorySegment getrpcbynumber$address() {
        return getrpcbynumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct rpcent *getrpcbynumber(int __number)
     * }
     */
    public static MemorySegment getrpcbynumber(int __number) {
        var mh$ = getrpcbynumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrpcbynumber", __number);
            }
            return (MemorySegment)mh$.invokeExact(__number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrpcent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getrpcent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct rpcent *getrpcent()
     * }
     */
    public static FunctionDescriptor getrpcent$descriptor() {
        return getrpcent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct rpcent *getrpcent()
     * }
     */
    public static MethodHandle getrpcent$handle() {
        return getrpcent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct rpcent *getrpcent()
     * }
     */
    public static MemorySegment getrpcent$address() {
        return getrpcent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct rpcent *getrpcent()
     * }
     */
    public static MemorySegment getrpcent() {
        var mh$ = getrpcent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrpcent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrpcbyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getrpcbyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getrpcbyname_r(const char *__name, struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static FunctionDescriptor getrpcbyname_r$descriptor() {
        return getrpcbyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getrpcbyname_r(const char *__name, struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static MethodHandle getrpcbyname_r$handle() {
        return getrpcbyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getrpcbyname_r(const char *__name, struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static MemorySegment getrpcbyname_r$address() {
        return getrpcbyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getrpcbyname_r(const char *__name, struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static int getrpcbyname_r(MemorySegment __name, MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getrpcbyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrpcbyname_r", __name, __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__name, __result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrpcbynumber_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getrpcbynumber_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getrpcbynumber_r(int __number, struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static FunctionDescriptor getrpcbynumber_r$descriptor() {
        return getrpcbynumber_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getrpcbynumber_r(int __number, struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static MethodHandle getrpcbynumber_r$handle() {
        return getrpcbynumber_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getrpcbynumber_r(int __number, struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static MemorySegment getrpcbynumber_r$address() {
        return getrpcbynumber_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getrpcbynumber_r(int __number, struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static int getrpcbynumber_r(int __number, MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getrpcbynumber_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrpcbynumber_r", __number, __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__number, __result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrpcent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getrpcent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getrpcent_r(struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static FunctionDescriptor getrpcent_r$descriptor() {
        return getrpcent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getrpcent_r(struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static MethodHandle getrpcent_r$handle() {
        return getrpcent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getrpcent_r(struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static MemorySegment getrpcent_r$address() {
        return getrpcent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getrpcent_r(struct rpcent *__result_buf, char *__buffer, size_t __buflen, struct rpcent **__result)
     * }
     */
    public static int getrpcent_r(MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getrpcent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrpcent_r", __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __h_errno_location {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__h_errno_location");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__h_errno_location()
     * }
     */
    public static FunctionDescriptor __h_errno_location$descriptor() {
        return __h_errno_location.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__h_errno_location()
     * }
     */
    public static MethodHandle __h_errno_location$handle() {
        return __h_errno_location.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__h_errno_location()
     * }
     */
    public static MemorySegment __h_errno_location$address() {
        return __h_errno_location.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__h_errno_location()
     * }
     */
    public static MemorySegment __h_errno_location() {
        var mh$ = __h_errno_location.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__h_errno_location");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class herror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("herror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void herror(const char *__str)
     * }
     */
    public static FunctionDescriptor herror$descriptor() {
        return herror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void herror(const char *__str)
     * }
     */
    public static MethodHandle herror$handle() {
        return herror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void herror(const char *__str)
     * }
     */
    public static MemorySegment herror$address() {
        return herror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void herror(const char *__str)
     * }
     */
    public static void herror(MemorySegment __str) {
        var mh$ = herror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("herror", __str);
            }
            mh$.invokeExact(__str);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hstrerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("hstrerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *hstrerror(int __err_num)
     * }
     */
    public static FunctionDescriptor hstrerror$descriptor() {
        return hstrerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *hstrerror(int __err_num)
     * }
     */
    public static MethodHandle hstrerror$handle() {
        return hstrerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *hstrerror(int __err_num)
     * }
     */
    public static MemorySegment hstrerror$address() {
        return hstrerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *hstrerror(int __err_num)
     * }
     */
    public static MemorySegment hstrerror(int __err_num) {
        var mh$ = hstrerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hstrerror", __err_num);
            }
            return (MemorySegment)mh$.invokeExact(__err_num);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("sethostent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void sethostent(int __stay_open)
     * }
     */
    public static FunctionDescriptor sethostent$descriptor() {
        return sethostent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void sethostent(int __stay_open)
     * }
     */
    public static MethodHandle sethostent$handle() {
        return sethostent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void sethostent(int __stay_open)
     * }
     */
    public static MemorySegment sethostent$address() {
        return sethostent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void sethostent(int __stay_open)
     * }
     */
    public static void sethostent(int __stay_open) {
        var mh$ = sethostent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostent", __stay_open);
            }
            mh$.invokeExact(__stay_open);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endhostent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endhostent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endhostent()
     * }
     */
    public static FunctionDescriptor endhostent$descriptor() {
        return endhostent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endhostent()
     * }
     */
    public static MethodHandle endhostent$handle() {
        return endhostent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endhostent()
     * }
     */
    public static MemorySegment endhostent$address() {
        return endhostent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endhostent()
     * }
     */
    public static void endhostent() {
        var mh$ = endhostent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endhostent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("gethostent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct hostent *gethostent()
     * }
     */
    public static FunctionDescriptor gethostent$descriptor() {
        return gethostent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct hostent *gethostent()
     * }
     */
    public static MethodHandle gethostent$handle() {
        return gethostent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct hostent *gethostent()
     * }
     */
    public static MemorySegment gethostent$address() {
        return gethostent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct hostent *gethostent()
     * }
     */
    public static MemorySegment gethostent() {
        var mh$ = gethostent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("gethostbyaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct hostent *gethostbyaddr(const void *__addr, __socklen_t __len, int __type)
     * }
     */
    public static FunctionDescriptor gethostbyaddr$descriptor() {
        return gethostbyaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct hostent *gethostbyaddr(const void *__addr, __socklen_t __len, int __type)
     * }
     */
    public static MethodHandle gethostbyaddr$handle() {
        return gethostbyaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct hostent *gethostbyaddr(const void *__addr, __socklen_t __len, int __type)
     * }
     */
    public static MemorySegment gethostbyaddr$address() {
        return gethostbyaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct hostent *gethostbyaddr(const void *__addr, __socklen_t __len, int __type)
     * }
     */
    public static MemorySegment gethostbyaddr(MemorySegment __addr, int __len, int __type) {
        var mh$ = gethostbyaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyaddr", __addr, __len, __type);
            }
            return (MemorySegment)mh$.invokeExact(__addr, __len, __type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("gethostbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct hostent *gethostbyname(const char *__name)
     * }
     */
    public static FunctionDescriptor gethostbyname$descriptor() {
        return gethostbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct hostent *gethostbyname(const char *__name)
     * }
     */
    public static MethodHandle gethostbyname$handle() {
        return gethostbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct hostent *gethostbyname(const char *__name)
     * }
     */
    public static MemorySegment gethostbyname$address() {
        return gethostbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct hostent *gethostbyname(const char *__name)
     * }
     */
    public static MemorySegment gethostbyname(MemorySegment __name) {
        var mh$ = gethostbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyname", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyname2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("gethostbyname2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct hostent *gethostbyname2(const char *__name, int __af)
     * }
     */
    public static FunctionDescriptor gethostbyname2$descriptor() {
        return gethostbyname2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct hostent *gethostbyname2(const char *__name, int __af)
     * }
     */
    public static MethodHandle gethostbyname2$handle() {
        return gethostbyname2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct hostent *gethostbyname2(const char *__name, int __af)
     * }
     */
    public static MemorySegment gethostbyname2$address() {
        return gethostbyname2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct hostent *gethostbyname2(const char *__name, int __af)
     * }
     */
    public static MemorySegment gethostbyname2(MemorySegment __name, int __af) {
        var mh$ = gethostbyname2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyname2", __name, __af);
            }
            return (MemorySegment)mh$.invokeExact(__name, __af);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("gethostent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gethostent_r(struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static FunctionDescriptor gethostent_r$descriptor() {
        return gethostent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gethostent_r(struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MethodHandle gethostent_r$handle() {
        return gethostent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gethostent_r(struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MemorySegment gethostent_r$address() {
        return gethostent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gethostent_r(struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static int gethostent_r(MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result, MemorySegment __h_errnop) {
        var mh$ = gethostent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostent_r", __result_buf, __buf, __buflen, __result, __h_errnop);
            }
            return (int)mh$.invokeExact(__result_buf, __buf, __buflen, __result, __h_errnop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyaddr_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("gethostbyaddr_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gethostbyaddr_r(const void *restrict __addr, __socklen_t __len, int __type, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static FunctionDescriptor gethostbyaddr_r$descriptor() {
        return gethostbyaddr_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gethostbyaddr_r(const void *restrict __addr, __socklen_t __len, int __type, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MethodHandle gethostbyaddr_r$handle() {
        return gethostbyaddr_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gethostbyaddr_r(const void *restrict __addr, __socklen_t __len, int __type, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MemorySegment gethostbyaddr_r$address() {
        return gethostbyaddr_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gethostbyaddr_r(const void *restrict __addr, __socklen_t __len, int __type, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static int gethostbyaddr_r(MemorySegment __addr, int __len, int __type, MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result, MemorySegment __h_errnop) {
        var mh$ = gethostbyaddr_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyaddr_r", __addr, __len, __type, __result_buf, __buf, __buflen, __result, __h_errnop);
            }
            return (int)mh$.invokeExact(__addr, __len, __type, __result_buf, __buf, __buflen, __result, __h_errnop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("gethostbyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gethostbyname_r(const char *restrict __name, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static FunctionDescriptor gethostbyname_r$descriptor() {
        return gethostbyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gethostbyname_r(const char *restrict __name, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MethodHandle gethostbyname_r$handle() {
        return gethostbyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gethostbyname_r(const char *restrict __name, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MemorySegment gethostbyname_r$address() {
        return gethostbyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gethostbyname_r(const char *restrict __name, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static int gethostbyname_r(MemorySegment __name, MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result, MemorySegment __h_errnop) {
        var mh$ = gethostbyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyname_r", __name, __result_buf, __buf, __buflen, __result, __h_errnop);
            }
            return (int)mh$.invokeExact(__name, __result_buf, __buf, __buflen, __result, __h_errnop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyname2_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("gethostbyname2_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int gethostbyname2_r(const char *restrict __name, int __af, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static FunctionDescriptor gethostbyname2_r$descriptor() {
        return gethostbyname2_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int gethostbyname2_r(const char *restrict __name, int __af, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MethodHandle gethostbyname2_r$handle() {
        return gethostbyname2_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int gethostbyname2_r(const char *restrict __name, int __af, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MemorySegment gethostbyname2_r$address() {
        return gethostbyname2_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int gethostbyname2_r(const char *restrict __name, int __af, struct hostent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct hostent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static int gethostbyname2_r(MemorySegment __name, int __af, MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result, MemorySegment __h_errnop) {
        var mh$ = gethostbyname2_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyname2_r", __name, __af, __result_buf, __buf, __buflen, __result, __h_errnop);
            }
            return (int)mh$.invokeExact(__name, __af, __result_buf, __buf, __buflen, __result, __h_errnop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setnetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setnetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setnetent(int __stay_open)
     * }
     */
    public static FunctionDescriptor setnetent$descriptor() {
        return setnetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setnetent(int __stay_open)
     * }
     */
    public static MethodHandle setnetent$handle() {
        return setnetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setnetent(int __stay_open)
     * }
     */
    public static MemorySegment setnetent$address() {
        return setnetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setnetent(int __stay_open)
     * }
     */
    public static void setnetent(int __stay_open) {
        var mh$ = setnetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setnetent", __stay_open);
            }
            mh$.invokeExact(__stay_open);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endnetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endnetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endnetent()
     * }
     */
    public static FunctionDescriptor endnetent$descriptor() {
        return endnetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endnetent()
     * }
     */
    public static MethodHandle endnetent$handle() {
        return endnetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endnetent()
     * }
     */
    public static MemorySegment endnetent$address() {
        return endnetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endnetent()
     * }
     */
    public static void endnetent() {
        var mh$ = endnetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endnetent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getnetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getnetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct netent *getnetent()
     * }
     */
    public static FunctionDescriptor getnetent$descriptor() {
        return getnetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct netent *getnetent()
     * }
     */
    public static MethodHandle getnetent$handle() {
        return getnetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct netent *getnetent()
     * }
     */
    public static MemorySegment getnetent$address() {
        return getnetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct netent *getnetent()
     * }
     */
    public static MemorySegment getnetent() {
        var mh$ = getnetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getnetent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getnetbyaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getnetbyaddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct netent *getnetbyaddr(uint32_t __net, int __type)
     * }
     */
    public static FunctionDescriptor getnetbyaddr$descriptor() {
        return getnetbyaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct netent *getnetbyaddr(uint32_t __net, int __type)
     * }
     */
    public static MethodHandle getnetbyaddr$handle() {
        return getnetbyaddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct netent *getnetbyaddr(uint32_t __net, int __type)
     * }
     */
    public static MemorySegment getnetbyaddr$address() {
        return getnetbyaddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct netent *getnetbyaddr(uint32_t __net, int __type)
     * }
     */
    public static MemorySegment getnetbyaddr(int __net, int __type) {
        var mh$ = getnetbyaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getnetbyaddr", __net, __type);
            }
            return (MemorySegment)mh$.invokeExact(__net, __type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getnetbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getnetbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct netent *getnetbyname(const char *__name)
     * }
     */
    public static FunctionDescriptor getnetbyname$descriptor() {
        return getnetbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct netent *getnetbyname(const char *__name)
     * }
     */
    public static MethodHandle getnetbyname$handle() {
        return getnetbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct netent *getnetbyname(const char *__name)
     * }
     */
    public static MemorySegment getnetbyname$address() {
        return getnetbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct netent *getnetbyname(const char *__name)
     * }
     */
    public static MemorySegment getnetbyname(MemorySegment __name) {
        var mh$ = getnetbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getnetbyname", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getnetent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getnetent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getnetent_r(struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static FunctionDescriptor getnetent_r$descriptor() {
        return getnetent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getnetent_r(struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MethodHandle getnetent_r$handle() {
        return getnetent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getnetent_r(struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MemorySegment getnetent_r$address() {
        return getnetent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getnetent_r(struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static int getnetent_r(MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result, MemorySegment __h_errnop) {
        var mh$ = getnetent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getnetent_r", __result_buf, __buf, __buflen, __result, __h_errnop);
            }
            return (int)mh$.invokeExact(__result_buf, __buf, __buflen, __result, __h_errnop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getnetbyaddr_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getnetbyaddr_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getnetbyaddr_r(uint32_t __net, int __type, struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static FunctionDescriptor getnetbyaddr_r$descriptor() {
        return getnetbyaddr_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getnetbyaddr_r(uint32_t __net, int __type, struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MethodHandle getnetbyaddr_r$handle() {
        return getnetbyaddr_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getnetbyaddr_r(uint32_t __net, int __type, struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MemorySegment getnetbyaddr_r$address() {
        return getnetbyaddr_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getnetbyaddr_r(uint32_t __net, int __type, struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static int getnetbyaddr_r(int __net, int __type, MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result, MemorySegment __h_errnop) {
        var mh$ = getnetbyaddr_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getnetbyaddr_r", __net, __type, __result_buf, __buf, __buflen, __result, __h_errnop);
            }
            return (int)mh$.invokeExact(__net, __type, __result_buf, __buf, __buflen, __result, __h_errnop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getnetbyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getnetbyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getnetbyname_r(const char *restrict __name, struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static FunctionDescriptor getnetbyname_r$descriptor() {
        return getnetbyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getnetbyname_r(const char *restrict __name, struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MethodHandle getnetbyname_r$handle() {
        return getnetbyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getnetbyname_r(const char *restrict __name, struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static MemorySegment getnetbyname_r$address() {
        return getnetbyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getnetbyname_r(const char *restrict __name, struct netent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct netent **restrict __result, int *restrict __h_errnop)
     * }
     */
    public static int getnetbyname_r(MemorySegment __name, MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result, MemorySegment __h_errnop) {
        var mh$ = getnetbyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getnetbyname_r", __name, __result_buf, __buf, __buflen, __result, __h_errnop);
            }
            return (int)mh$.invokeExact(__name, __result_buf, __buf, __buflen, __result, __h_errnop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setservent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setservent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setservent(int __stay_open)
     * }
     */
    public static FunctionDescriptor setservent$descriptor() {
        return setservent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setservent(int __stay_open)
     * }
     */
    public static MethodHandle setservent$handle() {
        return setservent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setservent(int __stay_open)
     * }
     */
    public static MemorySegment setservent$address() {
        return setservent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setservent(int __stay_open)
     * }
     */
    public static void setservent(int __stay_open) {
        var mh$ = setservent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setservent", __stay_open);
            }
            mh$.invokeExact(__stay_open);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endservent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endservent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endservent()
     * }
     */
    public static FunctionDescriptor endservent$descriptor() {
        return endservent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endservent()
     * }
     */
    public static MethodHandle endservent$handle() {
        return endservent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endservent()
     * }
     */
    public static MemorySegment endservent$address() {
        return endservent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endservent()
     * }
     */
    public static void endservent() {
        var mh$ = endservent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endservent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getservent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct servent *getservent()
     * }
     */
    public static FunctionDescriptor getservent$descriptor() {
        return getservent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct servent *getservent()
     * }
     */
    public static MethodHandle getservent$handle() {
        return getservent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct servent *getservent()
     * }
     */
    public static MemorySegment getservent$address() {
        return getservent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct servent *getservent()
     * }
     */
    public static MemorySegment getservent() {
        var mh$ = getservent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getservbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct servent *getservbyname(const char *__name, const char *__proto)
     * }
     */
    public static FunctionDescriptor getservbyname$descriptor() {
        return getservbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct servent *getservbyname(const char *__name, const char *__proto)
     * }
     */
    public static MethodHandle getservbyname$handle() {
        return getservbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct servent *getservbyname(const char *__name, const char *__proto)
     * }
     */
    public static MemorySegment getservbyname$address() {
        return getservbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct servent *getservbyname(const char *__name, const char *__proto)
     * }
     */
    public static MemorySegment getservbyname(MemorySegment __name, MemorySegment __proto) {
        var mh$ = getservbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservbyname", __name, __proto);
            }
            return (MemorySegment)mh$.invokeExact(__name, __proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservbyport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getservbyport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct servent *getservbyport(int __port, const char *__proto)
     * }
     */
    public static FunctionDescriptor getservbyport$descriptor() {
        return getservbyport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct servent *getservbyport(int __port, const char *__proto)
     * }
     */
    public static MethodHandle getservbyport$handle() {
        return getservbyport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct servent *getservbyport(int __port, const char *__proto)
     * }
     */
    public static MemorySegment getservbyport$address() {
        return getservbyport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct servent *getservbyport(int __port, const char *__proto)
     * }
     */
    public static MemorySegment getservbyport(int __port, MemorySegment __proto) {
        var mh$ = getservbyport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservbyport", __port, __proto);
            }
            return (MemorySegment)mh$.invokeExact(__port, __proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getservent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getservent_r(struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static FunctionDescriptor getservent_r$descriptor() {
        return getservent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getservent_r(struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static MethodHandle getservent_r$handle() {
        return getservent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getservent_r(struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static MemorySegment getservent_r$address() {
        return getservent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getservent_r(struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static int getservent_r(MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result) {
        var mh$ = getservent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservent_r", __result_buf, __buf, __buflen, __result);
            }
            return (int)mh$.invokeExact(__result_buf, __buf, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservbyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getservbyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getservbyname_r(const char *restrict __name, const char *restrict __proto, struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static FunctionDescriptor getservbyname_r$descriptor() {
        return getservbyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getservbyname_r(const char *restrict __name, const char *restrict __proto, struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static MethodHandle getservbyname_r$handle() {
        return getservbyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getservbyname_r(const char *restrict __name, const char *restrict __proto, struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static MemorySegment getservbyname_r$address() {
        return getservbyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getservbyname_r(const char *restrict __name, const char *restrict __proto, struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static int getservbyname_r(MemorySegment __name, MemorySegment __proto, MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result) {
        var mh$ = getservbyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservbyname_r", __name, __proto, __result_buf, __buf, __buflen, __result);
            }
            return (int)mh$.invokeExact(__name, __proto, __result_buf, __buf, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservbyport_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getservbyport_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getservbyport_r(int __port, const char *restrict __proto, struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static FunctionDescriptor getservbyport_r$descriptor() {
        return getservbyport_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getservbyport_r(int __port, const char *restrict __proto, struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static MethodHandle getservbyport_r$handle() {
        return getservbyport_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getservbyport_r(int __port, const char *restrict __proto, struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static MemorySegment getservbyport_r$address() {
        return getservbyport_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getservbyport_r(int __port, const char *restrict __proto, struct servent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct servent **restrict __result)
     * }
     */
    public static int getservbyport_r(int __port, MemorySegment __proto, MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result) {
        var mh$ = getservbyport_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservbyport_r", __port, __proto, __result_buf, __buf, __buflen, __result);
            }
            return (int)mh$.invokeExact(__port, __proto, __result_buf, __buf, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprotoent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setprotoent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setprotoent(int __stay_open)
     * }
     */
    public static FunctionDescriptor setprotoent$descriptor() {
        return setprotoent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setprotoent(int __stay_open)
     * }
     */
    public static MethodHandle setprotoent$handle() {
        return setprotoent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setprotoent(int __stay_open)
     * }
     */
    public static MemorySegment setprotoent$address() {
        return setprotoent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setprotoent(int __stay_open)
     * }
     */
    public static void setprotoent(int __stay_open) {
        var mh$ = setprotoent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprotoent", __stay_open);
            }
            mh$.invokeExact(__stay_open);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endprotoent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endprotoent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endprotoent()
     * }
     */
    public static FunctionDescriptor endprotoent$descriptor() {
        return endprotoent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endprotoent()
     * }
     */
    public static MethodHandle endprotoent$handle() {
        return endprotoent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endprotoent()
     * }
     */
    public static MemorySegment endprotoent$address() {
        return endprotoent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endprotoent()
     * }
     */
    public static void endprotoent() {
        var mh$ = endprotoent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endprotoent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotoent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getprotoent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct protoent *getprotoent()
     * }
     */
    public static FunctionDescriptor getprotoent$descriptor() {
        return getprotoent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct protoent *getprotoent()
     * }
     */
    public static MethodHandle getprotoent$handle() {
        return getprotoent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct protoent *getprotoent()
     * }
     */
    public static MemorySegment getprotoent$address() {
        return getprotoent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct protoent *getprotoent()
     * }
     */
    public static MemorySegment getprotoent() {
        var mh$ = getprotoent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotoent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotobyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getprotobyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct protoent *getprotobyname(const char *__name)
     * }
     */
    public static FunctionDescriptor getprotobyname$descriptor() {
        return getprotobyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct protoent *getprotobyname(const char *__name)
     * }
     */
    public static MethodHandle getprotobyname$handle() {
        return getprotobyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct protoent *getprotobyname(const char *__name)
     * }
     */
    public static MemorySegment getprotobyname$address() {
        return getprotobyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct protoent *getprotobyname(const char *__name)
     * }
     */
    public static MemorySegment getprotobyname(MemorySegment __name) {
        var mh$ = getprotobyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotobyname", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotobynumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getprotobynumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct protoent *getprotobynumber(int __proto)
     * }
     */
    public static FunctionDescriptor getprotobynumber$descriptor() {
        return getprotobynumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct protoent *getprotobynumber(int __proto)
     * }
     */
    public static MethodHandle getprotobynumber$handle() {
        return getprotobynumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct protoent *getprotobynumber(int __proto)
     * }
     */
    public static MemorySegment getprotobynumber$address() {
        return getprotobynumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct protoent *getprotobynumber(int __proto)
     * }
     */
    public static MemorySegment getprotobynumber(int __proto) {
        var mh$ = getprotobynumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotobynumber", __proto);
            }
            return (MemorySegment)mh$.invokeExact(__proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotoent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getprotoent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getprotoent_r(struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static FunctionDescriptor getprotoent_r$descriptor() {
        return getprotoent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getprotoent_r(struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static MethodHandle getprotoent_r$handle() {
        return getprotoent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getprotoent_r(struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static MemorySegment getprotoent_r$address() {
        return getprotoent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getprotoent_r(struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static int getprotoent_r(MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result) {
        var mh$ = getprotoent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotoent_r", __result_buf, __buf, __buflen, __result);
            }
            return (int)mh$.invokeExact(__result_buf, __buf, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotobyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getprotobyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getprotobyname_r(const char *restrict __name, struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static FunctionDescriptor getprotobyname_r$descriptor() {
        return getprotobyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getprotobyname_r(const char *restrict __name, struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static MethodHandle getprotobyname_r$handle() {
        return getprotobyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getprotobyname_r(const char *restrict __name, struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static MemorySegment getprotobyname_r$address() {
        return getprotobyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getprotobyname_r(const char *restrict __name, struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static int getprotobyname_r(MemorySegment __name, MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result) {
        var mh$ = getprotobyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotobyname_r", __name, __result_buf, __buf, __buflen, __result);
            }
            return (int)mh$.invokeExact(__name, __result_buf, __buf, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotobynumber_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getprotobynumber_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getprotobynumber_r(int __proto, struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static FunctionDescriptor getprotobynumber_r$descriptor() {
        return getprotobynumber_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getprotobynumber_r(int __proto, struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static MethodHandle getprotobynumber_r$handle() {
        return getprotobynumber_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getprotobynumber_r(int __proto, struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static MemorySegment getprotobynumber_r$address() {
        return getprotobynumber_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getprotobynumber_r(int __proto, struct protoent *restrict __result_buf, char *restrict __buf, size_t __buflen, struct protoent **restrict __result)
     * }
     */
    public static int getprotobynumber_r(int __proto, MemorySegment __result_buf, MemorySegment __buf, long __buflen, MemorySegment __result) {
        var mh$ = getprotobynumber_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotobynumber_r", __proto, __result_buf, __buf, __buflen, __result);
            }
            return (int)mh$.invokeExact(__proto, __result_buf, __buf, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setnetgrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setnetgrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setnetgrent(const char *__netgroup)
     * }
     */
    public static FunctionDescriptor setnetgrent$descriptor() {
        return setnetgrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setnetgrent(const char *__netgroup)
     * }
     */
    public static MethodHandle setnetgrent$handle() {
        return setnetgrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setnetgrent(const char *__netgroup)
     * }
     */
    public static MemorySegment setnetgrent$address() {
        return setnetgrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setnetgrent(const char *__netgroup)
     * }
     */
    public static int setnetgrent(MemorySegment __netgroup) {
        var mh$ = setnetgrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setnetgrent", __netgroup);
            }
            return (int)mh$.invokeExact(__netgroup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endnetgrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endnetgrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endnetgrent()
     * }
     */
    public static FunctionDescriptor endnetgrent$descriptor() {
        return endnetgrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endnetgrent()
     * }
     */
    public static MethodHandle endnetgrent$handle() {
        return endnetgrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endnetgrent()
     * }
     */
    public static MemorySegment endnetgrent$address() {
        return endnetgrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endnetgrent()
     * }
     */
    public static void endnetgrent() {
        var mh$ = endnetgrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endnetgrent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getnetgrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getnetgrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getnetgrent(char **restrict __hostp, char **restrict __userp, char **restrict __domainp)
     * }
     */
    public static FunctionDescriptor getnetgrent$descriptor() {
        return getnetgrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getnetgrent(char **restrict __hostp, char **restrict __userp, char **restrict __domainp)
     * }
     */
    public static MethodHandle getnetgrent$handle() {
        return getnetgrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getnetgrent(char **restrict __hostp, char **restrict __userp, char **restrict __domainp)
     * }
     */
    public static MemorySegment getnetgrent$address() {
        return getnetgrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getnetgrent(char **restrict __hostp, char **restrict __userp, char **restrict __domainp)
     * }
     */
    public static int getnetgrent(MemorySegment __hostp, MemorySegment __userp, MemorySegment __domainp) {
        var mh$ = getnetgrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getnetgrent", __hostp, __userp, __domainp);
            }
            return (int)mh$.invokeExact(__hostp, __userp, __domainp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class innetgr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("innetgr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int innetgr(const char *__netgroup, const char *__host, const char *__user, const char *__domain)
     * }
     */
    public static FunctionDescriptor innetgr$descriptor() {
        return innetgr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int innetgr(const char *__netgroup, const char *__host, const char *__user, const char *__domain)
     * }
     */
    public static MethodHandle innetgr$handle() {
        return innetgr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int innetgr(const char *__netgroup, const char *__host, const char *__user, const char *__domain)
     * }
     */
    public static MemorySegment innetgr$address() {
        return innetgr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int innetgr(const char *__netgroup, const char *__host, const char *__user, const char *__domain)
     * }
     */
    public static int innetgr(MemorySegment __netgroup, MemorySegment __host, MemorySegment __user, MemorySegment __domain) {
        var mh$ = innetgr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("innetgr", __netgroup, __host, __user, __domain);
            }
            return (int)mh$.invokeExact(__netgroup, __host, __user, __domain);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getnetgrent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getnetgrent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getnetgrent_r(char **restrict __hostp, char **restrict __userp, char **restrict __domainp, char *restrict __buffer, size_t __buflen)
     * }
     */
    public static FunctionDescriptor getnetgrent_r$descriptor() {
        return getnetgrent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getnetgrent_r(char **restrict __hostp, char **restrict __userp, char **restrict __domainp, char *restrict __buffer, size_t __buflen)
     * }
     */
    public static MethodHandle getnetgrent_r$handle() {
        return getnetgrent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getnetgrent_r(char **restrict __hostp, char **restrict __userp, char **restrict __domainp, char *restrict __buffer, size_t __buflen)
     * }
     */
    public static MemorySegment getnetgrent_r$address() {
        return getnetgrent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getnetgrent_r(char **restrict __hostp, char **restrict __userp, char **restrict __domainp, char *restrict __buffer, size_t __buflen)
     * }
     */
    public static int getnetgrent_r(MemorySegment __hostp, MemorySegment __userp, MemorySegment __domainp, MemorySegment __buffer, long __buflen) {
        var mh$ = getnetgrent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getnetgrent_r", __hostp, __userp, __domainp, __buffer, __buflen);
            }
            return (int)mh$.invokeExact(__hostp, __userp, __domainp, __buffer, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_SHORT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("rcmd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rcmd(char **restrict __ahost, unsigned short __rport, const char *restrict __locuser, const char *restrict __remuser, const char *restrict __cmd, int *restrict __fd2p)
     * }
     */
    public static FunctionDescriptor rcmd$descriptor() {
        return rcmd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rcmd(char **restrict __ahost, unsigned short __rport, const char *restrict __locuser, const char *restrict __remuser, const char *restrict __cmd, int *restrict __fd2p)
     * }
     */
    public static MethodHandle rcmd$handle() {
        return rcmd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rcmd(char **restrict __ahost, unsigned short __rport, const char *restrict __locuser, const char *restrict __remuser, const char *restrict __cmd, int *restrict __fd2p)
     * }
     */
    public static MemorySegment rcmd$address() {
        return rcmd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rcmd(char **restrict __ahost, unsigned short __rport, const char *restrict __locuser, const char *restrict __remuser, const char *restrict __cmd, int *restrict __fd2p)
     * }
     */
    public static int rcmd(MemorySegment __ahost, short __rport, MemorySegment __locuser, MemorySegment __remuser, MemorySegment __cmd, MemorySegment __fd2p) {
        var mh$ = rcmd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd", __ahost, __rport, __locuser, __remuser, __cmd, __fd2p);
            }
            return (int)mh$.invokeExact(__ahost, __rport, __locuser, __remuser, __cmd, __fd2p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_SHORT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_SHORT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("rcmd_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rcmd_af(char **restrict __ahost, unsigned short __rport, const char *restrict __locuser, const char *restrict __remuser, const char *restrict __cmd, int *restrict __fd2p, sa_family_t __af)
     * }
     */
    public static FunctionDescriptor rcmd_af$descriptor() {
        return rcmd_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rcmd_af(char **restrict __ahost, unsigned short __rport, const char *restrict __locuser, const char *restrict __remuser, const char *restrict __cmd, int *restrict __fd2p, sa_family_t __af)
     * }
     */
    public static MethodHandle rcmd_af$handle() {
        return rcmd_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rcmd_af(char **restrict __ahost, unsigned short __rport, const char *restrict __locuser, const char *restrict __remuser, const char *restrict __cmd, int *restrict __fd2p, sa_family_t __af)
     * }
     */
    public static MemorySegment rcmd_af$address() {
        return rcmd_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rcmd_af(char **restrict __ahost, unsigned short __rport, const char *restrict __locuser, const char *restrict __remuser, const char *restrict __cmd, int *restrict __fd2p, sa_family_t __af)
     * }
     */
    public static int rcmd_af(MemorySegment __ahost, short __rport, MemorySegment __locuser, MemorySegment __remuser, MemorySegment __cmd, MemorySegment __fd2p, short __af) {
        var mh$ = rcmd_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd_af", __ahost, __rport, __locuser, __remuser, __cmd, __fd2p, __af);
            }
            return (int)mh$.invokeExact(__ahost, __rport, __locuser, __remuser, __cmd, __fd2p, __af);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rexec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("rexec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rexec(char **restrict __ahost, int __rport, const char *restrict __name, const char *restrict __pass, const char *restrict __cmd, int *restrict __fd2p)
     * }
     */
    public static FunctionDescriptor rexec$descriptor() {
        return rexec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rexec(char **restrict __ahost, int __rport, const char *restrict __name, const char *restrict __pass, const char *restrict __cmd, int *restrict __fd2p)
     * }
     */
    public static MethodHandle rexec$handle() {
        return rexec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rexec(char **restrict __ahost, int __rport, const char *restrict __name, const char *restrict __pass, const char *restrict __cmd, int *restrict __fd2p)
     * }
     */
    public static MemorySegment rexec$address() {
        return rexec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rexec(char **restrict __ahost, int __rport, const char *restrict __name, const char *restrict __pass, const char *restrict __cmd, int *restrict __fd2p)
     * }
     */
    public static int rexec(MemorySegment __ahost, int __rport, MemorySegment __name, MemorySegment __pass, MemorySegment __cmd, MemorySegment __fd2p) {
        var mh$ = rexec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rexec", __ahost, __rport, __name, __pass, __cmd, __fd2p);
            }
            return (int)mh$.invokeExact(__ahost, __rport, __name, __pass, __cmd, __fd2p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rexec_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_SHORT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("rexec_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rexec_af(char **restrict __ahost, int __rport, const char *restrict __name, const char *restrict __pass, const char *restrict __cmd, int *restrict __fd2p, sa_family_t __af)
     * }
     */
    public static FunctionDescriptor rexec_af$descriptor() {
        return rexec_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rexec_af(char **restrict __ahost, int __rport, const char *restrict __name, const char *restrict __pass, const char *restrict __cmd, int *restrict __fd2p, sa_family_t __af)
     * }
     */
    public static MethodHandle rexec_af$handle() {
        return rexec_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rexec_af(char **restrict __ahost, int __rport, const char *restrict __name, const char *restrict __pass, const char *restrict __cmd, int *restrict __fd2p, sa_family_t __af)
     * }
     */
    public static MemorySegment rexec_af$address() {
        return rexec_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rexec_af(char **restrict __ahost, int __rport, const char *restrict __name, const char *restrict __pass, const char *restrict __cmd, int *restrict __fd2p, sa_family_t __af)
     * }
     */
    public static int rexec_af(MemorySegment __ahost, int __rport, MemorySegment __name, MemorySegment __pass, MemorySegment __cmd, MemorySegment __fd2p, short __af) {
        var mh$ = rexec_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rexec_af", __ahost, __rport, __name, __pass, __cmd, __fd2p, __af);
            }
            return (int)mh$.invokeExact(__ahost, __rport, __name, __pass, __cmd, __fd2p, __af);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ruserok(const char *__rhost, int __suser, const char *__remuser, const char *__locuser)
     * }
     */
    public static FunctionDescriptor ruserok$descriptor() {
        return ruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ruserok(const char *__rhost, int __suser, const char *__remuser, const char *__locuser)
     * }
     */
    public static MethodHandle ruserok$handle() {
        return ruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ruserok(const char *__rhost, int __suser, const char *__remuser, const char *__locuser)
     * }
     */
    public static MemorySegment ruserok$address() {
        return ruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ruserok(const char *__rhost, int __suser, const char *__remuser, const char *__locuser)
     * }
     */
    public static int ruserok(MemorySegment __rhost, int __suser, MemorySegment __remuser, MemorySegment __locuser) {
        var mh$ = ruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ruserok", __rhost, __suser, __remuser, __locuser);
            }
            return (int)mh$.invokeExact(__rhost, __suser, __remuser, __locuser);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ruserok_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_SHORT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ruserok_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ruserok_af(const char *__rhost, int __suser, const char *__remuser, const char *__locuser, sa_family_t __af)
     * }
     */
    public static FunctionDescriptor ruserok_af$descriptor() {
        return ruserok_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ruserok_af(const char *__rhost, int __suser, const char *__remuser, const char *__locuser, sa_family_t __af)
     * }
     */
    public static MethodHandle ruserok_af$handle() {
        return ruserok_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ruserok_af(const char *__rhost, int __suser, const char *__remuser, const char *__locuser, sa_family_t __af)
     * }
     */
    public static MemorySegment ruserok_af$address() {
        return ruserok_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ruserok_af(const char *__rhost, int __suser, const char *__remuser, const char *__locuser, sa_family_t __af)
     * }
     */
    public static int ruserok_af(MemorySegment __rhost, int __suser, MemorySegment __remuser, MemorySegment __locuser, short __af) {
        var mh$ = ruserok_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ruserok_af", __rhost, __suser, __remuser, __locuser, __af);
            }
            return (int)mh$.invokeExact(__rhost, __suser, __remuser, __locuser, __af);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("iruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int iruserok(uint32_t __raddr, int __suser, const char *__remuser, const char *__locuser)
     * }
     */
    public static FunctionDescriptor iruserok$descriptor() {
        return iruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int iruserok(uint32_t __raddr, int __suser, const char *__remuser, const char *__locuser)
     * }
     */
    public static MethodHandle iruserok$handle() {
        return iruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int iruserok(uint32_t __raddr, int __suser, const char *__remuser, const char *__locuser)
     * }
     */
    public static MemorySegment iruserok$address() {
        return iruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int iruserok(uint32_t __raddr, int __suser, const char *__remuser, const char *__locuser)
     * }
     */
    public static int iruserok(int __raddr, int __suser, MemorySegment __remuser, MemorySegment __locuser) {
        var mh$ = iruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok", __raddr, __suser, __remuser, __locuser);
            }
            return (int)mh$.invokeExact(__raddr, __suser, __remuser, __locuser);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_SHORT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("iruserok_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int iruserok_af(const void *__raddr, int __suser, const char *__remuser, const char *__locuser, sa_family_t __af)
     * }
     */
    public static FunctionDescriptor iruserok_af$descriptor() {
        return iruserok_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int iruserok_af(const void *__raddr, int __suser, const char *__remuser, const char *__locuser, sa_family_t __af)
     * }
     */
    public static MethodHandle iruserok_af$handle() {
        return iruserok_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int iruserok_af(const void *__raddr, int __suser, const char *__remuser, const char *__locuser, sa_family_t __af)
     * }
     */
    public static MemorySegment iruserok_af$address() {
        return iruserok_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int iruserok_af(const void *__raddr, int __suser, const char *__remuser, const char *__locuser, sa_family_t __af)
     * }
     */
    public static int iruserok_af(MemorySegment __raddr, int __suser, MemorySegment __remuser, MemorySegment __locuser, short __af) {
        var mh$ = iruserok_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok_af", __raddr, __suser, __remuser, __locuser, __af);
            }
            return (int)mh$.invokeExact(__raddr, __suser, __remuser, __locuser, __af);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("rresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rresvport(int *__alport)
     * }
     */
    public static FunctionDescriptor rresvport$descriptor() {
        return rresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rresvport(int *__alport)
     * }
     */
    public static MethodHandle rresvport$handle() {
        return rresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rresvport(int *__alport)
     * }
     */
    public static MemorySegment rresvport$address() {
        return rresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rresvport(int *__alport)
     * }
     */
    public static int rresvport(MemorySegment __alport) {
        var mh$ = rresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport", __alport);
            }
            return (int)mh$.invokeExact(__alport);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_SHORT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("rresvport_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rresvport_af(int *__alport, sa_family_t __af)
     * }
     */
    public static FunctionDescriptor rresvport_af$descriptor() {
        return rresvport_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rresvport_af(int *__alport, sa_family_t __af)
     * }
     */
    public static MethodHandle rresvport_af$handle() {
        return rresvport_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rresvport_af(int *__alport, sa_family_t __af)
     * }
     */
    public static MemorySegment rresvport_af$address() {
        return rresvport_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rresvport_af(int *__alport, sa_family_t __af)
     * }
     */
    public static int rresvport_af(MemorySegment __alport, short __af) {
        var mh$ = rresvport_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport_af", __alport, __af);
            }
            return (int)mh$.invokeExact(__alport, __af);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaddrinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getaddrinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getaddrinfo(const char *restrict __name, const char *restrict __service, const struct addrinfo *restrict __req, struct addrinfo **restrict __pai)
     * }
     */
    public static FunctionDescriptor getaddrinfo$descriptor() {
        return getaddrinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getaddrinfo(const char *restrict __name, const char *restrict __service, const struct addrinfo *restrict __req, struct addrinfo **restrict __pai)
     * }
     */
    public static MethodHandle getaddrinfo$handle() {
        return getaddrinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getaddrinfo(const char *restrict __name, const char *restrict __service, const struct addrinfo *restrict __req, struct addrinfo **restrict __pai)
     * }
     */
    public static MemorySegment getaddrinfo$address() {
        return getaddrinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getaddrinfo(const char *restrict __name, const char *restrict __service, const struct addrinfo *restrict __req, struct addrinfo **restrict __pai)
     * }
     */
    public static int getaddrinfo(MemorySegment __name, MemorySegment __service, MemorySegment __req, MemorySegment __pai) {
        var mh$ = getaddrinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaddrinfo", __name, __service, __req, __pai);
            }
            return (int)mh$.invokeExact(__name, __service, __req, __pai);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freeaddrinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("freeaddrinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void freeaddrinfo(struct addrinfo *__ai)
     * }
     */
    public static FunctionDescriptor freeaddrinfo$descriptor() {
        return freeaddrinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void freeaddrinfo(struct addrinfo *__ai)
     * }
     */
    public static MethodHandle freeaddrinfo$handle() {
        return freeaddrinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void freeaddrinfo(struct addrinfo *__ai)
     * }
     */
    public static MemorySegment freeaddrinfo$address() {
        return freeaddrinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void freeaddrinfo(struct addrinfo *__ai)
     * }
     */
    public static void freeaddrinfo(MemorySegment __ai) {
        var mh$ = freeaddrinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freeaddrinfo", __ai);
            }
            mh$.invokeExact(__ai);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gai_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("gai_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *gai_strerror(int __ecode)
     * }
     */
    public static FunctionDescriptor gai_strerror$descriptor() {
        return gai_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *gai_strerror(int __ecode)
     * }
     */
    public static MethodHandle gai_strerror$handle() {
        return gai_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *gai_strerror(int __ecode)
     * }
     */
    public static MemorySegment gai_strerror$address() {
        return gai_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *gai_strerror(int __ecode)
     * }
     */
    public static MemorySegment gai_strerror(int __ecode) {
        var mh$ = gai_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gai_strerror", __ecode);
            }
            return (MemorySegment)mh$.invokeExact(__ecode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getnameinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getnameinfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getnameinfo(const struct sockaddr *restrict __sa, socklen_t __salen, char *restrict __host, socklen_t __hostlen, char *restrict __serv, socklen_t __servlen, int __flags)
     * }
     */
    public static FunctionDescriptor getnameinfo$descriptor() {
        return getnameinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getnameinfo(const struct sockaddr *restrict __sa, socklen_t __salen, char *restrict __host, socklen_t __hostlen, char *restrict __serv, socklen_t __servlen, int __flags)
     * }
     */
    public static MethodHandle getnameinfo$handle() {
        return getnameinfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getnameinfo(const struct sockaddr *restrict __sa, socklen_t __salen, char *restrict __host, socklen_t __hostlen, char *restrict __serv, socklen_t __servlen, int __flags)
     * }
     */
    public static MemorySegment getnameinfo$address() {
        return getnameinfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getnameinfo(const struct sockaddr *restrict __sa, socklen_t __salen, char *restrict __host, socklen_t __hostlen, char *restrict __serv, socklen_t __servlen, int __flags)
     * }
     */
    public static int getnameinfo(MemorySegment __sa, int __salen, MemorySegment __host, int __hostlen, MemorySegment __serv, int __servlen, int __flags) {
        var mh$ = getnameinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getnameinfo", __sa, __salen, __host, __hostlen, __serv, __servlen, __flags);
            }
            return (int)mh$.invokeExact(__sa, __salen, __host, __hostlen, __serv, __servlen, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpwent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setpwent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setpwent()
     * }
     */
    public static FunctionDescriptor setpwent$descriptor() {
        return setpwent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setpwent()
     * }
     */
    public static MethodHandle setpwent$handle() {
        return setpwent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setpwent()
     * }
     */
    public static MemorySegment setpwent$address() {
        return setpwent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setpwent()
     * }
     */
    public static void setpwent() {
        var mh$ = setpwent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpwent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endpwent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endpwent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endpwent()
     * }
     */
    public static FunctionDescriptor endpwent$descriptor() {
        return endpwent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endpwent()
     * }
     */
    public static MethodHandle endpwent$handle() {
        return endpwent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endpwent()
     * }
     */
    public static MemorySegment endpwent$address() {
        return endpwent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endpwent()
     * }
     */
    public static void endpwent() {
        var mh$ = endpwent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endpwent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpwent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getpwent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct passwd *getpwent()
     * }
     */
    public static FunctionDescriptor getpwent$descriptor() {
        return getpwent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct passwd *getpwent()
     * }
     */
    public static MethodHandle getpwent$handle() {
        return getpwent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct passwd *getpwent()
     * }
     */
    public static MemorySegment getpwent$address() {
        return getpwent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct passwd *getpwent()
     * }
     */
    public static MemorySegment getpwent() {
        var mh$ = getpwent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpwent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpwent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetpwent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct passwd *fgetpwent(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetpwent$descriptor() {
        return fgetpwent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct passwd *fgetpwent(FILE *__stream)
     * }
     */
    public static MethodHandle fgetpwent$handle() {
        return fgetpwent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct passwd *fgetpwent(FILE *__stream)
     * }
     */
    public static MemorySegment fgetpwent$address() {
        return fgetpwent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct passwd *fgetpwent(FILE *__stream)
     * }
     */
    public static MemorySegment fgetpwent(MemorySegment __stream) {
        var mh$ = fgetpwent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpwent", __stream);
            }
            return (MemorySegment)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putpwent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("putpwent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putpwent(const struct passwd *restrict __p, FILE *restrict __f)
     * }
     */
    public static FunctionDescriptor putpwent$descriptor() {
        return putpwent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putpwent(const struct passwd *restrict __p, FILE *restrict __f)
     * }
     */
    public static MethodHandle putpwent$handle() {
        return putpwent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putpwent(const struct passwd *restrict __p, FILE *restrict __f)
     * }
     */
    public static MemorySegment putpwent$address() {
        return putpwent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putpwent(const struct passwd *restrict __p, FILE *restrict __f)
     * }
     */
    public static int putpwent(MemorySegment __p, MemorySegment __f) {
        var mh$ = putpwent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putpwent", __p, __f);
            }
            return (int)mh$.invokeExact(__p, __f);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpwuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getpwuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct passwd *getpwuid(__uid_t __uid)
     * }
     */
    public static FunctionDescriptor getpwuid$descriptor() {
        return getpwuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct passwd *getpwuid(__uid_t __uid)
     * }
     */
    public static MethodHandle getpwuid$handle() {
        return getpwuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct passwd *getpwuid(__uid_t __uid)
     * }
     */
    public static MemorySegment getpwuid$address() {
        return getpwuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct passwd *getpwuid(__uid_t __uid)
     * }
     */
    public static MemorySegment getpwuid(int __uid) {
        var mh$ = getpwuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpwuid", __uid);
            }
            return (MemorySegment)mh$.invokeExact(__uid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpwnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getpwnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct passwd *getpwnam(const char *__name)
     * }
     */
    public static FunctionDescriptor getpwnam$descriptor() {
        return getpwnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct passwd *getpwnam(const char *__name)
     * }
     */
    public static MethodHandle getpwnam$handle() {
        return getpwnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct passwd *getpwnam(const char *__name)
     * }
     */
    public static MemorySegment getpwnam$address() {
        return getpwnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct passwd *getpwnam(const char *__name)
     * }
     */
    public static MemorySegment getpwnam(MemorySegment __name) {
        var mh$ = getpwnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpwnam", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpwent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getpwent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpwent_r(struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static FunctionDescriptor getpwent_r$descriptor() {
        return getpwent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpwent_r(struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static MethodHandle getpwent_r$handle() {
        return getpwent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpwent_r(struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static MemorySegment getpwent_r$address() {
        return getpwent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpwent_r(struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static int getpwent_r(MemorySegment __resultbuf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getpwent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpwent_r", __resultbuf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__resultbuf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpwuid_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getpwuid_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpwuid_r(__uid_t __uid, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static FunctionDescriptor getpwuid_r$descriptor() {
        return getpwuid_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpwuid_r(__uid_t __uid, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static MethodHandle getpwuid_r$handle() {
        return getpwuid_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpwuid_r(__uid_t __uid, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static MemorySegment getpwuid_r$address() {
        return getpwuid_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpwuid_r(__uid_t __uid, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static int getpwuid_r(int __uid, MemorySegment __resultbuf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getpwuid_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpwuid_r", __uid, __resultbuf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__uid, __resultbuf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpwnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getpwnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getpwnam_r(const char *restrict __name, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static FunctionDescriptor getpwnam_r$descriptor() {
        return getpwnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getpwnam_r(const char *restrict __name, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static MethodHandle getpwnam_r$handle() {
        return getpwnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getpwnam_r(const char *restrict __name, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static MemorySegment getpwnam_r$address() {
        return getpwnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getpwnam_r(const char *restrict __name, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static int getpwnam_r(MemorySegment __name, MemorySegment __resultbuf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getpwnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpwnam_r", __name, __resultbuf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__name, __resultbuf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpwent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetpwent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpwent_r(FILE *restrict __stream, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static FunctionDescriptor fgetpwent_r$descriptor() {
        return fgetpwent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpwent_r(FILE *restrict __stream, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static MethodHandle fgetpwent_r$handle() {
        return fgetpwent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpwent_r(FILE *restrict __stream, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static MemorySegment fgetpwent_r$address() {
        return fgetpwent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpwent_r(FILE *restrict __stream, struct passwd *restrict __resultbuf, char *restrict __buffer, size_t __buflen, struct passwd **restrict __result)
     * }
     */
    public static int fgetpwent_r(MemorySegment __stream, MemorySegment __resultbuf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = fgetpwent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpwent_r", __stream, __resultbuf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__stream, __resultbuf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setspent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setspent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setspent()
     * }
     */
    public static FunctionDescriptor setspent$descriptor() {
        return setspent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setspent()
     * }
     */
    public static MethodHandle setspent$handle() {
        return setspent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setspent()
     * }
     */
    public static MemorySegment setspent$address() {
        return setspent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setspent()
     * }
     */
    public static void setspent() {
        var mh$ = setspent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setspent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endspent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endspent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endspent()
     * }
     */
    public static FunctionDescriptor endspent$descriptor() {
        return endspent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endspent()
     * }
     */
    public static MethodHandle endspent$handle() {
        return endspent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endspent()
     * }
     */
    public static MemorySegment endspent$address() {
        return endspent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endspent()
     * }
     */
    public static void endspent() {
        var mh$ = endspent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endspent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getspent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getspent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct spwd *getspent()
     * }
     */
    public static FunctionDescriptor getspent$descriptor() {
        return getspent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct spwd *getspent()
     * }
     */
    public static MethodHandle getspent$handle() {
        return getspent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct spwd *getspent()
     * }
     */
    public static MemorySegment getspent$address() {
        return getspent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct spwd *getspent()
     * }
     */
    public static MemorySegment getspent() {
        var mh$ = getspent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getspent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getspnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getspnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct spwd *getspnam(const char *__name)
     * }
     */
    public static FunctionDescriptor getspnam$descriptor() {
        return getspnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct spwd *getspnam(const char *__name)
     * }
     */
    public static MethodHandle getspnam$handle() {
        return getspnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct spwd *getspnam(const char *__name)
     * }
     */
    public static MemorySegment getspnam$address() {
        return getspnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct spwd *getspnam(const char *__name)
     * }
     */
    public static MemorySegment getspnam(MemorySegment __name) {
        var mh$ = getspnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getspnam", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetspent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("sgetspent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct spwd *sgetspent(const char *__string)
     * }
     */
    public static FunctionDescriptor sgetspent$descriptor() {
        return sgetspent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct spwd *sgetspent(const char *__string)
     * }
     */
    public static MethodHandle sgetspent$handle() {
        return sgetspent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct spwd *sgetspent(const char *__string)
     * }
     */
    public static MemorySegment sgetspent$address() {
        return sgetspent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct spwd *sgetspent(const char *__string)
     * }
     */
    public static MemorySegment sgetspent(MemorySegment __string) {
        var mh$ = sgetspent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetspent", __string);
            }
            return (MemorySegment)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetspent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetspent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct spwd *fgetspent(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetspent$descriptor() {
        return fgetspent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct spwd *fgetspent(FILE *__stream)
     * }
     */
    public static MethodHandle fgetspent$handle() {
        return fgetspent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct spwd *fgetspent(FILE *__stream)
     * }
     */
    public static MemorySegment fgetspent$address() {
        return fgetspent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct spwd *fgetspent(FILE *__stream)
     * }
     */
    public static MemorySegment fgetspent(MemorySegment __stream) {
        var mh$ = fgetspent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetspent", __stream);
            }
            return (MemorySegment)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putspent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("putspent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putspent(const struct spwd *__p, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putspent$descriptor() {
        return putspent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putspent(const struct spwd *__p, FILE *__stream)
     * }
     */
    public static MethodHandle putspent$handle() {
        return putspent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putspent(const struct spwd *__p, FILE *__stream)
     * }
     */
    public static MemorySegment putspent$address() {
        return putspent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putspent(const struct spwd *__p, FILE *__stream)
     * }
     */
    public static int putspent(MemorySegment __p, MemorySegment __stream) {
        var mh$ = putspent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putspent", __p, __stream);
            }
            return (int)mh$.invokeExact(__p, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getspent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getspent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getspent_r(struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static FunctionDescriptor getspent_r$descriptor() {
        return getspent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getspent_r(struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static MethodHandle getspent_r$handle() {
        return getspent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getspent_r(struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static MemorySegment getspent_r$address() {
        return getspent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getspent_r(struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static int getspent_r(MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getspent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getspent_r", __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getspnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getspnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getspnam_r(const char *__name, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static FunctionDescriptor getspnam_r$descriptor() {
        return getspnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getspnam_r(const char *__name, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static MethodHandle getspnam_r$handle() {
        return getspnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getspnam_r(const char *__name, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static MemorySegment getspnam_r$address() {
        return getspnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getspnam_r(const char *__name, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static int getspnam_r(MemorySegment __name, MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getspnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getspnam_r", __name, __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__name, __result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sgetspent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("sgetspent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int sgetspent_r(const char *__string, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static FunctionDescriptor sgetspent_r$descriptor() {
        return sgetspent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int sgetspent_r(const char *__string, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static MethodHandle sgetspent_r$handle() {
        return sgetspent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int sgetspent_r(const char *__string, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static MemorySegment sgetspent_r$address() {
        return sgetspent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int sgetspent_r(const char *__string, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static int sgetspent_r(MemorySegment __string, MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = sgetspent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sgetspent_r", __string, __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__string, __result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetspent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetspent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetspent_r(FILE *__stream, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static FunctionDescriptor fgetspent_r$descriptor() {
        return fgetspent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetspent_r(FILE *__stream, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static MethodHandle fgetspent_r$handle() {
        return fgetspent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetspent_r(FILE *__stream, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static MemorySegment fgetspent_r$address() {
        return fgetspent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetspent_r(FILE *__stream, struct spwd *__result_buf, char *__buffer, size_t __buflen, struct spwd **__result)
     * }
     */
    public static int fgetspent_r(MemorySegment __stream, MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = fgetspent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetspent_r", __stream, __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__stream, __result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lckpwdf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("lckpwdf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lckpwdf()
     * }
     */
    public static FunctionDescriptor lckpwdf$descriptor() {
        return lckpwdf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lckpwdf()
     * }
     */
    public static MethodHandle lckpwdf$handle() {
        return lckpwdf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lckpwdf()
     * }
     */
    public static MemorySegment lckpwdf$address() {
        return lckpwdf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lckpwdf()
     * }
     */
    public static int lckpwdf() {
        var mh$ = lckpwdf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lckpwdf");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ulckpwdf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ulckpwdf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ulckpwdf()
     * }
     */
    public static FunctionDescriptor ulckpwdf$descriptor() {
        return ulckpwdf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ulckpwdf()
     * }
     */
    public static MethodHandle ulckpwdf$handle() {
        return ulckpwdf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ulckpwdf()
     * }
     */
    public static MemorySegment ulckpwdf$address() {
        return ulckpwdf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ulckpwdf()
     * }
     */
    public static int ulckpwdf() {
        var mh$ = ulckpwdf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ulckpwdf");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_set_item {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_set_item");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_set_item(pam_handle_t *pamh, int item_type, const void *item)
     * }
     */
    public static FunctionDescriptor pam_set_item$descriptor() {
        return pam_set_item.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_set_item(pam_handle_t *pamh, int item_type, const void *item)
     * }
     */
    public static MethodHandle pam_set_item$handle() {
        return pam_set_item.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_set_item(pam_handle_t *pamh, int item_type, const void *item)
     * }
     */
    public static MemorySegment pam_set_item$address() {
        return pam_set_item.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_set_item(pam_handle_t *pamh, int item_type, const void *item)
     * }
     */
    public static int pam_set_item(MemorySegment pamh, int item_type, MemorySegment item) {
        var mh$ = pam_set_item.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_set_item", pamh, item_type, item);
            }
            return (int)mh$.invokeExact(pamh, item_type, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_get_item {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_get_item");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_get_item(const pam_handle_t *pamh, int item_type, const void **item)
     * }
     */
    public static FunctionDescriptor pam_get_item$descriptor() {
        return pam_get_item.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_get_item(const pam_handle_t *pamh, int item_type, const void **item)
     * }
     */
    public static MethodHandle pam_get_item$handle() {
        return pam_get_item.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_get_item(const pam_handle_t *pamh, int item_type, const void **item)
     * }
     */
    public static MemorySegment pam_get_item$address() {
        return pam_get_item.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_get_item(const pam_handle_t *pamh, int item_type, const void **item)
     * }
     */
    public static int pam_get_item(MemorySegment pamh, int item_type, MemorySegment item) {
        var mh$ = pam_get_item.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_get_item", pamh, item_type, item);
            }
            return (int)mh$.invokeExact(pamh, item_type, item);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *pam_strerror(pam_handle_t *pamh, int errnum)
     * }
     */
    public static FunctionDescriptor pam_strerror$descriptor() {
        return pam_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *pam_strerror(pam_handle_t *pamh, int errnum)
     * }
     */
    public static MethodHandle pam_strerror$handle() {
        return pam_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *pam_strerror(pam_handle_t *pamh, int errnum)
     * }
     */
    public static MemorySegment pam_strerror$address() {
        return pam_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *pam_strerror(pam_handle_t *pamh, int errnum)
     * }
     */
    public static MemorySegment pam_strerror(MemorySegment pamh, int errnum) {
        var mh$ = pam_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_strerror", pamh, errnum);
            }
            return (MemorySegment)mh$.invokeExact(pamh, errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_putenv(pam_handle_t *pamh, const char *name_value)
     * }
     */
    public static FunctionDescriptor pam_putenv$descriptor() {
        return pam_putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_putenv(pam_handle_t *pamh, const char *name_value)
     * }
     */
    public static MethodHandle pam_putenv$handle() {
        return pam_putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_putenv(pam_handle_t *pamh, const char *name_value)
     * }
     */
    public static MemorySegment pam_putenv$address() {
        return pam_putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_putenv(pam_handle_t *pamh, const char *name_value)
     * }
     */
    public static int pam_putenv(MemorySegment pamh, MemorySegment name_value) {
        var mh$ = pam_putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_putenv", pamh, name_value);
            }
            return (int)mh$.invokeExact(pamh, name_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *pam_getenv(pam_handle_t *pamh, const char *name)
     * }
     */
    public static FunctionDescriptor pam_getenv$descriptor() {
        return pam_getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *pam_getenv(pam_handle_t *pamh, const char *name)
     * }
     */
    public static MethodHandle pam_getenv$handle() {
        return pam_getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *pam_getenv(pam_handle_t *pamh, const char *name)
     * }
     */
    public static MemorySegment pam_getenv$address() {
        return pam_getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *pam_getenv(pam_handle_t *pamh, const char *name)
     * }
     */
    public static MemorySegment pam_getenv(MemorySegment pamh, MemorySegment name) {
        var mh$ = pam_getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_getenv", pamh, name);
            }
            return (MemorySegment)mh$.invokeExact(pamh, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_getenvlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_getenvlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char **pam_getenvlist(pam_handle_t *pamh)
     * }
     */
    public static FunctionDescriptor pam_getenvlist$descriptor() {
        return pam_getenvlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char **pam_getenvlist(pam_handle_t *pamh)
     * }
     */
    public static MethodHandle pam_getenvlist$handle() {
        return pam_getenvlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char **pam_getenvlist(pam_handle_t *pamh)
     * }
     */
    public static MemorySegment pam_getenvlist$address() {
        return pam_getenvlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char **pam_getenvlist(pam_handle_t *pamh)
     * }
     */
    public static MemorySegment pam_getenvlist(MemorySegment pamh) {
        var mh$ = pam_getenvlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_getenvlist", pamh);
            }
            return (MemorySegment)mh$.invokeExact(pamh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_fail_delay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_fail_delay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_fail_delay(pam_handle_t *pamh, unsigned int musec_delay)
     * }
     */
    public static FunctionDescriptor pam_fail_delay$descriptor() {
        return pam_fail_delay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_fail_delay(pam_handle_t *pamh, unsigned int musec_delay)
     * }
     */
    public static MethodHandle pam_fail_delay$handle() {
        return pam_fail_delay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_fail_delay(pam_handle_t *pamh, unsigned int musec_delay)
     * }
     */
    public static MemorySegment pam_fail_delay$address() {
        return pam_fail_delay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_fail_delay(pam_handle_t *pamh, unsigned int musec_delay)
     * }
     */
    public static int pam_fail_delay(MemorySegment pamh, int musec_delay) {
        var mh$ = pam_fail_delay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_fail_delay", pamh, musec_delay);
            }
            return (int)mh$.invokeExact(pamh, musec_delay);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_start(const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh)
     * }
     */
    public static FunctionDescriptor pam_start$descriptor() {
        return pam_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_start(const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh)
     * }
     */
    public static MethodHandle pam_start$handle() {
        return pam_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_start(const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh)
     * }
     */
    public static MemorySegment pam_start$address() {
        return pam_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_start(const char *service_name, const char *user, const struct pam_conv *pam_conversation, pam_handle_t **pamh)
     * }
     */
    public static int pam_start(MemorySegment service_name, MemorySegment user, MemorySegment pam_conversation, MemorySegment pamh) {
        var mh$ = pam_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_start", service_name, user, pam_conversation, pamh);
            }
            return (int)mh$.invokeExact(service_name, user, pam_conversation, pamh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_start_confdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_start_confdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_start_confdir(const char *service_name, const char *user, const struct pam_conv *pam_conversation, const char *confdir, pam_handle_t **pamh)
     * }
     */
    public static FunctionDescriptor pam_start_confdir$descriptor() {
        return pam_start_confdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_start_confdir(const char *service_name, const char *user, const struct pam_conv *pam_conversation, const char *confdir, pam_handle_t **pamh)
     * }
     */
    public static MethodHandle pam_start_confdir$handle() {
        return pam_start_confdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_start_confdir(const char *service_name, const char *user, const struct pam_conv *pam_conversation, const char *confdir, pam_handle_t **pamh)
     * }
     */
    public static MemorySegment pam_start_confdir$address() {
        return pam_start_confdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_start_confdir(const char *service_name, const char *user, const struct pam_conv *pam_conversation, const char *confdir, pam_handle_t **pamh)
     * }
     */
    public static int pam_start_confdir(MemorySegment service_name, MemorySegment user, MemorySegment pam_conversation, MemorySegment confdir, MemorySegment pamh) {
        var mh$ = pam_start_confdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_start_confdir", service_name, user, pam_conversation, confdir, pamh);
            }
            return (int)mh$.invokeExact(service_name, user, pam_conversation, confdir, pamh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_end(pam_handle_t *pamh, int pam_status)
     * }
     */
    public static FunctionDescriptor pam_end$descriptor() {
        return pam_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_end(pam_handle_t *pamh, int pam_status)
     * }
     */
    public static MethodHandle pam_end$handle() {
        return pam_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_end(pam_handle_t *pamh, int pam_status)
     * }
     */
    public static MemorySegment pam_end$address() {
        return pam_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_end(pam_handle_t *pamh, int pam_status)
     * }
     */
    public static int pam_end(MemorySegment pamh, int pam_status) {
        var mh$ = pam_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_end", pamh, pam_status);
            }
            return (int)mh$.invokeExact(pamh, pam_status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_authenticate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_authenticate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_authenticate(pam_handle_t *pamh, int flags)
     * }
     */
    public static FunctionDescriptor pam_authenticate$descriptor() {
        return pam_authenticate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_authenticate(pam_handle_t *pamh, int flags)
     * }
     */
    public static MethodHandle pam_authenticate$handle() {
        return pam_authenticate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_authenticate(pam_handle_t *pamh, int flags)
     * }
     */
    public static MemorySegment pam_authenticate$address() {
        return pam_authenticate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_authenticate(pam_handle_t *pamh, int flags)
     * }
     */
    public static int pam_authenticate(MemorySegment pamh, int flags) {
        var mh$ = pam_authenticate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_authenticate", pamh, flags);
            }
            return (int)mh$.invokeExact(pamh, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_setcred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_setcred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_setcred(pam_handle_t *pamh, int flags)
     * }
     */
    public static FunctionDescriptor pam_setcred$descriptor() {
        return pam_setcred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_setcred(pam_handle_t *pamh, int flags)
     * }
     */
    public static MethodHandle pam_setcred$handle() {
        return pam_setcred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_setcred(pam_handle_t *pamh, int flags)
     * }
     */
    public static MemorySegment pam_setcred$address() {
        return pam_setcred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_setcred(pam_handle_t *pamh, int flags)
     * }
     */
    public static int pam_setcred(MemorySegment pamh, int flags) {
        var mh$ = pam_setcred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_setcred", pamh, flags);
            }
            return (int)mh$.invokeExact(pamh, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_acct_mgmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_acct_mgmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_acct_mgmt(pam_handle_t *pamh, int flags)
     * }
     */
    public static FunctionDescriptor pam_acct_mgmt$descriptor() {
        return pam_acct_mgmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_acct_mgmt(pam_handle_t *pamh, int flags)
     * }
     */
    public static MethodHandle pam_acct_mgmt$handle() {
        return pam_acct_mgmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_acct_mgmt(pam_handle_t *pamh, int flags)
     * }
     */
    public static MemorySegment pam_acct_mgmt$address() {
        return pam_acct_mgmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_acct_mgmt(pam_handle_t *pamh, int flags)
     * }
     */
    public static int pam_acct_mgmt(MemorySegment pamh, int flags) {
        var mh$ = pam_acct_mgmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_acct_mgmt", pamh, flags);
            }
            return (int)mh$.invokeExact(pamh, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_open_session {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_open_session");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_open_session(pam_handle_t *pamh, int flags)
     * }
     */
    public static FunctionDescriptor pam_open_session$descriptor() {
        return pam_open_session.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_open_session(pam_handle_t *pamh, int flags)
     * }
     */
    public static MethodHandle pam_open_session$handle() {
        return pam_open_session.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_open_session(pam_handle_t *pamh, int flags)
     * }
     */
    public static MemorySegment pam_open_session$address() {
        return pam_open_session.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_open_session(pam_handle_t *pamh, int flags)
     * }
     */
    public static int pam_open_session(MemorySegment pamh, int flags) {
        var mh$ = pam_open_session.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_open_session", pamh, flags);
            }
            return (int)mh$.invokeExact(pamh, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_close_session {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_close_session");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_close_session(pam_handle_t *pamh, int flags)
     * }
     */
    public static FunctionDescriptor pam_close_session$descriptor() {
        return pam_close_session.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_close_session(pam_handle_t *pamh, int flags)
     * }
     */
    public static MethodHandle pam_close_session$handle() {
        return pam_close_session.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_close_session(pam_handle_t *pamh, int flags)
     * }
     */
    public static MemorySegment pam_close_session$address() {
        return pam_close_session.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_close_session(pam_handle_t *pamh, int flags)
     * }
     */
    public static int pam_close_session(MemorySegment pamh, int flags) {
        var mh$ = pam_close_session.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_close_session", pamh, flags);
            }
            return (int)mh$.invokeExact(pamh, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pam_chauthtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pam_chauthtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pam_chauthtok(pam_handle_t *pamh, int flags)
     * }
     */
    public static FunctionDescriptor pam_chauthtok$descriptor() {
        return pam_chauthtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pam_chauthtok(pam_handle_t *pamh, int flags)
     * }
     */
    public static MethodHandle pam_chauthtok$handle() {
        return pam_chauthtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pam_chauthtok(pam_handle_t *pamh, int flags)
     * }
     */
    public static MemorySegment pam_chauthtok$address() {
        return pam_chauthtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pam_chauthtok(pam_handle_t *pamh, int flags)
     * }
     */
    public static int pam_chauthtok(MemorySegment pamh, int flags) {
        var mh$ = pam_chauthtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pam_chauthtok", pamh, flags);
            }
            return (int)mh$.invokeExact(pamh, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __BYTE_ORDER 1234
     * }
     */
    public static int __BYTE_ORDER() {
        return __BYTE_ORDER;
    }
    private static final int __FLOAT_WORD_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __FLOAT_WORD_ORDER 1234
     * }
     */
    public static int __FLOAT_WORD_ORDER() {
        return __FLOAT_WORD_ORDER;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final long _SIGSET_NWORDS = 16L;
    /**
     * {@snippet lang=c :
     * #define _SIGSET_NWORDS 16
     * }
     */
    public static long _SIGSET_NWORDS() {
        return _SIGSET_NWORDS;
    }
    private static final int __NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __NFDBITS 64
     * }
     */
    public static int __NFDBITS() {
        return __NFDBITS;
    }
    private static final int FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FD_SETSIZE 1024
     * }
     */
    public static int FD_SETSIZE() {
        return FD_SETSIZE;
    }
    private static final int NFDBITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define NFDBITS 64
     * }
     */
    public static int NFDBITS() {
        return NFDBITS;
    }
    private static final int __PTHREAD_RWLOCK_ELISION_EXTRA = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_ELISION_EXTRA 0
     * }
     */
    public static int __PTHREAD_RWLOCK_ELISION_EXTRA() {
        return __PTHREAD_RWLOCK_ELISION_EXTRA;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/tmp"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/tmp");
        }
        return Holder.P_tmpdir;
    }
    private static final int __HAVE_DISTINCT_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT16 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT16() {
        return __HAVE_DISTINCT_FLOAT16;
    }
    private static final int __HAVE_DISTINCT_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128X() {
        return __HAVE_DISTINCT_FLOAT128X;
    }
    private static final int __HAVE_FLOAT128_UNLIKE_LDBL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128_UNLIKE_LDBL 0
     * }
     */
    public static int __HAVE_FLOAT128_UNLIKE_LDBL() {
        return __HAVE_FLOAT128_UNLIKE_LDBL;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final int PTHREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int PTHREAD_DESTRUCTOR_ITERATIONS() {
        return PTHREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int SEM_VALUE_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SEM_VALUE_MAX 2147483647
     * }
     */
    public static int SEM_VALUE_MAX() {
        return SEM_VALUE_MAX;
    }
    private static final long SSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SSIZE_MAX 9223372036854775807
     * }
     */
    public static long SSIZE_MAX() {
        return SSIZE_MAX;
    }
    private static final int BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_BASE_MAX 99
     * }
     */
    public static int BC_BASE_MAX() {
        return BC_BASE_MAX;
    }
    private static final int BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define BC_DIM_MAX 2048
     * }
     */
    public static int BC_DIM_MAX() {
        return BC_DIM_MAX;
    }
    private static final int BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_SCALE_MAX 99
     * }
     */
    public static int BC_SCALE_MAX() {
        return BC_SCALE_MAX;
    }
    private static final int BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define BC_STRING_MAX 1000
     * }
     */
    public static int BC_STRING_MAX() {
        return BC_STRING_MAX;
    }
    private static final int EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EXPR_NEST_MAX 32
     * }
     */
    public static int EXPR_NEST_MAX() {
        return EXPR_NEST_MAX;
    }
    private static final int LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define LINE_MAX 2048
     * }
     */
    public static int LINE_MAX() {
        return LINE_MAX;
    }
    private static final int RE_DUP_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define RE_DUP_MAX 32767
     * }
     */
    public static int RE_DUP_MAX() {
        return RE_DUP_MAX;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final long LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_MAX() {
        return LONG_MAX;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final long LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_MIN() {
        return LONG_MIN;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final long ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX -1
     * }
     */
    public static long ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int EWOULDBLOCK = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EWOULDBLOCK 11
     * }
     */
    public static int EWOULDBLOCK() {
        return EWOULDBLOCK;
    }
    private static final int EDEADLOCK = (int)35L;
    /**
     * {@snippet lang=c :
     * #define EDEADLOCK 35
     * }
     */
    public static int EDEADLOCK() {
        return EDEADLOCK;
    }
    private static final int ENOTSUP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define ENOTSUP 95
     * }
     */
    public static int ENOTSUP() {
        return ENOTSUP;
    }
    private static final int ARGP_ERR_UNKNOWN = (int)7L;
    /**
     * {@snippet lang=c :
     * #define ARGP_ERR_UNKNOWN 7
     * }
     */
    public static int ARGP_ERR_UNKNOWN() {
        return ARGP_ERR_UNKNOWN;
    }
    private static final int ARGP_SILENT = (int)50L;
    /**
     * {@snippet lang=c :
     * #define ARGP_SILENT 50
     * }
     */
    public static int ARGP_SILENT() {
        return ARGP_SILENT;
    }
    private static final int ARGP_HELP_DOC = (int)48L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_DOC 48
     * }
     */
    public static int ARGP_HELP_DOC() {
        return ARGP_HELP_DOC;
    }
    private static final int ARGP_HELP_STD_ERR = (int)260L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_STD_ERR 260
     * }
     */
    public static int ARGP_HELP_STD_ERR() {
        return ARGP_HELP_STD_ERR;
    }
    private static final int ARGP_HELP_STD_USAGE = (int)262L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_STD_USAGE 262
     * }
     */
    public static int ARGP_HELP_STD_USAGE() {
        return ARGP_HELP_STD_USAGE;
    }
    private static final int ARGP_HELP_STD_HELP = (int)634L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_STD_HELP 634
     * }
     */
    public static int ARGP_HELP_STD_HELP() {
        return ARGP_HELP_STD_HELP;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_DEFPATH "/usr/bin:/bin"
     * }
     */
    public static MemorySegment _PATH_DEFPATH() {
        class Holder {
            static final MemorySegment _PATH_DEFPATH
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/usr/bin:/bin");
        }
        return Holder._PATH_DEFPATH;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_STDPATH "/usr/bin:/bin:/usr/sbin:/sbin"
     * }
     */
    public static MemorySegment _PATH_STDPATH() {
        class Holder {
            static final MemorySegment _PATH_STDPATH
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/usr/bin:/bin:/usr/sbin:/sbin");
        }
        return Holder._PATH_STDPATH;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_BSHELL "/bin/sh"
     * }
     */
    public static MemorySegment _PATH_BSHELL() {
        class Holder {
            static final MemorySegment _PATH_BSHELL
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/bin/sh");
        }
        return Holder._PATH_BSHELL;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_CONSOLE "/dev/console"
     * }
     */
    public static MemorySegment _PATH_CONSOLE() {
        class Holder {
            static final MemorySegment _PATH_CONSOLE
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/dev/console");
        }
        return Holder._PATH_CONSOLE;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_CSHELL "/bin/csh"
     * }
     */
    public static MemorySegment _PATH_CSHELL() {
        class Holder {
            static final MemorySegment _PATH_CSHELL
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/bin/csh");
        }
        return Holder._PATH_CSHELL;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_DEVDB "/var/run/dev.db"
     * }
     */
    public static MemorySegment _PATH_DEVDB() {
        class Holder {
            static final MemorySegment _PATH_DEVDB
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/run/dev.db");
        }
        return Holder._PATH_DEVDB;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_DEVNULL "/dev/null"
     * }
     */
    public static MemorySegment _PATH_DEVNULL() {
        class Holder {
            static final MemorySegment _PATH_DEVNULL
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/dev/null");
        }
        return Holder._PATH_DEVNULL;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_DRUM "/dev/drum"
     * }
     */
    public static MemorySegment _PATH_DRUM() {
        class Holder {
            static final MemorySegment _PATH_DRUM
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/dev/drum");
        }
        return Holder._PATH_DRUM;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_GSHADOW "/etc/gshadow"
     * }
     */
    public static MemorySegment _PATH_GSHADOW() {
        class Holder {
            static final MemorySegment _PATH_GSHADOW
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/gshadow");
        }
        return Holder._PATH_GSHADOW;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_KLOG "/proc/kmsg"
     * }
     */
    public static MemorySegment _PATH_KLOG() {
        class Holder {
            static final MemorySegment _PATH_KLOG
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/proc/kmsg");
        }
        return Holder._PATH_KLOG;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_KMEM "/dev/kmem"
     * }
     */
    public static MemorySegment _PATH_KMEM() {
        class Holder {
            static final MemorySegment _PATH_KMEM
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/dev/kmem");
        }
        return Holder._PATH_KMEM;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_LASTLOG "/var/log/lastlog"
     * }
     */
    public static MemorySegment _PATH_LASTLOG() {
        class Holder {
            static final MemorySegment _PATH_LASTLOG
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/log/lastlog");
        }
        return Holder._PATH_LASTLOG;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_MAILDIR "/var/mail"
     * }
     */
    public static MemorySegment _PATH_MAILDIR() {
        class Holder {
            static final MemorySegment _PATH_MAILDIR
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/mail");
        }
        return Holder._PATH_MAILDIR;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_MAN "/usr/share/man"
     * }
     */
    public static MemorySegment _PATH_MAN() {
        class Holder {
            static final MemorySegment _PATH_MAN
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/usr/share/man");
        }
        return Holder._PATH_MAN;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_MEM "/dev/mem"
     * }
     */
    public static MemorySegment _PATH_MEM() {
        class Holder {
            static final MemorySegment _PATH_MEM
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/dev/mem");
        }
        return Holder._PATH_MEM;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_MNTTAB "/etc/fstab"
     * }
     */
    public static MemorySegment _PATH_MNTTAB() {
        class Holder {
            static final MemorySegment _PATH_MNTTAB
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/fstab");
        }
        return Holder._PATH_MNTTAB;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_MOUNTED "/etc/mtab"
     * }
     */
    public static MemorySegment _PATH_MOUNTED() {
        class Holder {
            static final MemorySegment _PATH_MOUNTED
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/mtab");
        }
        return Holder._PATH_MOUNTED;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_NOLOGIN "/etc/nologin"
     * }
     */
    public static MemorySegment _PATH_NOLOGIN() {
        class Holder {
            static final MemorySegment _PATH_NOLOGIN
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/nologin");
        }
        return Holder._PATH_NOLOGIN;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_PRESERVE "/var/lib"
     * }
     */
    public static MemorySegment _PATH_PRESERVE() {
        class Holder {
            static final MemorySegment _PATH_PRESERVE
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/lib");
        }
        return Holder._PATH_PRESERVE;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_RWHODIR "/var/spool/rwho"
     * }
     */
    public static MemorySegment _PATH_RWHODIR() {
        class Holder {
            static final MemorySegment _PATH_RWHODIR
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/spool/rwho");
        }
        return Holder._PATH_RWHODIR;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_SENDMAIL "/usr/sbin/sendmail"
     * }
     */
    public static MemorySegment _PATH_SENDMAIL() {
        class Holder {
            static final MemorySegment _PATH_SENDMAIL
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/usr/sbin/sendmail");
        }
        return Holder._PATH_SENDMAIL;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_SHADOW "/etc/shadow"
     * }
     */
    public static MemorySegment _PATH_SHADOW() {
        class Holder {
            static final MemorySegment _PATH_SHADOW
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/shadow");
        }
        return Holder._PATH_SHADOW;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_SHELLS "/etc/shells"
     * }
     */
    public static MemorySegment _PATH_SHELLS() {
        class Holder {
            static final MemorySegment _PATH_SHELLS
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/shells");
        }
        return Holder._PATH_SHELLS;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_TTY "/dev/tty"
     * }
     */
    public static MemorySegment _PATH_TTY() {
        class Holder {
            static final MemorySegment _PATH_TTY
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/dev/tty");
        }
        return Holder._PATH_TTY;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_UNIX "/boot/vmlinux"
     * }
     */
    public static MemorySegment _PATH_UNIX() {
        class Holder {
            static final MemorySegment _PATH_UNIX
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/boot/vmlinux");
        }
        return Holder._PATH_UNIX;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_UTMP "/var/run/utmp"
     * }
     */
    public static MemorySegment _PATH_UTMP() {
        class Holder {
            static final MemorySegment _PATH_UTMP
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/run/utmp");
        }
        return Holder._PATH_UTMP;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_VI "/usr/bin/vi"
     * }
     */
    public static MemorySegment _PATH_VI() {
        class Holder {
            static final MemorySegment _PATH_VI
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/usr/bin/vi");
        }
        return Holder._PATH_VI;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_WTMP "/var/log/wtmp"
     * }
     */
    public static MemorySegment _PATH_WTMP() {
        class Holder {
            static final MemorySegment _PATH_WTMP
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/log/wtmp");
        }
        return Holder._PATH_WTMP;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_DEV "/dev/"
     * }
     */
    public static MemorySegment _PATH_DEV() {
        class Holder {
            static final MemorySegment _PATH_DEV
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/dev/");
        }
        return Holder._PATH_DEV;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_TMP "/tmp/"
     * }
     */
    public static MemorySegment _PATH_TMP() {
        class Holder {
            static final MemorySegment _PATH_TMP
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/tmp/");
        }
        return Holder._PATH_TMP;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_VARDB "/var/lib/misc/"
     * }
     */
    public static MemorySegment _PATH_VARDB() {
        class Holder {
            static final MemorySegment _PATH_VARDB
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/lib/misc/");
        }
        return Holder._PATH_VARDB;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_VARRUN "/var/run/"
     * }
     */
    public static MemorySegment _PATH_VARRUN() {
        class Holder {
            static final MemorySegment _PATH_VARRUN
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/run/");
        }
        return Holder._PATH_VARRUN;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_VARTMP "/var/tmp/"
     * }
     */
    public static MemorySegment _PATH_VARTMP() {
        class Holder {
            static final MemorySegment _PATH_VARTMP
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/var/tmp/");
        }
        return Holder._PATH_VARTMP;
    }
    /**
     * {@snippet lang=c :
     * #define GSHADOW "/etc/gshadow"
     * }
     */
    public static MemorySegment GSHADOW() {
        class Holder {
            static final MemorySegment GSHADOW
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/gshadow");
        }
        return Holder.GSHADOW;
    }
    private static final int PF_UNIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_UNIX 1
     * }
     */
    public static int PF_UNIX() {
        return PF_UNIX;
    }
    private static final int PF_FILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_FILE 1
     * }
     */
    public static int PF_FILE() {
        return PF_FILE;
    }
    private static final int PF_ROUTE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PF_ROUTE 16
     * }
     */
    public static int PF_ROUTE() {
        return PF_ROUTE;
    }
    private static final int AF_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AF_UNSPEC 0
     * }
     */
    public static int AF_UNSPEC() {
        return AF_UNSPEC;
    }
    private static final int AF_LOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AF_LOCAL 1
     * }
     */
    public static int AF_LOCAL() {
        return AF_LOCAL;
    }
    private static final int AF_UNIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AF_UNIX 1
     * }
     */
    public static int AF_UNIX() {
        return AF_UNIX;
    }
    private static final int AF_FILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AF_FILE 1
     * }
     */
    public static int AF_FILE() {
        return AF_FILE;
    }
    private static final int AF_INET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AF_INET 2
     * }
     */
    public static int AF_INET() {
        return AF_INET;
    }
    private static final int AF_AX25 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define AF_AX25 3
     * }
     */
    public static int AF_AX25() {
        return AF_AX25;
    }
    private static final int AF_IPX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AF_IPX 4
     * }
     */
    public static int AF_IPX() {
        return AF_IPX;
    }
    private static final int AF_APPLETALK = (int)5L;
    /**
     * {@snippet lang=c :
     * #define AF_APPLETALK 5
     * }
     */
    public static int AF_APPLETALK() {
        return AF_APPLETALK;
    }
    private static final int AF_NETROM = (int)6L;
    /**
     * {@snippet lang=c :
     * #define AF_NETROM 6
     * }
     */
    public static int AF_NETROM() {
        return AF_NETROM;
    }
    private static final int AF_BRIDGE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define AF_BRIDGE 7
     * }
     */
    public static int AF_BRIDGE() {
        return AF_BRIDGE;
    }
    private static final int AF_ATMPVC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AF_ATMPVC 8
     * }
     */
    public static int AF_ATMPVC() {
        return AF_ATMPVC;
    }
    private static final int AF_X25 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define AF_X25 9
     * }
     */
    public static int AF_X25() {
        return AF_X25;
    }
    private static final int AF_INET6 = (int)10L;
    /**
     * {@snippet lang=c :
     * #define AF_INET6 10
     * }
     */
    public static int AF_INET6() {
        return AF_INET6;
    }
    private static final int AF_ROSE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define AF_ROSE 11
     * }
     */
    public static int AF_ROSE() {
        return AF_ROSE;
    }
    private static final int AF_DECnet = (int)12L;
    /**
     * {@snippet lang=c :
     * #define AF_DECnet 12
     * }
     */
    public static int AF_DECnet() {
        return AF_DECnet;
    }
    private static final int AF_NETBEUI = (int)13L;
    /**
     * {@snippet lang=c :
     * #define AF_NETBEUI 13
     * }
     */
    public static int AF_NETBEUI() {
        return AF_NETBEUI;
    }
    private static final int AF_SECURITY = (int)14L;
    /**
     * {@snippet lang=c :
     * #define AF_SECURITY 14
     * }
     */
    public static int AF_SECURITY() {
        return AF_SECURITY;
    }
    private static final int AF_KEY = (int)15L;
    /**
     * {@snippet lang=c :
     * #define AF_KEY 15
     * }
     */
    public static int AF_KEY() {
        return AF_KEY;
    }
    private static final int AF_NETLINK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AF_NETLINK 16
     * }
     */
    public static int AF_NETLINK() {
        return AF_NETLINK;
    }
    private static final int AF_ROUTE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AF_ROUTE 16
     * }
     */
    public static int AF_ROUTE() {
        return AF_ROUTE;
    }
    private static final int AF_PACKET = (int)17L;
    /**
     * {@snippet lang=c :
     * #define AF_PACKET 17
     * }
     */
    public static int AF_PACKET() {
        return AF_PACKET;
    }
    private static final int AF_ASH = (int)18L;
    /**
     * {@snippet lang=c :
     * #define AF_ASH 18
     * }
     */
    public static int AF_ASH() {
        return AF_ASH;
    }
    private static final int AF_ECONET = (int)19L;
    /**
     * {@snippet lang=c :
     * #define AF_ECONET 19
     * }
     */
    public static int AF_ECONET() {
        return AF_ECONET;
    }
    private static final int AF_ATMSVC = (int)20L;
    /**
     * {@snippet lang=c :
     * #define AF_ATMSVC 20
     * }
     */
    public static int AF_ATMSVC() {
        return AF_ATMSVC;
    }
    private static final int AF_RDS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define AF_RDS 21
     * }
     */
    public static int AF_RDS() {
        return AF_RDS;
    }
    private static final int AF_SNA = (int)22L;
    /**
     * {@snippet lang=c :
     * #define AF_SNA 22
     * }
     */
    public static int AF_SNA() {
        return AF_SNA;
    }
    private static final int AF_IRDA = (int)23L;
    /**
     * {@snippet lang=c :
     * #define AF_IRDA 23
     * }
     */
    public static int AF_IRDA() {
        return AF_IRDA;
    }
    private static final int AF_PPPOX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define AF_PPPOX 24
     * }
     */
    public static int AF_PPPOX() {
        return AF_PPPOX;
    }
    private static final int AF_WANPIPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define AF_WANPIPE 25
     * }
     */
    public static int AF_WANPIPE() {
        return AF_WANPIPE;
    }
    private static final int AF_LLC = (int)26L;
    /**
     * {@snippet lang=c :
     * #define AF_LLC 26
     * }
     */
    public static int AF_LLC() {
        return AF_LLC;
    }
    private static final int AF_IB = (int)27L;
    /**
     * {@snippet lang=c :
     * #define AF_IB 27
     * }
     */
    public static int AF_IB() {
        return AF_IB;
    }
    private static final int AF_MPLS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define AF_MPLS 28
     * }
     */
    public static int AF_MPLS() {
        return AF_MPLS;
    }
    private static final int AF_CAN = (int)29L;
    /**
     * {@snippet lang=c :
     * #define AF_CAN 29
     * }
     */
    public static int AF_CAN() {
        return AF_CAN;
    }
    private static final int AF_TIPC = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AF_TIPC 30
     * }
     */
    public static int AF_TIPC() {
        return AF_TIPC;
    }
    private static final int AF_BLUETOOTH = (int)31L;
    /**
     * {@snippet lang=c :
     * #define AF_BLUETOOTH 31
     * }
     */
    public static int AF_BLUETOOTH() {
        return AF_BLUETOOTH;
    }
    private static final int AF_IUCV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AF_IUCV 32
     * }
     */
    public static int AF_IUCV() {
        return AF_IUCV;
    }
    private static final int AF_RXRPC = (int)33L;
    /**
     * {@snippet lang=c :
     * #define AF_RXRPC 33
     * }
     */
    public static int AF_RXRPC() {
        return AF_RXRPC;
    }
    private static final int AF_ISDN = (int)34L;
    /**
     * {@snippet lang=c :
     * #define AF_ISDN 34
     * }
     */
    public static int AF_ISDN() {
        return AF_ISDN;
    }
    private static final int AF_PHONET = (int)35L;
    /**
     * {@snippet lang=c :
     * #define AF_PHONET 35
     * }
     */
    public static int AF_PHONET() {
        return AF_PHONET;
    }
    private static final int AF_IEEE802154 = (int)36L;
    /**
     * {@snippet lang=c :
     * #define AF_IEEE802154 36
     * }
     */
    public static int AF_IEEE802154() {
        return AF_IEEE802154;
    }
    private static final int AF_CAIF = (int)37L;
    /**
     * {@snippet lang=c :
     * #define AF_CAIF 37
     * }
     */
    public static int AF_CAIF() {
        return AF_CAIF;
    }
    private static final int AF_ALG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define AF_ALG 38
     * }
     */
    public static int AF_ALG() {
        return AF_ALG;
    }
    private static final int AF_NFC = (int)39L;
    /**
     * {@snippet lang=c :
     * #define AF_NFC 39
     * }
     */
    public static int AF_NFC() {
        return AF_NFC;
    }
    private static final int AF_VSOCK = (int)40L;
    /**
     * {@snippet lang=c :
     * #define AF_VSOCK 40
     * }
     */
    public static int AF_VSOCK() {
        return AF_VSOCK;
    }
    private static final int AF_KCM = (int)41L;
    /**
     * {@snippet lang=c :
     * #define AF_KCM 41
     * }
     */
    public static int AF_KCM() {
        return AF_KCM;
    }
    private static final int AF_QIPCRTR = (int)42L;
    /**
     * {@snippet lang=c :
     * #define AF_QIPCRTR 42
     * }
     */
    public static int AF_QIPCRTR() {
        return AF_QIPCRTR;
    }
    private static final int AF_SMC = (int)43L;
    /**
     * {@snippet lang=c :
     * #define AF_SMC 43
     * }
     */
    public static int AF_SMC() {
        return AF_SMC;
    }
    private static final int AF_XDP = (int)44L;
    /**
     * {@snippet lang=c :
     * #define AF_XDP 44
     * }
     */
    public static int AF_XDP() {
        return AF_XDP;
    }
    private static final int AF_MCTP = (int)45L;
    /**
     * {@snippet lang=c :
     * #define AF_MCTP 45
     * }
     */
    public static int AF_MCTP() {
        return AF_MCTP;
    }
    private static final int AF_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define AF_MAX 46
     * }
     */
    public static int AF_MAX() {
        return AF_MAX;
    }
    private static final long __SOCKADDR_COMMON_SIZE = 2L;
    /**
     * {@snippet lang=c :
     * #define __SOCKADDR_COMMON_SIZE 2
     * }
     */
    public static long __SOCKADDR_COMMON_SIZE() {
        return __SOCKADDR_COMMON_SIZE;
    }
    private static final long _SS_PADSIZE = 118L;
    /**
     * {@snippet lang=c :
     * #define _SS_PADSIZE 118
     * }
     */
    public static long _SS_PADSIZE() {
        return _SS_PADSIZE;
    }
    private static final int SO_GET_FILTER = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SO_GET_FILTER 26
     * }
     */
    public static int SO_GET_FILTER() {
        return SO_GET_FILTER;
    }
    private static final int SCM_WIFI_STATUS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define SCM_WIFI_STATUS 41
     * }
     */
    public static int SCM_WIFI_STATUS() {
        return SCM_WIFI_STATUS;
    }
    private static final int SO_DETACH_BPF = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_BPF 27
     * }
     */
    public static int SO_DETACH_BPF() {
        return SO_DETACH_BPF;
    }
    private static final int SCM_TXTIME = (int)61L;
    /**
     * {@snippet lang=c :
     * #define SCM_TXTIME 61
     * }
     */
    public static int SCM_TXTIME() {
        return SCM_TXTIME;
    }
    private static final int SO_TIMESTAMP = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP 29
     * }
     */
    public static int SO_TIMESTAMP() {
        return SO_TIMESTAMP;
    }
    private static final int SO_TIMESTAMPNS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS 35
     * }
     */
    public static int SO_TIMESTAMPNS() {
        return SO_TIMESTAMPNS;
    }
    private static final int SO_TIMESTAMPING = (int)37L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING 37
     * }
     */
    public static int SO_TIMESTAMPING() {
        return SO_TIMESTAMPING;
    }
    private static final int SO_RCVTIMEO = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO 20
     * }
     */
    public static int SO_RCVTIMEO() {
        return SO_RCVTIMEO;
    }
    private static final int SO_SNDTIMEO = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO 21
     * }
     */
    public static int SO_SNDTIMEO() {
        return SO_SNDTIMEO;
    }
    private static final int SCM_TIMESTAMP = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMP 29
     * }
     */
    public static int SCM_TIMESTAMP() {
        return SCM_TIMESTAMP;
    }
    private static final int SCM_TIMESTAMPNS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPNS 35
     * }
     */
    public static int SCM_TIMESTAMPNS() {
        return SCM_TIMESTAMPNS;
    }
    private static final int SCM_TIMESTAMPING = (int)37L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING 37
     * }
     */
    public static int SCM_TIMESTAMPING() {
        return SCM_TIMESTAMPING;
    }
    private static final int IP_RECVRETOPTS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVRETOPTS 7
     * }
     */
    public static int IP_RECVRETOPTS() {
        return IP_RECVRETOPTS;
    }
    private static final int IP_RECVORIGDSTADDR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVORIGDSTADDR 20
     * }
     */
    public static int IP_RECVORIGDSTADDR() {
        return IP_RECVORIGDSTADDR;
    }
    private static final int IPV6_RECVORIGDSTADDR = (int)74L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVORIGDSTADDR 74
     * }
     */
    public static int IPV6_RECVORIGDSTADDR() {
        return IPV6_RECVORIGDSTADDR;
    }
    private static final int IPV6_ADD_MEMBERSHIP = (int)20L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ADD_MEMBERSHIP 20
     * }
     */
    public static int IPV6_ADD_MEMBERSHIP() {
        return IPV6_ADD_MEMBERSHIP;
    }
    private static final int IPV6_DROP_MEMBERSHIP = (int)21L;
    /**
     * {@snippet lang=c :
     * #define IPV6_DROP_MEMBERSHIP 21
     * }
     */
    public static int IPV6_DROP_MEMBERSHIP() {
        return IPV6_DROP_MEMBERSHIP;
    }
    private static final int IPV6_RXHOPOPTS = (int)54L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RXHOPOPTS 54
     * }
     */
    public static int IPV6_RXHOPOPTS() {
        return IPV6_RXHOPOPTS;
    }
    private static final int IPV6_RXDSTOPTS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RXDSTOPTS 59
     * }
     */
    public static int IPV6_RXDSTOPTS() {
        return IPV6_RXDSTOPTS;
    }
    private static final int IN_CLASSA_NET = (int)4278190080L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSA_NET 4278190080
     * }
     */
    public static int IN_CLASSA_NET() {
        return IN_CLASSA_NET;
    }
    private static final int IN_CLASSA_HOST = (int)16777215L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSA_HOST 16777215
     * }
     */
    public static int IN_CLASSA_HOST() {
        return IN_CLASSA_HOST;
    }
    private static final int IN_CLASSB_NET = (int)4294901760L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSB_NET 4294901760
     * }
     */
    public static int IN_CLASSB_NET() {
        return IN_CLASSB_NET;
    }
    private static final int IN_CLASSB_HOST = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSB_HOST 65535
     * }
     */
    public static int IN_CLASSB_HOST() {
        return IN_CLASSB_HOST;
    }
    private static final int IN_CLASSC_NET = (int)4294967040L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSC_NET 4294967040
     * }
     */
    public static int IN_CLASSC_NET() {
        return IN_CLASSC_NET;
    }
    private static final int IN_CLASSC_HOST = (int)255L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSC_HOST 255
     * }
     */
    public static int IN_CLASSC_HOST() {
        return IN_CLASSC_HOST;
    }
    private static final int INADDR_ANY = (int)0L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ANY 0
     * }
     */
    public static int INADDR_ANY() {
        return INADDR_ANY;
    }
    private static final int INADDR_BROADCAST = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define INADDR_BROADCAST 4294967295
     * }
     */
    public static int INADDR_BROADCAST() {
        return INADDR_BROADCAST;
    }
    private static final int INADDR_NONE = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define INADDR_NONE 4294967295
     * }
     */
    public static int INADDR_NONE() {
        return INADDR_NONE;
    }
    private static final int INADDR_DUMMY = (int)3221225480L;
    /**
     * {@snippet lang=c :
     * #define INADDR_DUMMY 3221225480
     * }
     */
    public static int INADDR_DUMMY() {
        return INADDR_DUMMY;
    }
    private static final int INADDR_LOOPBACK = (int)2130706433L;
    /**
     * {@snippet lang=c :
     * #define INADDR_LOOPBACK 2130706433
     * }
     */
    public static int INADDR_LOOPBACK() {
        return INADDR_LOOPBACK;
    }
    private static final int INADDR_UNSPEC_GROUP = (int)3758096384L;
    /**
     * {@snippet lang=c :
     * #define INADDR_UNSPEC_GROUP 3758096384
     * }
     */
    public static int INADDR_UNSPEC_GROUP() {
        return INADDR_UNSPEC_GROUP;
    }
    private static final int INADDR_ALLHOSTS_GROUP = (int)3758096385L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ALLHOSTS_GROUP 3758096385
     * }
     */
    public static int INADDR_ALLHOSTS_GROUP() {
        return INADDR_ALLHOSTS_GROUP;
    }
    private static final int INADDR_ALLRTRS_GROUP = (int)3758096386L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ALLRTRS_GROUP 3758096386
     * }
     */
    public static int INADDR_ALLRTRS_GROUP() {
        return INADDR_ALLRTRS_GROUP;
    }
    private static final int INADDR_ALLSNOOPERS_GROUP = (int)3758096490L;
    /**
     * {@snippet lang=c :
     * #define INADDR_ALLSNOOPERS_GROUP 3758096490
     * }
     */
    public static int INADDR_ALLSNOOPERS_GROUP() {
        return INADDR_ALLSNOOPERS_GROUP;
    }
    private static final int INADDR_MAX_LOCAL_GROUP = (int)3758096639L;
    /**
     * {@snippet lang=c :
     * #define INADDR_MAX_LOCAL_GROUP 3758096639
     * }
     */
    public static int INADDR_MAX_LOCAL_GROUP() {
        return INADDR_MAX_LOCAL_GROUP;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_HEQUIV "/etc/hosts.equiv"
     * }
     */
    public static MemorySegment _PATH_HEQUIV() {
        class Holder {
            static final MemorySegment _PATH_HEQUIV
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/hosts.equiv");
        }
        return Holder._PATH_HEQUIV;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_HOSTS "/etc/hosts"
     * }
     */
    public static MemorySegment _PATH_HOSTS() {
        class Holder {
            static final MemorySegment _PATH_HOSTS
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/hosts");
        }
        return Holder._PATH_HOSTS;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_NETWORKS "/etc/networks"
     * }
     */
    public static MemorySegment _PATH_NETWORKS() {
        class Holder {
            static final MemorySegment _PATH_NETWORKS
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/networks");
        }
        return Holder._PATH_NETWORKS;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_NSSWITCH_CONF "/etc/nsswitch.conf"
     * }
     */
    public static MemorySegment _PATH_NSSWITCH_CONF() {
        class Holder {
            static final MemorySegment _PATH_NSSWITCH_CONF
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/nsswitch.conf");
        }
        return Holder._PATH_NSSWITCH_CONF;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_PROTOCOLS "/etc/protocols"
     * }
     */
    public static MemorySegment _PATH_PROTOCOLS() {
        class Holder {
            static final MemorySegment _PATH_PROTOCOLS
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/protocols");
        }
        return Holder._PATH_PROTOCOLS;
    }
    /**
     * {@snippet lang=c :
     * #define _PATH_SERVICES "/etc/services"
     * }
     */
    public static MemorySegment _PATH_SERVICES() {
        class Holder {
            static final MemorySegment _PATH_SERVICES
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/services");
        }
        return Holder._PATH_SERVICES;
    }
    private static final int NETDB_INTERNAL = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define NETDB_INTERNAL -1
     * }
     */
    public static int NETDB_INTERNAL() {
        return NETDB_INTERNAL;
    }
    private static final int NO_ADDRESS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define NO_ADDRESS 4
     * }
     */
    public static int NO_ADDRESS() {
        return NO_ADDRESS;
    }
    private static final int EAI_BADFLAGS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EAI_BADFLAGS -1
     * }
     */
    public static int EAI_BADFLAGS() {
        return EAI_BADFLAGS;
    }
    private static final int EAI_NONAME = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define EAI_NONAME -2
     * }
     */
    public static int EAI_NONAME() {
        return EAI_NONAME;
    }
    private static final int EAI_AGAIN = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define EAI_AGAIN -3
     * }
     */
    public static int EAI_AGAIN() {
        return EAI_AGAIN;
    }
    private static final int EAI_FAIL = (int)-4L;
    /**
     * {@snippet lang=c :
     * #define EAI_FAIL -4
     * }
     */
    public static int EAI_FAIL() {
        return EAI_FAIL;
    }
    private static final int EAI_FAMILY = (int)-6L;
    /**
     * {@snippet lang=c :
     * #define EAI_FAMILY -6
     * }
     */
    public static int EAI_FAMILY() {
        return EAI_FAMILY;
    }
    private static final int EAI_SOCKTYPE = (int)-7L;
    /**
     * {@snippet lang=c :
     * #define EAI_SOCKTYPE -7
     * }
     */
    public static int EAI_SOCKTYPE() {
        return EAI_SOCKTYPE;
    }
    private static final int EAI_SERVICE = (int)-8L;
    /**
     * {@snippet lang=c :
     * #define EAI_SERVICE -8
     * }
     */
    public static int EAI_SERVICE() {
        return EAI_SERVICE;
    }
    private static final int EAI_MEMORY = (int)-10L;
    /**
     * {@snippet lang=c :
     * #define EAI_MEMORY -10
     * }
     */
    public static int EAI_MEMORY() {
        return EAI_MEMORY;
    }
    private static final int EAI_SYSTEM = (int)-11L;
    /**
     * {@snippet lang=c :
     * #define EAI_SYSTEM -11
     * }
     */
    public static int EAI_SYSTEM() {
        return EAI_SYSTEM;
    }
    private static final int EAI_OVERFLOW = (int)-12L;
    /**
     * {@snippet lang=c :
     * #define EAI_OVERFLOW -12
     * }
     */
    public static int EAI_OVERFLOW() {
        return EAI_OVERFLOW;
    }
    /**
     * {@snippet lang=c :
     * #define SHADOW "/etc/shadow"
     * }
     */
    public static MemorySegment SHADOW() {
        class Holder {
            static final MemorySegment SHADOW
                = nss_proto_h.LIBRARY_ARENA.allocateFrom("/etc/shadow");
        }
        return Holder.SHADOW;
    }
    private static final int PAM_SILENT = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define PAM_SILENT 32768
     * }
     */
    public static int PAM_SILENT() {
        return PAM_SILENT;
    }
    private static final int PAM_DISALLOW_NULL_AUTHTOK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PAM_DISALLOW_NULL_AUTHTOK 1
     * }
     */
    public static int PAM_DISALLOW_NULL_AUTHTOK() {
        return PAM_DISALLOW_NULL_AUTHTOK;
    }
    private static final int PAM_ESTABLISH_CRED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PAM_ESTABLISH_CRED 2
     * }
     */
    public static int PAM_ESTABLISH_CRED() {
        return PAM_ESTABLISH_CRED;
    }
    private static final int PAM_DELETE_CRED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PAM_DELETE_CRED 4
     * }
     */
    public static int PAM_DELETE_CRED() {
        return PAM_DELETE_CRED;
    }
    private static final int PAM_REINITIALIZE_CRED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PAM_REINITIALIZE_CRED 8
     * }
     */
    public static int PAM_REINITIALIZE_CRED() {
        return PAM_REINITIALIZE_CRED;
    }
    private static final int PAM_REFRESH_CRED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PAM_REFRESH_CRED 16
     * }
     */
    public static int PAM_REFRESH_CRED() {
        return PAM_REFRESH_CRED;
    }
    private static final int PAM_CHANGE_EXPIRED_AUTHTOK = (int)32L;
    /**
     * {@snippet lang=c :
     * #define PAM_CHANGE_EXPIRED_AUTHTOK 32
     * }
     */
    public static int PAM_CHANGE_EXPIRED_AUTHTOK() {
        return PAM_CHANGE_EXPIRED_AUTHTOK;
    }
    private static final int PAM_AUTHTOK_RECOVER_ERR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTHTOK_RECOVER_ERR 21
     * }
     */
    public static int PAM_AUTHTOK_RECOVER_ERR() {
        return PAM_AUTHTOK_RECOVER_ERR;
    }
}

