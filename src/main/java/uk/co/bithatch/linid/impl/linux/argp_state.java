/*
 * Copyright © 2025 Bithatch (tanktarta@gmail.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this
 * software and associated documentation files (the “Software”), to deal in the Software
 * without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
// Generated by jextract

package uk.co.bithatch.linid.impl.linux;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct argp_state {
 *     const struct argp *root_argp;
 *     int argc;
 *     char **argv;
 *     int next;
 *     unsigned int flags;
 *     unsigned int arg_num;
 *     int quoted;
 *     void *input;
 *     void **child_inputs;
 *     void *hook;
 *     char *name;
 *     FILE *err_stream;
 *     FILE *out_stream;
 *     void *pstate;
 * }
 * }
 */
public class argp_state {

    argp_state() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        nss_proto_h.C_POINTER.withName("root_argp"),
        nss_proto_h.C_INT.withName("argc"),
        MemoryLayout.paddingLayout(4),
        nss_proto_h.C_POINTER.withName("argv"),
        nss_proto_h.C_INT.withName("next"),
        nss_proto_h.C_INT.withName("flags"),
        nss_proto_h.C_INT.withName("arg_num"),
        nss_proto_h.C_INT.withName("quoted"),
        nss_proto_h.C_POINTER.withName("input"),
        nss_proto_h.C_POINTER.withName("child_inputs"),
        nss_proto_h.C_POINTER.withName("hook"),
        nss_proto_h.C_POINTER.withName("name"),
        nss_proto_h.C_POINTER.withName("err_stream"),
        nss_proto_h.C_POINTER.withName("out_stream"),
        nss_proto_h.C_POINTER.withName("pstate")
    ).withName("argp_state");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout root_argp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("root_argp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const struct argp *root_argp
     * }
     */
    public static final AddressLayout root_argp$layout() {
        return root_argp$LAYOUT;
    }

    private static final long root_argp$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const struct argp *root_argp
     * }
     */
    public static final long root_argp$offset() {
        return root_argp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const struct argp *root_argp
     * }
     */
    public static MemorySegment root_argp(MemorySegment struct) {
        return struct.get(root_argp$LAYOUT, root_argp$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const struct argp *root_argp
     * }
     */
    public static void root_argp(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(root_argp$LAYOUT, root_argp$OFFSET, fieldValue);
    }

    private static final OfInt argc$LAYOUT = (OfInt)$LAYOUT.select(groupElement("argc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int argc
     * }
     */
    public static final OfInt argc$layout() {
        return argc$LAYOUT;
    }

    private static final long argc$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int argc
     * }
     */
    public static final long argc$offset() {
        return argc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int argc
     * }
     */
    public static int argc(MemorySegment struct) {
        return struct.get(argc$LAYOUT, argc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int argc
     * }
     */
    public static void argc(MemorySegment struct, int fieldValue) {
        struct.set(argc$LAYOUT, argc$OFFSET, fieldValue);
    }

    private static final AddressLayout argv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("argv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char **argv
     * }
     */
    public static final AddressLayout argv$layout() {
        return argv$LAYOUT;
    }

    private static final long argv$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char **argv
     * }
     */
    public static final long argv$offset() {
        return argv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char **argv
     * }
     */
    public static MemorySegment argv(MemorySegment struct) {
        return struct.get(argv$LAYOUT, argv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char **argv
     * }
     */
    public static void argv(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(argv$LAYOUT, argv$OFFSET, fieldValue);
    }

    private static final OfInt next$LAYOUT = (OfInt)$LAYOUT.select(groupElement("next"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int next
     * }
     */
    public static final OfInt next$layout() {
        return next$LAYOUT;
    }

    private static final long next$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int next
     * }
     */
    public static final long next$offset() {
        return next$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int next
     * }
     */
    public static int next(MemorySegment struct) {
        return struct.get(next$LAYOUT, next$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int next
     * }
     */
    public static void next(MemorySegment struct, int fieldValue) {
        struct.set(next$LAYOUT, next$OFFSET, fieldValue);
    }

    private static final OfInt flags$LAYOUT = (OfInt)$LAYOUT.select(groupElement("flags"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static final OfInt flags$layout() {
        return flags$LAYOUT;
    }

    private static final long flags$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static final long flags$offset() {
        return flags$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static int flags(MemorySegment struct) {
        return struct.get(flags$LAYOUT, flags$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int flags
     * }
     */
    public static void flags(MemorySegment struct, int fieldValue) {
        struct.set(flags$LAYOUT, flags$OFFSET, fieldValue);
    }

    private static final OfInt arg_num$LAYOUT = (OfInt)$LAYOUT.select(groupElement("arg_num"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int arg_num
     * }
     */
    public static final OfInt arg_num$layout() {
        return arg_num$LAYOUT;
    }

    private static final long arg_num$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int arg_num
     * }
     */
    public static final long arg_num$offset() {
        return arg_num$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int arg_num
     * }
     */
    public static int arg_num(MemorySegment struct) {
        return struct.get(arg_num$LAYOUT, arg_num$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int arg_num
     * }
     */
    public static void arg_num(MemorySegment struct, int fieldValue) {
        struct.set(arg_num$LAYOUT, arg_num$OFFSET, fieldValue);
    }

    private static final OfInt quoted$LAYOUT = (OfInt)$LAYOUT.select(groupElement("quoted"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int quoted
     * }
     */
    public static final OfInt quoted$layout() {
        return quoted$LAYOUT;
    }

    private static final long quoted$OFFSET = 36;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int quoted
     * }
     */
    public static final long quoted$offset() {
        return quoted$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int quoted
     * }
     */
    public static int quoted(MemorySegment struct) {
        return struct.get(quoted$LAYOUT, quoted$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int quoted
     * }
     */
    public static void quoted(MemorySegment struct, int fieldValue) {
        struct.set(quoted$LAYOUT, quoted$OFFSET, fieldValue);
    }

    private static final AddressLayout input$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("input"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *input
     * }
     */
    public static final AddressLayout input$layout() {
        return input$LAYOUT;
    }

    private static final long input$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *input
     * }
     */
    public static final long input$offset() {
        return input$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *input
     * }
     */
    public static MemorySegment input(MemorySegment struct) {
        return struct.get(input$LAYOUT, input$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *input
     * }
     */
    public static void input(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(input$LAYOUT, input$OFFSET, fieldValue);
    }

    private static final AddressLayout child_inputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("child_inputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void **child_inputs
     * }
     */
    public static final AddressLayout child_inputs$layout() {
        return child_inputs$LAYOUT;
    }

    private static final long child_inputs$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void **child_inputs
     * }
     */
    public static final long child_inputs$offset() {
        return child_inputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void **child_inputs
     * }
     */
    public static MemorySegment child_inputs(MemorySegment struct) {
        return struct.get(child_inputs$LAYOUT, child_inputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void **child_inputs
     * }
     */
    public static void child_inputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(child_inputs$LAYOUT, child_inputs$OFFSET, fieldValue);
    }

    private static final AddressLayout hook$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("hook"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *hook
     * }
     */
    public static final AddressLayout hook$layout() {
        return hook$LAYOUT;
    }

    private static final long hook$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *hook
     * }
     */
    public static final long hook$offset() {
        return hook$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *hook
     * }
     */
    public static MemorySegment hook(MemorySegment struct) {
        return struct.get(hook$LAYOUT, hook$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *hook
     * }
     */
    public static void hook(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(hook$LAYOUT, hook$OFFSET, fieldValue);
    }

    private static final AddressLayout name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *name
     * }
     */
    public static final AddressLayout name$layout() {
        return name$LAYOUT;
    }

    private static final long name$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *name
     * }
     */
    public static final long name$offset() {
        return name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *name
     * }
     */
    public static MemorySegment name(MemorySegment struct) {
        return struct.get(name$LAYOUT, name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *name
     * }
     */
    public static void name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(name$LAYOUT, name$OFFSET, fieldValue);
    }

    private static final AddressLayout err_stream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("err_stream"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FILE *err_stream
     * }
     */
    public static final AddressLayout err_stream$layout() {
        return err_stream$LAYOUT;
    }

    private static final long err_stream$OFFSET = 72;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FILE *err_stream
     * }
     */
    public static final long err_stream$offset() {
        return err_stream$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FILE *err_stream
     * }
     */
    public static MemorySegment err_stream(MemorySegment struct) {
        return struct.get(err_stream$LAYOUT, err_stream$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FILE *err_stream
     * }
     */
    public static void err_stream(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(err_stream$LAYOUT, err_stream$OFFSET, fieldValue);
    }

    private static final AddressLayout out_stream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("out_stream"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * FILE *out_stream
     * }
     */
    public static final AddressLayout out_stream$layout() {
        return out_stream$LAYOUT;
    }

    private static final long out_stream$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * FILE *out_stream
     * }
     */
    public static final long out_stream$offset() {
        return out_stream$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * FILE *out_stream
     * }
     */
    public static MemorySegment out_stream(MemorySegment struct) {
        return struct.get(out_stream$LAYOUT, out_stream$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * FILE *out_stream
     * }
     */
    public static void out_stream(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(out_stream$LAYOUT, out_stream$OFFSET, fieldValue);
    }

    private static final AddressLayout pstate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("pstate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *pstate
     * }
     */
    public static final AddressLayout pstate$layout() {
        return pstate$LAYOUT;
    }

    private static final long pstate$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *pstate
     * }
     */
    public static final long pstate$offset() {
        return pstate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *pstate
     * }
     */
    public static MemorySegment pstate(MemorySegment struct) {
        return struct.get(pstate$LAYOUT, pstate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *pstate
     * }
     */
    public static void pstate(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(pstate$LAYOUT, pstate$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

