/*
 * Copyright © 2025 Bithatch (tanktarta@gmail.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this
 * software and associated documentation files (the “Software”), to deal in the Software
 * without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies
 * or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
// Generated by jextract

package uk.co.bithatch.linid.impl.linux;

import static java.lang.foreign.ValueLayout.JAVA_BYTE;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.Arena;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.Linker;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.PaddingLayout;
import java.lang.foreign.SequenceLayout;
import java.lang.foreign.StructLayout;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.foreign.ValueLayout.OfByte;
import java.lang.foreign.ValueLayout.OfDouble;
import java.lang.foreign.ValueLayout.OfFloat;
import java.lang.foreign.ValueLayout.OfInt;
import java.lang.foreign.ValueLayout.OfLong;
import java.lang.foreign.ValueLayout.OfShort;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.util.Arrays;
import java.util.stream.Collectors;

import com.sshtools.nih.Native;

public class nss_proto_h_1 {

    nss_proto_h_1() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP =  Native.load("pam", LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _ALIASES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALIASES_H 1
     * }
     */
    public static int _ALIASES_H() {
        return _ALIASES_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C2X_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C2X_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C2X_STRTOL() {
        return __GLIBC_USE_C2X_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)39L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 39
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int __cookie_io_functions_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __cookie_io_functions_t_defined 1
     * }
     */
    public static int __cookie_io_functions_t_defined() {
        return __cookie_io_functions_t_defined;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int _CTYPE_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CTYPE_H 1
     * }
     */
    public static int _CTYPE_H() {
        return _CTYPE_H;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int _GETOPT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _GETOPT_H 1
     * }
     */
    public static int _GETOPT_H() {
        return _GETOPT_H;
    }
    private static final int _GETOPT_CORE_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _GETOPT_CORE_H 1
     * }
     */
    public static int _GETOPT_CORE_H() {
        return _GETOPT_CORE_H;
    }
    private static final int _GETOPT_EXT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _GETOPT_EXT_H 1
     * }
     */
    public static int _GETOPT_EXT_H() {
        return _GETOPT_EXT_H;
    }
    private static final int no_argument = (int)0L;
    /**
     * {@snippet lang=c :
     * #define no_argument 0
     * }
     */
    public static int no_argument() {
        return no_argument;
    }
    private static final int required_argument = (int)1L;
    /**
     * {@snippet lang=c :
     * #define required_argument 1
     * }
     */
    public static int required_argument() {
        return required_argument;
    }
    private static final int optional_argument = (int)2L;
    /**
     * {@snippet lang=c :
     * #define optional_argument 2
     * }
     */
    public static int optional_argument() {
        return optional_argument;
    }
    private static final int _LIBC_LIMITS_H_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _LIBC_LIMITS_H_ 1
     * }
     */
    public static int _LIBC_LIMITS_H_() {
        return _LIBC_LIMITS_H_;
    }
    private static final int MB_LEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 16
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int _BITS_POSIX1_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX1_LIM_H 1
     * }
     */
    public static int _BITS_POSIX1_LIM_H() {
        return _BITS_POSIX1_LIM_H;
    }
    private static final int _POSIX_AIO_LISTIO_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_LISTIO_MAX 2
     * }
     */
    public static int _POSIX_AIO_LISTIO_MAX() {
        return _POSIX_AIO_LISTIO_MAX;
    }
    private static final int _POSIX_AIO_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_MAX 1
     * }
     */
    public static int _POSIX_AIO_MAX() {
        return _POSIX_AIO_MAX;
    }
    private static final int _POSIX_ARG_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ARG_MAX 4096
     * }
     */
    public static int _POSIX_ARG_MAX() {
        return _POSIX_ARG_MAX;
    }
    private static final int _POSIX_CHILD_MAX = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CHILD_MAX 25
     * }
     */
    public static int _POSIX_CHILD_MAX() {
        return _POSIX_CHILD_MAX;
    }
    private static final int _POSIX_DELAYTIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_DELAYTIMER_MAX 32
     * }
     */
    public static int _POSIX_DELAYTIMER_MAX() {
        return _POSIX_DELAYTIMER_MAX;
    }
    private static final int _POSIX_HOST_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_HOST_NAME_MAX 255
     * }
     */
    public static int _POSIX_HOST_NAME_MAX() {
        return _POSIX_HOST_NAME_MAX;
    }
    private static final int _POSIX_LINK_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LINK_MAX 8
     * }
     */
    public static int _POSIX_LINK_MAX() {
        return _POSIX_LINK_MAX;
    }
    private static final int _POSIX_LOGIN_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LOGIN_NAME_MAX 9
     * }
     */
    public static int _POSIX_LOGIN_NAME_MAX() {
        return _POSIX_LOGIN_NAME_MAX;
    }
    private static final int _POSIX_MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_CANON 255
     * }
     */
    public static int _POSIX_MAX_CANON() {
        return _POSIX_MAX_CANON;
    }
    private static final int _POSIX_MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_INPUT 255
     * }
     */
    public static int _POSIX_MAX_INPUT() {
        return _POSIX_MAX_INPUT;
    }
    private static final int _POSIX_MQ_OPEN_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_OPEN_MAX 8
     * }
     */
    public static int _POSIX_MQ_OPEN_MAX() {
        return _POSIX_MQ_OPEN_MAX;
    }
    private static final int _POSIX_MQ_PRIO_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_PRIO_MAX 32
     * }
     */
    public static int _POSIX_MQ_PRIO_MAX() {
        return _POSIX_MQ_PRIO_MAX;
    }
    private static final int _POSIX_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NAME_MAX 14
     * }
     */
    public static int _POSIX_NAME_MAX() {
        return _POSIX_NAME_MAX;
    }
    private static final int _POSIX_NGROUPS_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NGROUPS_MAX 8
     * }
     */
    public static int _POSIX_NGROUPS_MAX() {
        return _POSIX_NGROUPS_MAX;
    }
    private static final int _POSIX_OPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_OPEN_MAX 20
     * }
     */
    public static int _POSIX_OPEN_MAX() {
        return _POSIX_OPEN_MAX;
    }
    private static final int _POSIX_PATH_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PATH_MAX 256
     * }
     */
    public static int _POSIX_PATH_MAX() {
        return _POSIX_PATH_MAX;
    }
    private static final int _POSIX_PIPE_BUF = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PIPE_BUF 512
     * }
     */
    public static int _POSIX_PIPE_BUF() {
        return _POSIX_PIPE_BUF;
    }
    private static final int _POSIX_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }
    private static final int _POSIX_RTSIG_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RTSIG_MAX 8
     * }
     */
    public static int _POSIX_RTSIG_MAX() {
        return _POSIX_RTSIG_MAX;
    }
    private static final int _POSIX_SEM_NSEMS_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_NSEMS_MAX 256
     * }
     */
    public static int _POSIX_SEM_NSEMS_MAX() {
        return _POSIX_SEM_NSEMS_MAX;
    }
    private static final int _POSIX_SEM_VALUE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_VALUE_MAX 32767
     * }
     */
    public static int _POSIX_SEM_VALUE_MAX() {
        return _POSIX_SEM_VALUE_MAX;
    }
    private static final int _POSIX_SIGQUEUE_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SIGQUEUE_MAX 32
     * }
     */
    public static int _POSIX_SIGQUEUE_MAX() {
        return _POSIX_SIGQUEUE_MAX;
    }
    private static final int _POSIX_SSIZE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SSIZE_MAX 32767
     * }
     */
    public static int _POSIX_SSIZE_MAX() {
        return _POSIX_SSIZE_MAX;
    }
    private static final int _POSIX_STREAM_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_STREAM_MAX 8
     * }
     */
    public static int _POSIX_STREAM_MAX() {
        return _POSIX_STREAM_MAX;
    }
    private static final int _POSIX_SYMLINK_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLINK_MAX 255
     * }
     */
    public static int _POSIX_SYMLINK_MAX() {
        return _POSIX_SYMLINK_MAX;
    }
    private static final int _POSIX_SYMLOOP_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLOOP_MAX 8
     * }
     */
    public static int _POSIX_SYMLOOP_MAX() {
        return _POSIX_SYMLOOP_MAX;
    }
    private static final int _POSIX_TIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMER_MAX 32
     * }
     */
    public static int _POSIX_TIMER_MAX() {
        return _POSIX_TIMER_MAX;
    }
    private static final int _POSIX_TTY_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TTY_NAME_MAX 9
     * }
     */
    public static int _POSIX_TTY_NAME_MAX() {
        return _POSIX_TTY_NAME_MAX;
    }
    private static final int _POSIX_TZNAME_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TZNAME_MAX 6
     * }
     */
    public static int _POSIX_TZNAME_MAX() {
        return _POSIX_TZNAME_MAX;
    }
    private static final int _POSIX_CLOCKRES_MIN = (int)20000000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCKRES_MIN 20000000
     * }
     */
    public static int _POSIX_CLOCKRES_MIN() {
        return _POSIX_CLOCKRES_MIN;
    }
    private static final int NR_OPEN = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define NR_OPEN 1024
     * }
     */
    public static int NR_OPEN() {
        return NR_OPEN;
    }
    private static final int NGROUPS_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define NGROUPS_MAX 65536
     * }
     */
    public static int NGROUPS_MAX() {
        return NGROUPS_MAX;
    }
    private static final int ARG_MAX = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 131072
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }
    private static final int LINK_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define LINK_MAX 127
     * }
     */
    public static int LINK_MAX() {
        return LINK_MAX;
    }
    private static final int MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_CANON 255
     * }
     */
    public static int MAX_CANON() {
        return MAX_CANON;
    }
    private static final int MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_INPUT 255
     * }
     */
    public static int MAX_INPUT() {
        return MAX_INPUT;
    }
    private static final int NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define NAME_MAX 255
     * }
     */
    public static int NAME_MAX() {
        return NAME_MAX;
    }
    private static final int PATH_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PATH_MAX 4096
     * }
     */
    public static int PATH_MAX() {
        return PATH_MAX;
    }
    private static final int PIPE_BUF = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PIPE_BUF 4096
     * }
     */
    public static int PIPE_BUF() {
        return PIPE_BUF;
    }
    private static final int XATTR_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define XATTR_NAME_MAX 255
     * }
     */
    public static int XATTR_NAME_MAX() {
        return XATTR_NAME_MAX;
    }
    private static final int XATTR_SIZE_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_SIZE_MAX 65536
     * }
     */
    public static int XATTR_SIZE_MAX() {
        return XATTR_SIZE_MAX;
    }
    private static final int XATTR_LIST_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_LIST_MAX 65536
     * }
     */
    public static int XATTR_LIST_MAX() {
        return XATTR_LIST_MAX;
    }
    private static final int RTSIG_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RTSIG_MAX 32
     * }
     */
    public static int RTSIG_MAX() {
        return RTSIG_MAX;
    }
    private static final int _POSIX_THREAD_KEYS_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_KEYS_MAX 128
     * }
     */
    public static int _POSIX_THREAD_KEYS_MAX() {
        return _POSIX_THREAD_KEYS_MAX;
    }
    private static final int PTHREAD_KEYS_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_KEYS_MAX 1024
     * }
     */
    public static int PTHREAD_KEYS_MAX() {
        return PTHREAD_KEYS_MAX;
    }
    private static final int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int _POSIX_THREAD_DESTRUCTOR_ITERATIONS() {
        return _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _POSIX_THREAD_THREADS_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_THREADS_MAX 64
     * }
     */
    public static int _POSIX_THREAD_THREADS_MAX() {
        return _POSIX_THREAD_THREADS_MAX;
    }
    private static final int AIO_PRIO_DELTA_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define AIO_PRIO_DELTA_MAX 20
     * }
     */
    public static int AIO_PRIO_DELTA_MAX() {
        return AIO_PRIO_DELTA_MAX;
    }
    private static final int PTHREAD_STACK_MIN = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_STACK_MIN 16384
     * }
     */
    public static int PTHREAD_STACK_MIN() {
        return PTHREAD_STACK_MIN;
    }
    private static final int DELAYTIMER_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define DELAYTIMER_MAX 2147483647
     * }
     */
    public static int DELAYTIMER_MAX() {
        return DELAYTIMER_MAX;
    }
    private static final int TTY_NAME_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define TTY_NAME_MAX 32
     * }
     */
    public static int TTY_NAME_MAX() {
        return TTY_NAME_MAX;
    }
    private static final int LOGIN_NAME_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define LOGIN_NAME_MAX 256
     * }
     */
    public static int LOGIN_NAME_MAX() {
        return LOGIN_NAME_MAX;
    }
    private static final int HOST_NAME_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define HOST_NAME_MAX 64
     * }
     */
    public static int HOST_NAME_MAX() {
        return HOST_NAME_MAX;
    }
    private static final int MQ_PRIO_MAX = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MQ_PRIO_MAX 32768
     * }
     */
    public static int MQ_PRIO_MAX() {
        return MQ_PRIO_MAX;
    }
    private static final int _BITS_POSIX2_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX2_LIM_H 1
     * }
     */
    public static int _BITS_POSIX2_LIM_H() {
        return _BITS_POSIX2_LIM_H;
    }
    private static final int _POSIX2_BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_BASE_MAX 99
     * }
     */
    public static int _POSIX2_BC_BASE_MAX() {
        return _POSIX2_BC_BASE_MAX;
    }
    private static final int _POSIX2_BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_DIM_MAX 2048
     * }
     */
    public static int _POSIX2_BC_DIM_MAX() {
        return _POSIX2_BC_DIM_MAX;
    }
    private static final int _POSIX2_BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_SCALE_MAX 99
     * }
     */
    public static int _POSIX2_BC_SCALE_MAX() {
        return _POSIX2_BC_SCALE_MAX;
    }
    private static final int _POSIX2_BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_STRING_MAX 1000
     * }
     */
    public static int _POSIX2_BC_STRING_MAX() {
        return _POSIX2_BC_STRING_MAX;
    }
    private static final int _POSIX2_COLL_WEIGHTS_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_COLL_WEIGHTS_MAX 2
     * }
     */
    public static int _POSIX2_COLL_WEIGHTS_MAX() {
        return _POSIX2_COLL_WEIGHTS_MAX;
    }
    private static final int _POSIX2_EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_EXPR_NEST_MAX 32
     * }
     */
    public static int _POSIX2_EXPR_NEST_MAX() {
        return _POSIX2_EXPR_NEST_MAX;
    }
    private static final int _POSIX2_LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LINE_MAX 2048
     * }
     */
    public static int _POSIX2_LINE_MAX() {
        return _POSIX2_LINE_MAX;
    }
    private static final int _POSIX2_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX2_RE_DUP_MAX() {
        return _POSIX2_RE_DUP_MAX;
    }
    private static final int _POSIX2_CHARCLASS_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHARCLASS_NAME_MAX 14
     * }
     */
    public static int _POSIX2_CHARCLASS_NAME_MAX() {
        return _POSIX2_CHARCLASS_NAME_MAX;
    }
    private static final int COLL_WEIGHTS_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define COLL_WEIGHTS_MAX 255
     * }
     */
    public static int COLL_WEIGHTS_MAX() {
        return COLL_WEIGHTS_MAX;
    }
    private static final int CHARCLASS_NAME_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define CHARCLASS_NAME_MAX 2048
     * }
     */
    public static int CHARCLASS_NAME_MAX() {
        return CHARCLASS_NAME_MAX;
    }
    private static final int _ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ERRNO_H 1
     * }
     */
    public static int _ERRNO_H() {
        return _ERRNO_H;
    }
    private static final int _BITS_ERRNO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ERRNO_H 1
     * }
     */
    public static int _BITS_ERRNO_H() {
        return _BITS_ERRNO_H;
    }
    private static final int EPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPERM 1
     * }
     */
    public static int EPERM() {
        return EPERM;
    }
    private static final int ENOENT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ENOENT 2
     * }
     */
    public static int ENOENT() {
        return ENOENT;
    }
    private static final int ESRCH = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ESRCH 3
     * }
     */
    public static int ESRCH() {
        return ESRCH;
    }
    private static final int EINTR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EINTR 4
     * }
     */
    public static int EINTR() {
        return EINTR;
    }
    private static final int EIO = (int)5L;
    /**
     * {@snippet lang=c :
     * #define EIO 5
     * }
     */
    public static int EIO() {
        return EIO;
    }
    private static final int ENXIO = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ENXIO 6
     * }
     */
    public static int ENXIO() {
        return ENXIO;
    }
    private static final int E2BIG = (int)7L;
    /**
     * {@snippet lang=c :
     * #define E2BIG 7
     * }
     */
    public static int E2BIG() {
        return E2BIG;
    }
    private static final int ENOEXEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ENOEXEC 8
     * }
     */
    public static int ENOEXEC() {
        return ENOEXEC;
    }
    private static final int EBADF = (int)9L;
    /**
     * {@snippet lang=c :
     * #define EBADF 9
     * }
     */
    public static int EBADF() {
        return EBADF;
    }
    private static final int ECHILD = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ECHILD 10
     * }
     */
    public static int ECHILD() {
        return ECHILD;
    }
    private static final int EAGAIN = (int)11L;
    /**
     * {@snippet lang=c :
     * #define EAGAIN 11
     * }
     */
    public static int EAGAIN() {
        return EAGAIN;
    }
    private static final int ENOMEM = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ENOMEM 12
     * }
     */
    public static int ENOMEM() {
        return ENOMEM;
    }
    private static final int EACCES = (int)13L;
    /**
     * {@snippet lang=c :
     * #define EACCES 13
     * }
     */
    public static int EACCES() {
        return EACCES;
    }
    private static final int EFAULT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define EFAULT 14
     * }
     */
    public static int EFAULT() {
        return EFAULT;
    }
    private static final int ENOTBLK = (int)15L;
    /**
     * {@snippet lang=c :
     * #define ENOTBLK 15
     * }
     */
    public static int ENOTBLK() {
        return ENOTBLK;
    }
    private static final int EBUSY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EBUSY 16
     * }
     */
    public static int EBUSY() {
        return EBUSY;
    }
    private static final int EEXIST = (int)17L;
    /**
     * {@snippet lang=c :
     * #define EEXIST 17
     * }
     */
    public static int EEXIST() {
        return EEXIST;
    }
    private static final int EXDEV = (int)18L;
    /**
     * {@snippet lang=c :
     * #define EXDEV 18
     * }
     */
    public static int EXDEV() {
        return EXDEV;
    }
    private static final int ENODEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define ENODEV 19
     * }
     */
    public static int ENODEV() {
        return ENODEV;
    }
    private static final int ENOTDIR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define ENOTDIR 20
     * }
     */
    public static int ENOTDIR() {
        return ENOTDIR;
    }
    private static final int EISDIR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define EISDIR 21
     * }
     */
    public static int EISDIR() {
        return EISDIR;
    }
    private static final int EINVAL = (int)22L;
    /**
     * {@snippet lang=c :
     * #define EINVAL 22
     * }
     */
    public static int EINVAL() {
        return EINVAL;
    }
    private static final int ENFILE = (int)23L;
    /**
     * {@snippet lang=c :
     * #define ENFILE 23
     * }
     */
    public static int ENFILE() {
        return ENFILE;
    }
    private static final int EMFILE = (int)24L;
    /**
     * {@snippet lang=c :
     * #define EMFILE 24
     * }
     */
    public static int EMFILE() {
        return EMFILE;
    }
    private static final int ENOTTY = (int)25L;
    /**
     * {@snippet lang=c :
     * #define ENOTTY 25
     * }
     */
    public static int ENOTTY() {
        return ENOTTY;
    }
    private static final int ETXTBSY = (int)26L;
    /**
     * {@snippet lang=c :
     * #define ETXTBSY 26
     * }
     */
    public static int ETXTBSY() {
        return ETXTBSY;
    }
    private static final int EFBIG = (int)27L;
    /**
     * {@snippet lang=c :
     * #define EFBIG 27
     * }
     */
    public static int EFBIG() {
        return EFBIG;
    }
    private static final int ENOSPC = (int)28L;
    /**
     * {@snippet lang=c :
     * #define ENOSPC 28
     * }
     */
    public static int ENOSPC() {
        return ENOSPC;
    }
    private static final int ESPIPE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define ESPIPE 29
     * }
     */
    public static int ESPIPE() {
        return ESPIPE;
    }
    private static final int EROFS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define EROFS 30
     * }
     */
    public static int EROFS() {
        return EROFS;
    }
    private static final int EMLINK = (int)31L;
    /**
     * {@snippet lang=c :
     * #define EMLINK 31
     * }
     */
    public static int EMLINK() {
        return EMLINK;
    }
    private static final int EPIPE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EPIPE 32
     * }
     */
    public static int EPIPE() {
        return EPIPE;
    }
    private static final int EDOM = (int)33L;
    /**
     * {@snippet lang=c :
     * #define EDOM 33
     * }
     */
    public static int EDOM() {
        return EDOM;
    }
    private static final int ERANGE = (int)34L;
    /**
     * {@snippet lang=c :
     * #define ERANGE 34
     * }
     */
    public static int ERANGE() {
        return ERANGE;
    }
    private static final int EDEADLK = (int)35L;
    /**
     * {@snippet lang=c :
     * #define EDEADLK 35
     * }
     */
    public static int EDEADLK() {
        return EDEADLK;
    }
    private static final int ENAMETOOLONG = (int)36L;
    /**
     * {@snippet lang=c :
     * #define ENAMETOOLONG 36
     * }
     */
    public static int ENAMETOOLONG() {
        return ENAMETOOLONG;
    }
    private static final int ENOLCK = (int)37L;
    /**
     * {@snippet lang=c :
     * #define ENOLCK 37
     * }
     */
    public static int ENOLCK() {
        return ENOLCK;
    }
    private static final int ENOSYS = (int)38L;
    /**
     * {@snippet lang=c :
     * #define ENOSYS 38
     * }
     */
    public static int ENOSYS() {
        return ENOSYS;
    }
    private static final int ENOTEMPTY = (int)39L;
    /**
     * {@snippet lang=c :
     * #define ENOTEMPTY 39
     * }
     */
    public static int ENOTEMPTY() {
        return ENOTEMPTY;
    }
    private static final int ELOOP = (int)40L;
    /**
     * {@snippet lang=c :
     * #define ELOOP 40
     * }
     */
    public static int ELOOP() {
        return ELOOP;
    }
    private static final int ENOMSG = (int)42L;
    /**
     * {@snippet lang=c :
     * #define ENOMSG 42
     * }
     */
    public static int ENOMSG() {
        return ENOMSG;
    }
    private static final int EIDRM = (int)43L;
    /**
     * {@snippet lang=c :
     * #define EIDRM 43
     * }
     */
    public static int EIDRM() {
        return EIDRM;
    }
    private static final int ECHRNG = (int)44L;
    /**
     * {@snippet lang=c :
     * #define ECHRNG 44
     * }
     */
    public static int ECHRNG() {
        return ECHRNG;
    }
    private static final int EL2NSYNC = (int)45L;
    /**
     * {@snippet lang=c :
     * #define EL2NSYNC 45
     * }
     */
    public static int EL2NSYNC() {
        return EL2NSYNC;
    }
    private static final int EL3HLT = (int)46L;
    /**
     * {@snippet lang=c :
     * #define EL3HLT 46
     * }
     */
    public static int EL3HLT() {
        return EL3HLT;
    }
    private static final int EL3RST = (int)47L;
    /**
     * {@snippet lang=c :
     * #define EL3RST 47
     * }
     */
    public static int EL3RST() {
        return EL3RST;
    }
    private static final int ELNRNG = (int)48L;
    /**
     * {@snippet lang=c :
     * #define ELNRNG 48
     * }
     */
    public static int ELNRNG() {
        return ELNRNG;
    }
    private static final int EUNATCH = (int)49L;
    /**
     * {@snippet lang=c :
     * #define EUNATCH 49
     * }
     */
    public static int EUNATCH() {
        return EUNATCH;
    }
    private static final int ENOCSI = (int)50L;
    /**
     * {@snippet lang=c :
     * #define ENOCSI 50
     * }
     */
    public static int ENOCSI() {
        return ENOCSI;
    }
    private static final int EL2HLT = (int)51L;
    /**
     * {@snippet lang=c :
     * #define EL2HLT 51
     * }
     */
    public static int EL2HLT() {
        return EL2HLT;
    }
    private static final int EBADE = (int)52L;
    /**
     * {@snippet lang=c :
     * #define EBADE 52
     * }
     */
    public static int EBADE() {
        return EBADE;
    }
    private static final int EBADR = (int)53L;
    /**
     * {@snippet lang=c :
     * #define EBADR 53
     * }
     */
    public static int EBADR() {
        return EBADR;
    }
    private static final int EXFULL = (int)54L;
    /**
     * {@snippet lang=c :
     * #define EXFULL 54
     * }
     */
    public static int EXFULL() {
        return EXFULL;
    }
    private static final int ENOANO = (int)55L;
    /**
     * {@snippet lang=c :
     * #define ENOANO 55
     * }
     */
    public static int ENOANO() {
        return ENOANO;
    }
    private static final int EBADRQC = (int)56L;
    /**
     * {@snippet lang=c :
     * #define EBADRQC 56
     * }
     */
    public static int EBADRQC() {
        return EBADRQC;
    }
    private static final int EBADSLT = (int)57L;
    /**
     * {@snippet lang=c :
     * #define EBADSLT 57
     * }
     */
    public static int EBADSLT() {
        return EBADSLT;
    }
    private static final int EBFONT = (int)59L;
    /**
     * {@snippet lang=c :
     * #define EBFONT 59
     * }
     */
    public static int EBFONT() {
        return EBFONT;
    }
    private static final int ENOSTR = (int)60L;
    /**
     * {@snippet lang=c :
     * #define ENOSTR 60
     * }
     */
    public static int ENOSTR() {
        return ENOSTR;
    }
    private static final int ENODATA = (int)61L;
    /**
     * {@snippet lang=c :
     * #define ENODATA 61
     * }
     */
    public static int ENODATA() {
        return ENODATA;
    }
    private static final int ETIME = (int)62L;
    /**
     * {@snippet lang=c :
     * #define ETIME 62
     * }
     */
    public static int ETIME() {
        return ETIME;
    }
    private static final int ENOSR = (int)63L;
    /**
     * {@snippet lang=c :
     * #define ENOSR 63
     * }
     */
    public static int ENOSR() {
        return ENOSR;
    }
    private static final int ENONET = (int)64L;
    /**
     * {@snippet lang=c :
     * #define ENONET 64
     * }
     */
    public static int ENONET() {
        return ENONET;
    }
    private static final int ENOPKG = (int)65L;
    /**
     * {@snippet lang=c :
     * #define ENOPKG 65
     * }
     */
    public static int ENOPKG() {
        return ENOPKG;
    }
    private static final int EREMOTE = (int)66L;
    /**
     * {@snippet lang=c :
     * #define EREMOTE 66
     * }
     */
    public static int EREMOTE() {
        return EREMOTE;
    }
    private static final int ENOLINK = (int)67L;
    /**
     * {@snippet lang=c :
     * #define ENOLINK 67
     * }
     */
    public static int ENOLINK() {
        return ENOLINK;
    }
    private static final int EADV = (int)68L;
    /**
     * {@snippet lang=c :
     * #define EADV 68
     * }
     */
    public static int EADV() {
        return EADV;
    }
    private static final int ESRMNT = (int)69L;
    /**
     * {@snippet lang=c :
     * #define ESRMNT 69
     * }
     */
    public static int ESRMNT() {
        return ESRMNT;
    }
    private static final int ECOMM = (int)70L;
    /**
     * {@snippet lang=c :
     * #define ECOMM 70
     * }
     */
    public static int ECOMM() {
        return ECOMM;
    }
    private static final int EPROTO = (int)71L;
    /**
     * {@snippet lang=c :
     * #define EPROTO 71
     * }
     */
    public static int EPROTO() {
        return EPROTO;
    }
    private static final int EMULTIHOP = (int)72L;
    /**
     * {@snippet lang=c :
     * #define EMULTIHOP 72
     * }
     */
    public static int EMULTIHOP() {
        return EMULTIHOP;
    }
    private static final int EDOTDOT = (int)73L;
    /**
     * {@snippet lang=c :
     * #define EDOTDOT 73
     * }
     */
    public static int EDOTDOT() {
        return EDOTDOT;
    }
    private static final int EBADMSG = (int)74L;
    /**
     * {@snippet lang=c :
     * #define EBADMSG 74
     * }
     */
    public static int EBADMSG() {
        return EBADMSG;
    }
    private static final int EOVERFLOW = (int)75L;
    /**
     * {@snippet lang=c :
     * #define EOVERFLOW 75
     * }
     */
    public static int EOVERFLOW() {
        return EOVERFLOW;
    }
    private static final int ENOTUNIQ = (int)76L;
    /**
     * {@snippet lang=c :
     * #define ENOTUNIQ 76
     * }
     */
    public static int ENOTUNIQ() {
        return ENOTUNIQ;
    }
    private static final int EBADFD = (int)77L;
    /**
     * {@snippet lang=c :
     * #define EBADFD 77
     * }
     */
    public static int EBADFD() {
        return EBADFD;
    }
    private static final int EREMCHG = (int)78L;
    /**
     * {@snippet lang=c :
     * #define EREMCHG 78
     * }
     */
    public static int EREMCHG() {
        return EREMCHG;
    }
    private static final int ELIBACC = (int)79L;
    /**
     * {@snippet lang=c :
     * #define ELIBACC 79
     * }
     */
    public static int ELIBACC() {
        return ELIBACC;
    }
    private static final int ELIBBAD = (int)80L;
    /**
     * {@snippet lang=c :
     * #define ELIBBAD 80
     * }
     */
    public static int ELIBBAD() {
        return ELIBBAD;
    }
    private static final int ELIBSCN = (int)81L;
    /**
     * {@snippet lang=c :
     * #define ELIBSCN 81
     * }
     */
    public static int ELIBSCN() {
        return ELIBSCN;
    }
    private static final int ELIBMAX = (int)82L;
    /**
     * {@snippet lang=c :
     * #define ELIBMAX 82
     * }
     */
    public static int ELIBMAX() {
        return ELIBMAX;
    }
    private static final int ELIBEXEC = (int)83L;
    /**
     * {@snippet lang=c :
     * #define ELIBEXEC 83
     * }
     */
    public static int ELIBEXEC() {
        return ELIBEXEC;
    }
    private static final int EILSEQ = (int)84L;
    /**
     * {@snippet lang=c :
     * #define EILSEQ 84
     * }
     */
    public static int EILSEQ() {
        return EILSEQ;
    }
    private static final int ERESTART = (int)85L;
    /**
     * {@snippet lang=c :
     * #define ERESTART 85
     * }
     */
    public static int ERESTART() {
        return ERESTART;
    }
    private static final int ESTRPIPE = (int)86L;
    /**
     * {@snippet lang=c :
     * #define ESTRPIPE 86
     * }
     */
    public static int ESTRPIPE() {
        return ESTRPIPE;
    }
    private static final int EUSERS = (int)87L;
    /**
     * {@snippet lang=c :
     * #define EUSERS 87
     * }
     */
    public static int EUSERS() {
        return EUSERS;
    }
    private static final int ENOTSOCK = (int)88L;
    /**
     * {@snippet lang=c :
     * #define ENOTSOCK 88
     * }
     */
    public static int ENOTSOCK() {
        return ENOTSOCK;
    }
    private static final int EDESTADDRREQ = (int)89L;
    /**
     * {@snippet lang=c :
     * #define EDESTADDRREQ 89
     * }
     */
    public static int EDESTADDRREQ() {
        return EDESTADDRREQ;
    }
    private static final int EMSGSIZE = (int)90L;
    /**
     * {@snippet lang=c :
     * #define EMSGSIZE 90
     * }
     */
    public static int EMSGSIZE() {
        return EMSGSIZE;
    }
    private static final int EPROTOTYPE = (int)91L;
    /**
     * {@snippet lang=c :
     * #define EPROTOTYPE 91
     * }
     */
    public static int EPROTOTYPE() {
        return EPROTOTYPE;
    }
    private static final int ENOPROTOOPT = (int)92L;
    /**
     * {@snippet lang=c :
     * #define ENOPROTOOPT 92
     * }
     */
    public static int ENOPROTOOPT() {
        return ENOPROTOOPT;
    }
    private static final int EPROTONOSUPPORT = (int)93L;
    /**
     * {@snippet lang=c :
     * #define EPROTONOSUPPORT 93
     * }
     */
    public static int EPROTONOSUPPORT() {
        return EPROTONOSUPPORT;
    }
    private static final int ESOCKTNOSUPPORT = (int)94L;
    /**
     * {@snippet lang=c :
     * #define ESOCKTNOSUPPORT 94
     * }
     */
    public static int ESOCKTNOSUPPORT() {
        return ESOCKTNOSUPPORT;
    }
    private static final int EOPNOTSUPP = (int)95L;
    /**
     * {@snippet lang=c :
     * #define EOPNOTSUPP 95
     * }
     */
    public static int EOPNOTSUPP() {
        return EOPNOTSUPP;
    }
    private static final int EPFNOSUPPORT = (int)96L;
    /**
     * {@snippet lang=c :
     * #define EPFNOSUPPORT 96
     * }
     */
    public static int EPFNOSUPPORT() {
        return EPFNOSUPPORT;
    }
    private static final int EAFNOSUPPORT = (int)97L;
    /**
     * {@snippet lang=c :
     * #define EAFNOSUPPORT 97
     * }
     */
    public static int EAFNOSUPPORT() {
        return EAFNOSUPPORT;
    }
    private static final int EADDRINUSE = (int)98L;
    /**
     * {@snippet lang=c :
     * #define EADDRINUSE 98
     * }
     */
    public static int EADDRINUSE() {
        return EADDRINUSE;
    }
    private static final int EADDRNOTAVAIL = (int)99L;
    /**
     * {@snippet lang=c :
     * #define EADDRNOTAVAIL 99
     * }
     */
    public static int EADDRNOTAVAIL() {
        return EADDRNOTAVAIL;
    }
    private static final int ENETDOWN = (int)100L;
    /**
     * {@snippet lang=c :
     * #define ENETDOWN 100
     * }
     */
    public static int ENETDOWN() {
        return ENETDOWN;
    }
    private static final int ENETUNREACH = (int)101L;
    /**
     * {@snippet lang=c :
     * #define ENETUNREACH 101
     * }
     */
    public static int ENETUNREACH() {
        return ENETUNREACH;
    }
    private static final int ENETRESET = (int)102L;
    /**
     * {@snippet lang=c :
     * #define ENETRESET 102
     * }
     */
    public static int ENETRESET() {
        return ENETRESET;
    }
    private static final int ECONNABORTED = (int)103L;
    /**
     * {@snippet lang=c :
     * #define ECONNABORTED 103
     * }
     */
    public static int ECONNABORTED() {
        return ECONNABORTED;
    }
    private static final int ECONNRESET = (int)104L;
    /**
     * {@snippet lang=c :
     * #define ECONNRESET 104
     * }
     */
    public static int ECONNRESET() {
        return ECONNRESET;
    }
    private static final int ENOBUFS = (int)105L;
    /**
     * {@snippet lang=c :
     * #define ENOBUFS 105
     * }
     */
    public static int ENOBUFS() {
        return ENOBUFS;
    }
    private static final int EISCONN = (int)106L;
    /**
     * {@snippet lang=c :
     * #define EISCONN 106
     * }
     */
    public static int EISCONN() {
        return EISCONN;
    }
    private static final int ENOTCONN = (int)107L;
    /**
     * {@snippet lang=c :
     * #define ENOTCONN 107
     * }
     */
    public static int ENOTCONN() {
        return ENOTCONN;
    }
    private static final int ESHUTDOWN = (int)108L;
    /**
     * {@snippet lang=c :
     * #define ESHUTDOWN 108
     * }
     */
    public static int ESHUTDOWN() {
        return ESHUTDOWN;
    }
    private static final int ETOOMANYREFS = (int)109L;
    /**
     * {@snippet lang=c :
     * #define ETOOMANYREFS 109
     * }
     */
    public static int ETOOMANYREFS() {
        return ETOOMANYREFS;
    }
    private static final int ETIMEDOUT = (int)110L;
    /**
     * {@snippet lang=c :
     * #define ETIMEDOUT 110
     * }
     */
    public static int ETIMEDOUT() {
        return ETIMEDOUT;
    }
    private static final int ECONNREFUSED = (int)111L;
    /**
     * {@snippet lang=c :
     * #define ECONNREFUSED 111
     * }
     */
    public static int ECONNREFUSED() {
        return ECONNREFUSED;
    }
    private static final int EHOSTDOWN = (int)112L;
    /**
     * {@snippet lang=c :
     * #define EHOSTDOWN 112
     * }
     */
    public static int EHOSTDOWN() {
        return EHOSTDOWN;
    }
    private static final int EHOSTUNREACH = (int)113L;
    /**
     * {@snippet lang=c :
     * #define EHOSTUNREACH 113
     * }
     */
    public static int EHOSTUNREACH() {
        return EHOSTUNREACH;
    }
    private static final int EALREADY = (int)114L;
    /**
     * {@snippet lang=c :
     * #define EALREADY 114
     * }
     */
    public static int EALREADY() {
        return EALREADY;
    }
    private static final int EINPROGRESS = (int)115L;
    /**
     * {@snippet lang=c :
     * #define EINPROGRESS 115
     * }
     */
    public static int EINPROGRESS() {
        return EINPROGRESS;
    }
    private static final int ESTALE = (int)116L;
    /**
     * {@snippet lang=c :
     * #define ESTALE 116
     * }
     */
    public static int ESTALE() {
        return ESTALE;
    }
    private static final int EUCLEAN = (int)117L;
    /**
     * {@snippet lang=c :
     * #define EUCLEAN 117
     * }
     */
    public static int EUCLEAN() {
        return EUCLEAN;
    }
    private static final int ENOTNAM = (int)118L;
    /**
     * {@snippet lang=c :
     * #define ENOTNAM 118
     * }
     */
    public static int ENOTNAM() {
        return ENOTNAM;
    }
    private static final int ENAVAIL = (int)119L;
    /**
     * {@snippet lang=c :
     * #define ENAVAIL 119
     * }
     */
    public static int ENAVAIL() {
        return ENAVAIL;
    }
    private static final int EISNAM = (int)120L;
    /**
     * {@snippet lang=c :
     * #define EISNAM 120
     * }
     */
    public static int EISNAM() {
        return EISNAM;
    }
    private static final int EREMOTEIO = (int)121L;
    /**
     * {@snippet lang=c :
     * #define EREMOTEIO 121
     * }
     */
    public static int EREMOTEIO() {
        return EREMOTEIO;
    }
    private static final int EDQUOT = (int)122L;
    /**
     * {@snippet lang=c :
     * #define EDQUOT 122
     * }
     */
    public static int EDQUOT() {
        return EDQUOT;
    }
    private static final int ENOMEDIUM = (int)123L;
    /**
     * {@snippet lang=c :
     * #define ENOMEDIUM 123
     * }
     */
    public static int ENOMEDIUM() {
        return ENOMEDIUM;
    }
    private static final int EMEDIUMTYPE = (int)124L;
    /**
     * {@snippet lang=c :
     * #define EMEDIUMTYPE 124
     * }
     */
    public static int EMEDIUMTYPE() {
        return EMEDIUMTYPE;
    }
    private static final int ECANCELED = (int)125L;
    /**
     * {@snippet lang=c :
     * #define ECANCELED 125
     * }
     */
    public static int ECANCELED() {
        return ECANCELED;
    }
    private static final int ENOKEY = (int)126L;
    /**
     * {@snippet lang=c :
     * #define ENOKEY 126
     * }
     */
    public static int ENOKEY() {
        return ENOKEY;
    }
    private static final int EKEYEXPIRED = (int)127L;
    /**
     * {@snippet lang=c :
     * #define EKEYEXPIRED 127
     * }
     */
    public static int EKEYEXPIRED() {
        return EKEYEXPIRED;
    }
    private static final int EKEYREVOKED = (int)128L;
    /**
     * {@snippet lang=c :
     * #define EKEYREVOKED 128
     * }
     */
    public static int EKEYREVOKED() {
        return EKEYREVOKED;
    }
    private static final int EKEYREJECTED = (int)129L;
    /**
     * {@snippet lang=c :
     * #define EKEYREJECTED 129
     * }
     */
    public static int EKEYREJECTED() {
        return EKEYREJECTED;
    }
    private static final int EOWNERDEAD = (int)130L;
    /**
     * {@snippet lang=c :
     * #define EOWNERDEAD 130
     * }
     */
    public static int EOWNERDEAD() {
        return EOWNERDEAD;
    }
    private static final int ENOTRECOVERABLE = (int)131L;
    /**
     * {@snippet lang=c :
     * #define ENOTRECOVERABLE 131
     * }
     */
    public static int ENOTRECOVERABLE() {
        return ENOTRECOVERABLE;
    }
    private static final int ERFKILL = (int)132L;
    /**
     * {@snippet lang=c :
     * #define ERFKILL 132
     * }
     */
    public static int ERFKILL() {
        return ERFKILL;
    }
    private static final int EHWPOISON = (int)133L;
    /**
     * {@snippet lang=c :
     * #define EHWPOISON 133
     * }
     */
    public static int EHWPOISON() {
        return EHWPOISON;
    }
    private static final int __error_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __error_t_defined 1
     * }
     */
    public static int __error_t_defined() {
        return __error_t_defined;
    }
    private static final int OPTION_ARG_OPTIONAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define OPTION_ARG_OPTIONAL 1
     * }
     */
    public static int OPTION_ARG_OPTIONAL() {
        return OPTION_ARG_OPTIONAL;
    }
    private static final int OPTION_HIDDEN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define OPTION_HIDDEN 2
     * }
     */
    public static int OPTION_HIDDEN() {
        return OPTION_HIDDEN;
    }
    private static final int OPTION_ALIAS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define OPTION_ALIAS 4
     * }
     */
    public static int OPTION_ALIAS() {
        return OPTION_ALIAS;
    }
    private static final int OPTION_DOC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define OPTION_DOC 8
     * }
     */
    public static int OPTION_DOC() {
        return OPTION_DOC;
    }
    private static final int OPTION_NO_USAGE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define OPTION_NO_USAGE 16
     * }
     */
    public static int OPTION_NO_USAGE() {
        return OPTION_NO_USAGE;
    }
    private static final int ARGP_KEY_ARG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_ARG 0
     * }
     */
    public static int ARGP_KEY_ARG() {
        return ARGP_KEY_ARG;
    }
    private static final int ARGP_KEY_ARGS = (int)16777222L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_ARGS 16777222
     * }
     */
    public static int ARGP_KEY_ARGS() {
        return ARGP_KEY_ARGS;
    }
    private static final int ARGP_KEY_END = (int)16777217L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_END 16777217
     * }
     */
    public static int ARGP_KEY_END() {
        return ARGP_KEY_END;
    }
    private static final int ARGP_KEY_NO_ARGS = (int)16777218L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_NO_ARGS 16777218
     * }
     */
    public static int ARGP_KEY_NO_ARGS() {
        return ARGP_KEY_NO_ARGS;
    }
    private static final int ARGP_KEY_INIT = (int)16777219L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_INIT 16777219
     * }
     */
    public static int ARGP_KEY_INIT() {
        return ARGP_KEY_INIT;
    }
    private static final int ARGP_KEY_FINI = (int)16777223L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_FINI 16777223
     * }
     */
    public static int ARGP_KEY_FINI() {
        return ARGP_KEY_FINI;
    }
    private static final int ARGP_KEY_SUCCESS = (int)16777220L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_SUCCESS 16777220
     * }
     */
    public static int ARGP_KEY_SUCCESS() {
        return ARGP_KEY_SUCCESS;
    }
    private static final int ARGP_KEY_ERROR = (int)16777221L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_ERROR 16777221
     * }
     */
    public static int ARGP_KEY_ERROR() {
        return ARGP_KEY_ERROR;
    }
    private static final int ARGP_KEY_HELP_PRE_DOC = (int)33554433L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_HELP_PRE_DOC 33554433
     * }
     */
    public static int ARGP_KEY_HELP_PRE_DOC() {
        return ARGP_KEY_HELP_PRE_DOC;
    }
    private static final int ARGP_KEY_HELP_POST_DOC = (int)33554434L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_HELP_POST_DOC 33554434
     * }
     */
    public static int ARGP_KEY_HELP_POST_DOC() {
        return ARGP_KEY_HELP_POST_DOC;
    }
    private static final int ARGP_KEY_HELP_HEADER = (int)33554435L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_HELP_HEADER 33554435
     * }
     */
    public static int ARGP_KEY_HELP_HEADER() {
        return ARGP_KEY_HELP_HEADER;
    }
    private static final int ARGP_KEY_HELP_EXTRA = (int)33554436L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_HELP_EXTRA 33554436
     * }
     */
    public static int ARGP_KEY_HELP_EXTRA() {
        return ARGP_KEY_HELP_EXTRA;
    }
    private static final int ARGP_KEY_HELP_DUP_ARGS_NOTE = (int)33554437L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_HELP_DUP_ARGS_NOTE 33554437
     * }
     */
    public static int ARGP_KEY_HELP_DUP_ARGS_NOTE() {
        return ARGP_KEY_HELP_DUP_ARGS_NOTE;
    }
    private static final int ARGP_KEY_HELP_ARGS_DOC = (int)33554438L;
    /**
     * {@snippet lang=c :
     * #define ARGP_KEY_HELP_ARGS_DOC 33554438
     * }
     */
    public static int ARGP_KEY_HELP_ARGS_DOC() {
        return ARGP_KEY_HELP_ARGS_DOC;
    }
    private static final int ARGP_PARSE_ARGV0 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ARGP_PARSE_ARGV0 1
     * }
     */
    public static int ARGP_PARSE_ARGV0() {
        return ARGP_PARSE_ARGV0;
    }
    private static final int ARGP_NO_ERRS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ARGP_NO_ERRS 2
     * }
     */
    public static int ARGP_NO_ERRS() {
        return ARGP_NO_ERRS;
    }
    private static final int ARGP_NO_ARGS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ARGP_NO_ARGS 4
     * }
     */
    public static int ARGP_NO_ARGS() {
        return ARGP_NO_ARGS;
    }
    private static final int ARGP_IN_ORDER = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ARGP_IN_ORDER 8
     * }
     */
    public static int ARGP_IN_ORDER() {
        return ARGP_IN_ORDER;
    }
    private static final int ARGP_NO_HELP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define ARGP_NO_HELP 16
     * }
     */
    public static int ARGP_NO_HELP() {
        return ARGP_NO_HELP;
    }
    private static final int ARGP_NO_EXIT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define ARGP_NO_EXIT 32
     * }
     */
    public static int ARGP_NO_EXIT() {
        return ARGP_NO_EXIT;
    }
    private static final int ARGP_LONG_ONLY = (int)64L;
    /**
     * {@snippet lang=c :
     * #define ARGP_LONG_ONLY 64
     * }
     */
    public static int ARGP_LONG_ONLY() {
        return ARGP_LONG_ONLY;
    }
    private static final int ARGP_HELP_USAGE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_USAGE 1
     * }
     */
    public static int ARGP_HELP_USAGE() {
        return ARGP_HELP_USAGE;
    }
    private static final int ARGP_HELP_SHORT_USAGE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_SHORT_USAGE 2
     * }
     */
    public static int ARGP_HELP_SHORT_USAGE() {
        return ARGP_HELP_SHORT_USAGE;
    }
    private static final int ARGP_HELP_SEE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_SEE 4
     * }
     */
    public static int ARGP_HELP_SEE() {
        return ARGP_HELP_SEE;
    }
    private static final int ARGP_HELP_LONG = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_LONG 8
     * }
     */
    public static int ARGP_HELP_LONG() {
        return ARGP_HELP_LONG;
    }
    private static final int ARGP_HELP_PRE_DOC = (int)16L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_PRE_DOC 16
     * }
     */
    public static int ARGP_HELP_PRE_DOC() {
        return ARGP_HELP_PRE_DOC;
    }
    private static final int ARGP_HELP_POST_DOC = (int)32L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_POST_DOC 32
     * }
     */
    public static int ARGP_HELP_POST_DOC() {
        return ARGP_HELP_POST_DOC;
    }
    private static final int ARGP_HELP_BUG_ADDR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_BUG_ADDR 64
     * }
     */
    public static int ARGP_HELP_BUG_ADDR() {
        return ARGP_HELP_BUG_ADDR;
    }
    private static final int ARGP_HELP_LONG_ONLY = (int)128L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_LONG_ONLY 128
     * }
     */
    public static int ARGP_HELP_LONG_ONLY() {
        return ARGP_HELP_LONG_ONLY;
    }
    private static final int ARGP_HELP_EXIT_ERR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_EXIT_ERR 256
     * }
     */
    public static int ARGP_HELP_EXIT_ERR() {
        return ARGP_HELP_EXIT_ERR;
    }
    private static final int ARGP_HELP_EXIT_OK = (int)512L;
    /**
     * {@snippet lang=c :
     * #define ARGP_HELP_EXIT_OK 512
     * }
     */
    public static int ARGP_HELP_EXIT_OK() {
        return ARGP_HELP_EXIT_OK;
    }
    private static final int _GRP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _GRP_H 1
     * }
     */
    public static int _GRP_H() {
        return _GRP_H;
    }
    private static final int NSS_BUFLEN_GROUP = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define NSS_BUFLEN_GROUP 1024
     * }
     */
    public static int NSS_BUFLEN_GROUP() {
        return NSS_BUFLEN_GROUP;
    }
    private static final int _GSHADOW_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _GSHADOW_H 1
     * }
     */
    public static int _GSHADOW_H() {
        return _GSHADOW_H;
    }
    private static final int _NETDB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _NETDB_H 1
     * }
     */
    public static int _NETDB_H() {
        return _NETDB_H;
    }
    private static final int _NETINET_IN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _NETINET_IN_H 1
     * }
     */
    public static int _NETINET_IN_H() {
        return _NETINET_IN_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _SYS_SOCKET_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SOCKET_H 1
     * }
     */
    public static int _SYS_SOCKET_H() {
        return _SYS_SOCKET_H;
    }
    private static final int __iovec_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __iovec_defined 1
     * }
     */
    public static int __iovec_defined() {
        return __iovec_defined;
    }
    private static final int PF_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PF_UNSPEC 0
     * }
     */
    public static int PF_UNSPEC() {
        return PF_UNSPEC;
    }
    private static final int PF_LOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PF_LOCAL 1
     * }
     */
    public static int PF_LOCAL() {
        return PF_LOCAL;
    }
    private static final int PF_INET = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PF_INET 2
     * }
     */
    public static int PF_INET() {
        return PF_INET;
    }
    private static final int PF_AX25 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PF_AX25 3
     * }
     */
    public static int PF_AX25() {
        return PF_AX25;
    }
    private static final int PF_IPX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PF_IPX 4
     * }
     */
    public static int PF_IPX() {
        return PF_IPX;
    }
    private static final int PF_APPLETALK = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PF_APPLETALK 5
     * }
     */
    public static int PF_APPLETALK() {
        return PF_APPLETALK;
    }
    private static final int PF_NETROM = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PF_NETROM 6
     * }
     */
    public static int PF_NETROM() {
        return PF_NETROM;
    }
    private static final int PF_BRIDGE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PF_BRIDGE 7
     * }
     */
    public static int PF_BRIDGE() {
        return PF_BRIDGE;
    }
    private static final int PF_ATMPVC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PF_ATMPVC 8
     * }
     */
    public static int PF_ATMPVC() {
        return PF_ATMPVC;
    }
    private static final int PF_X25 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PF_X25 9
     * }
     */
    public static int PF_X25() {
        return PF_X25;
    }
    private static final int PF_INET6 = (int)10L;
    /**
     * {@snippet lang=c :
     * #define PF_INET6 10
     * }
     */
    public static int PF_INET6() {
        return PF_INET6;
    }
    private static final int PF_ROSE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define PF_ROSE 11
     * }
     */
    public static int PF_ROSE() {
        return PF_ROSE;
    }
    private static final int PF_DECnet = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PF_DECnet 12
     * }
     */
    public static int PF_DECnet() {
        return PF_DECnet;
    }
    private static final int PF_NETBEUI = (int)13L;
    /**
     * {@snippet lang=c :
     * #define PF_NETBEUI 13
     * }
     */
    public static int PF_NETBEUI() {
        return PF_NETBEUI;
    }
    private static final int PF_SECURITY = (int)14L;
    /**
     * {@snippet lang=c :
     * #define PF_SECURITY 14
     * }
     */
    public static int PF_SECURITY() {
        return PF_SECURITY;
    }
    private static final int PF_KEY = (int)15L;
    /**
     * {@snippet lang=c :
     * #define PF_KEY 15
     * }
     */
    public static int PF_KEY() {
        return PF_KEY;
    }
    private static final int PF_NETLINK = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PF_NETLINK 16
     * }
     */
    public static int PF_NETLINK() {
        return PF_NETLINK;
    }
    private static final int PF_PACKET = (int)17L;
    /**
     * {@snippet lang=c :
     * #define PF_PACKET 17
     * }
     */
    public static int PF_PACKET() {
        return PF_PACKET;
    }
    private static final int PF_ASH = (int)18L;
    /**
     * {@snippet lang=c :
     * #define PF_ASH 18
     * }
     */
    public static int PF_ASH() {
        return PF_ASH;
    }
    private static final int PF_ECONET = (int)19L;
    /**
     * {@snippet lang=c :
     * #define PF_ECONET 19
     * }
     */
    public static int PF_ECONET() {
        return PF_ECONET;
    }
    private static final int PF_ATMSVC = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PF_ATMSVC 20
     * }
     */
    public static int PF_ATMSVC() {
        return PF_ATMSVC;
    }
    private static final int PF_RDS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define PF_RDS 21
     * }
     */
    public static int PF_RDS() {
        return PF_RDS;
    }
    private static final int PF_SNA = (int)22L;
    /**
     * {@snippet lang=c :
     * #define PF_SNA 22
     * }
     */
    public static int PF_SNA() {
        return PF_SNA;
    }
    private static final int PF_IRDA = (int)23L;
    /**
     * {@snippet lang=c :
     * #define PF_IRDA 23
     * }
     */
    public static int PF_IRDA() {
        return PF_IRDA;
    }
    private static final int PF_PPPOX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define PF_PPPOX 24
     * }
     */
    public static int PF_PPPOX() {
        return PF_PPPOX;
    }
    private static final int PF_WANPIPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define PF_WANPIPE 25
     * }
     */
    public static int PF_WANPIPE() {
        return PF_WANPIPE;
    }
    private static final int PF_LLC = (int)26L;
    /**
     * {@snippet lang=c :
     * #define PF_LLC 26
     * }
     */
    public static int PF_LLC() {
        return PF_LLC;
    }
    private static final int PF_IB = (int)27L;
    /**
     * {@snippet lang=c :
     * #define PF_IB 27
     * }
     */
    public static int PF_IB() {
        return PF_IB;
    }
    private static final int PF_MPLS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define PF_MPLS 28
     * }
     */
    public static int PF_MPLS() {
        return PF_MPLS;
    }
    private static final int PF_CAN = (int)29L;
    /**
     * {@snippet lang=c :
     * #define PF_CAN 29
     * }
     */
    public static int PF_CAN() {
        return PF_CAN;
    }
    private static final int PF_TIPC = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PF_TIPC 30
     * }
     */
    public static int PF_TIPC() {
        return PF_TIPC;
    }
    private static final int PF_BLUETOOTH = (int)31L;
    /**
     * {@snippet lang=c :
     * #define PF_BLUETOOTH 31
     * }
     */
    public static int PF_BLUETOOTH() {
        return PF_BLUETOOTH;
    }
    private static final int PF_IUCV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define PF_IUCV 32
     * }
     */
    public static int PF_IUCV() {
        return PF_IUCV;
    }
    private static final int PF_RXRPC = (int)33L;
    /**
     * {@snippet lang=c :
     * #define PF_RXRPC 33
     * }
     */
    public static int PF_RXRPC() {
        return PF_RXRPC;
    }
    private static final int PF_ISDN = (int)34L;
    /**
     * {@snippet lang=c :
     * #define PF_ISDN 34
     * }
     */
    public static int PF_ISDN() {
        return PF_ISDN;
    }
    private static final int PF_PHONET = (int)35L;
    /**
     * {@snippet lang=c :
     * #define PF_PHONET 35
     * }
     */
    public static int PF_PHONET() {
        return PF_PHONET;
    }
    private static final int PF_IEEE802154 = (int)36L;
    /**
     * {@snippet lang=c :
     * #define PF_IEEE802154 36
     * }
     */
    public static int PF_IEEE802154() {
        return PF_IEEE802154;
    }
    private static final int PF_CAIF = (int)37L;
    /**
     * {@snippet lang=c :
     * #define PF_CAIF 37
     * }
     */
    public static int PF_CAIF() {
        return PF_CAIF;
    }
    private static final int PF_ALG = (int)38L;
    /**
     * {@snippet lang=c :
     * #define PF_ALG 38
     * }
     */
    public static int PF_ALG() {
        return PF_ALG;
    }
    private static final int PF_NFC = (int)39L;
    /**
     * {@snippet lang=c :
     * #define PF_NFC 39
     * }
     */
    public static int PF_NFC() {
        return PF_NFC;
    }
    private static final int PF_VSOCK = (int)40L;
    /**
     * {@snippet lang=c :
     * #define PF_VSOCK 40
     * }
     */
    public static int PF_VSOCK() {
        return PF_VSOCK;
    }
    private static final int PF_KCM = (int)41L;
    /**
     * {@snippet lang=c :
     * #define PF_KCM 41
     * }
     */
    public static int PF_KCM() {
        return PF_KCM;
    }
    private static final int PF_QIPCRTR = (int)42L;
    /**
     * {@snippet lang=c :
     * #define PF_QIPCRTR 42
     * }
     */
    public static int PF_QIPCRTR() {
        return PF_QIPCRTR;
    }
    private static final int PF_SMC = (int)43L;
    /**
     * {@snippet lang=c :
     * #define PF_SMC 43
     * }
     */
    public static int PF_SMC() {
        return PF_SMC;
    }
    private static final int PF_XDP = (int)44L;
    /**
     * {@snippet lang=c :
     * #define PF_XDP 44
     * }
     */
    public static int PF_XDP() {
        return PF_XDP;
    }
    private static final int PF_MCTP = (int)45L;
    /**
     * {@snippet lang=c :
     * #define PF_MCTP 45
     * }
     */
    public static int PF_MCTP() {
        return PF_MCTP;
    }
    private static final int PF_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define PF_MAX 46
     * }
     */
    public static int PF_MAX() {
        return PF_MAX;
    }
    private static final int SOL_RAW = (int)255L;
    /**
     * {@snippet lang=c :
     * #define SOL_RAW 255
     * }
     */
    public static int SOL_RAW() {
        return SOL_RAW;
    }
    private static final int SOL_DECNET = (int)261L;
    /**
     * {@snippet lang=c :
     * #define SOL_DECNET 261
     * }
     */
    public static int SOL_DECNET() {
        return SOL_DECNET;
    }
    private static final int SOL_X25 = (int)262L;
    /**
     * {@snippet lang=c :
     * #define SOL_X25 262
     * }
     */
    public static int SOL_X25() {
        return SOL_X25;
    }
    private static final int SOL_PACKET = (int)263L;
    /**
     * {@snippet lang=c :
     * #define SOL_PACKET 263
     * }
     */
    public static int SOL_PACKET() {
        return SOL_PACKET;
    }
    private static final int SOL_ATM = (int)264L;
    /**
     * {@snippet lang=c :
     * #define SOL_ATM 264
     * }
     */
    public static int SOL_ATM() {
        return SOL_ATM;
    }
    private static final int SOL_AAL = (int)265L;
    /**
     * {@snippet lang=c :
     * #define SOL_AAL 265
     * }
     */
    public static int SOL_AAL() {
        return SOL_AAL;
    }
    private static final int SOL_IRDA = (int)266L;
    /**
     * {@snippet lang=c :
     * #define SOL_IRDA 266
     * }
     */
    public static int SOL_IRDA() {
        return SOL_IRDA;
    }
    private static final int SOL_NETBEUI = (int)267L;
    /**
     * {@snippet lang=c :
     * #define SOL_NETBEUI 267
     * }
     */
    public static int SOL_NETBEUI() {
        return SOL_NETBEUI;
    }
    private static final int SOL_LLC = (int)268L;
    /**
     * {@snippet lang=c :
     * #define SOL_LLC 268
     * }
     */
    public static int SOL_LLC() {
        return SOL_LLC;
    }
    private static final int SOL_DCCP = (int)269L;
    /**
     * {@snippet lang=c :
     * #define SOL_DCCP 269
     * }
     */
    public static int SOL_DCCP() {
        return SOL_DCCP;
    }
    private static final int SOL_NETLINK = (int)270L;
    /**
     * {@snippet lang=c :
     * #define SOL_NETLINK 270
     * }
     */
    public static int SOL_NETLINK() {
        return SOL_NETLINK;
    }
    private static final int SOL_TIPC = (int)271L;
    /**
     * {@snippet lang=c :
     * #define SOL_TIPC 271
     * }
     */
    public static int SOL_TIPC() {
        return SOL_TIPC;
    }
    private static final int SOL_RXRPC = (int)272L;
    /**
     * {@snippet lang=c :
     * #define SOL_RXRPC 272
     * }
     */
    public static int SOL_RXRPC() {
        return SOL_RXRPC;
    }
    private static final int SOL_PPPOL2TP = (int)273L;
    /**
     * {@snippet lang=c :
     * #define SOL_PPPOL2TP 273
     * }
     */
    public static int SOL_PPPOL2TP() {
        return SOL_PPPOL2TP;
    }
    private static final int SOL_BLUETOOTH = (int)274L;
    /**
     * {@snippet lang=c :
     * #define SOL_BLUETOOTH 274
     * }
     */
    public static int SOL_BLUETOOTH() {
        return SOL_BLUETOOTH;
    }
    private static final int SOL_PNPIPE = (int)275L;
    /**
     * {@snippet lang=c :
     * #define SOL_PNPIPE 275
     * }
     */
    public static int SOL_PNPIPE() {
        return SOL_PNPIPE;
    }
    private static final int SOL_RDS = (int)276L;
    /**
     * {@snippet lang=c :
     * #define SOL_RDS 276
     * }
     */
    public static int SOL_RDS() {
        return SOL_RDS;
    }
    private static final int SOL_IUCV = (int)277L;
    /**
     * {@snippet lang=c :
     * #define SOL_IUCV 277
     * }
     */
    public static int SOL_IUCV() {
        return SOL_IUCV;
    }
    private static final int SOL_CAIF = (int)278L;
    /**
     * {@snippet lang=c :
     * #define SOL_CAIF 278
     * }
     */
    public static int SOL_CAIF() {
        return SOL_CAIF;
    }
    private static final int SOL_ALG = (int)279L;
    /**
     * {@snippet lang=c :
     * #define SOL_ALG 279
     * }
     */
    public static int SOL_ALG() {
        return SOL_ALG;
    }
    private static final int SOL_NFC = (int)280L;
    /**
     * {@snippet lang=c :
     * #define SOL_NFC 280
     * }
     */
    public static int SOL_NFC() {
        return SOL_NFC;
    }
    private static final int SOL_KCM = (int)281L;
    /**
     * {@snippet lang=c :
     * #define SOL_KCM 281
     * }
     */
    public static int SOL_KCM() {
        return SOL_KCM;
    }
    private static final int SOL_TLS = (int)282L;
    /**
     * {@snippet lang=c :
     * #define SOL_TLS 282
     * }
     */
    public static int SOL_TLS() {
        return SOL_TLS;
    }
    private static final int SOL_XDP = (int)283L;
    /**
     * {@snippet lang=c :
     * #define SOL_XDP 283
     * }
     */
    public static int SOL_XDP() {
        return SOL_XDP;
    }
    private static final int SOL_MPTCP = (int)284L;
    /**
     * {@snippet lang=c :
     * #define SOL_MPTCP 284
     * }
     */
    public static int SOL_MPTCP() {
        return SOL_MPTCP;
    }
    private static final int SOL_MCTP = (int)285L;
    /**
     * {@snippet lang=c :
     * #define SOL_MCTP 285
     * }
     */
    public static int SOL_MCTP() {
        return SOL_MCTP;
    }
    private static final int SOL_SMC = (int)286L;
    /**
     * {@snippet lang=c :
     * #define SOL_SMC 286
     * }
     */
    public static int SOL_SMC() {
        return SOL_SMC;
    }
    private static final int SOMAXCONN = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define SOMAXCONN 4096
     * }
     */
    public static int SOMAXCONN() {
        return SOMAXCONN;
    }
    private static final int _BITS_SOCKADDR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_SOCKADDR_H 1
     * }
     */
    public static int _BITS_SOCKADDR_H() {
        return _BITS_SOCKADDR_H;
    }
    private static final int _SS_SIZE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SS_SIZE 128
     * }
     */
    public static int _SS_SIZE() {
        return _SS_SIZE;
    }
    private static final int __BITS_PER_LONG = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __BITS_PER_LONG 64
     * }
     */
    public static int __BITS_PER_LONG() {
        return __BITS_PER_LONG;
    }
    private static final int FIOSETOWN = (int)35073L;
    /**
     * {@snippet lang=c :
     * #define FIOSETOWN 35073
     * }
     */
    public static int FIOSETOWN() {
        return FIOSETOWN;
    }
    private static final int SIOCSPGRP = (int)35074L;
    /**
     * {@snippet lang=c :
     * #define SIOCSPGRP 35074
     * }
     */
    public static int SIOCSPGRP() {
        return SIOCSPGRP;
    }
    private static final int FIOGETOWN = (int)35075L;
    /**
     * {@snippet lang=c :
     * #define FIOGETOWN 35075
     * }
     */
    public static int FIOGETOWN() {
        return FIOGETOWN;
    }
    private static final int SIOCGPGRP = (int)35076L;
    /**
     * {@snippet lang=c :
     * #define SIOCGPGRP 35076
     * }
     */
    public static int SIOCGPGRP() {
        return SIOCGPGRP;
    }
    private static final int SIOCATMARK = (int)35077L;
    /**
     * {@snippet lang=c :
     * #define SIOCATMARK 35077
     * }
     */
    public static int SIOCATMARK() {
        return SIOCATMARK;
    }
    private static final int SIOCGSTAMP_OLD = (int)35078L;
    /**
     * {@snippet lang=c :
     * #define SIOCGSTAMP_OLD 35078
     * }
     */
    public static int SIOCGSTAMP_OLD() {
        return SIOCGSTAMP_OLD;
    }
    private static final int SIOCGSTAMPNS_OLD = (int)35079L;
    /**
     * {@snippet lang=c :
     * #define SIOCGSTAMPNS_OLD 35079
     * }
     */
    public static int SIOCGSTAMPNS_OLD() {
        return SIOCGSTAMPNS_OLD;
    }
    private static final int SOL_SOCKET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SOL_SOCKET 1
     * }
     */
    public static int SOL_SOCKET() {
        return SOL_SOCKET;
    }
    private static final int SO_DEBUG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SO_DEBUG 1
     * }
     */
    public static int SO_DEBUG() {
        return SO_DEBUG;
    }
    private static final int SO_REUSEADDR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SO_REUSEADDR 2
     * }
     */
    public static int SO_REUSEADDR() {
        return SO_REUSEADDR;
    }
    private static final int SO_TYPE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SO_TYPE 3
     * }
     */
    public static int SO_TYPE() {
        return SO_TYPE;
    }
    private static final int SO_ERROR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SO_ERROR 4
     * }
     */
    public static int SO_ERROR() {
        return SO_ERROR;
    }
    private static final int SO_DONTROUTE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SO_DONTROUTE 5
     * }
     */
    public static int SO_DONTROUTE() {
        return SO_DONTROUTE;
    }
    private static final int SO_BROADCAST = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SO_BROADCAST 6
     * }
     */
    public static int SO_BROADCAST() {
        return SO_BROADCAST;
    }
    private static final int SO_SNDBUF = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDBUF 7
     * }
     */
    public static int SO_SNDBUF() {
        return SO_SNDBUF;
    }
    private static final int SO_RCVBUF = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVBUF 8
     * }
     */
    public static int SO_RCVBUF() {
        return SO_RCVBUF;
    }
    private static final int SO_SNDBUFFORCE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDBUFFORCE 32
     * }
     */
    public static int SO_SNDBUFFORCE() {
        return SO_SNDBUFFORCE;
    }
    private static final int SO_RCVBUFFORCE = (int)33L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVBUFFORCE 33
     * }
     */
    public static int SO_RCVBUFFORCE() {
        return SO_RCVBUFFORCE;
    }
    private static final int SO_KEEPALIVE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SO_KEEPALIVE 9
     * }
     */
    public static int SO_KEEPALIVE() {
        return SO_KEEPALIVE;
    }
    private static final int SO_OOBINLINE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SO_OOBINLINE 10
     * }
     */
    public static int SO_OOBINLINE() {
        return SO_OOBINLINE;
    }
    private static final int SO_NO_CHECK = (int)11L;
    /**
     * {@snippet lang=c :
     * #define SO_NO_CHECK 11
     * }
     */
    public static int SO_NO_CHECK() {
        return SO_NO_CHECK;
    }
    private static final int SO_PRIORITY = (int)12L;
    /**
     * {@snippet lang=c :
     * #define SO_PRIORITY 12
     * }
     */
    public static int SO_PRIORITY() {
        return SO_PRIORITY;
    }
    private static final int SO_LINGER = (int)13L;
    /**
     * {@snippet lang=c :
     * #define SO_LINGER 13
     * }
     */
    public static int SO_LINGER() {
        return SO_LINGER;
    }
    private static final int SO_BSDCOMPAT = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SO_BSDCOMPAT 14
     * }
     */
    public static int SO_BSDCOMPAT() {
        return SO_BSDCOMPAT;
    }
    private static final int SO_REUSEPORT = (int)15L;
    /**
     * {@snippet lang=c :
     * #define SO_REUSEPORT 15
     * }
     */
    public static int SO_REUSEPORT() {
        return SO_REUSEPORT;
    }
    private static final int SO_PASSCRED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSCRED 16
     * }
     */
    public static int SO_PASSCRED() {
        return SO_PASSCRED;
    }
    private static final int SO_PEERCRED = (int)17L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERCRED 17
     * }
     */
    public static int SO_PEERCRED() {
        return SO_PEERCRED;
    }
    private static final int SO_RCVLOWAT = (int)18L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVLOWAT 18
     * }
     */
    public static int SO_RCVLOWAT() {
        return SO_RCVLOWAT;
    }
    private static final int SO_SNDLOWAT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDLOWAT 19
     * }
     */
    public static int SO_SNDLOWAT() {
        return SO_SNDLOWAT;
    }
    private static final int SO_RCVTIMEO_OLD = (int)20L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO_OLD 20
     * }
     */
    public static int SO_RCVTIMEO_OLD() {
        return SO_RCVTIMEO_OLD;
    }
    private static final int SO_SNDTIMEO_OLD = (int)21L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO_OLD 21
     * }
     */
    public static int SO_SNDTIMEO_OLD() {
        return SO_SNDTIMEO_OLD;
    }
    private static final int SO_SECURITY_AUTHENTICATION = (int)22L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_AUTHENTICATION 22
     * }
     */
    public static int SO_SECURITY_AUTHENTICATION() {
        return SO_SECURITY_AUTHENTICATION;
    }
    private static final int SO_SECURITY_ENCRYPTION_TRANSPORT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_ENCRYPTION_TRANSPORT 23
     * }
     */
    public static int SO_SECURITY_ENCRYPTION_TRANSPORT() {
        return SO_SECURITY_ENCRYPTION_TRANSPORT;
    }
    private static final int SO_SECURITY_ENCRYPTION_NETWORK = (int)24L;
    /**
     * {@snippet lang=c :
     * #define SO_SECURITY_ENCRYPTION_NETWORK 24
     * }
     */
    public static int SO_SECURITY_ENCRYPTION_NETWORK() {
        return SO_SECURITY_ENCRYPTION_NETWORK;
    }
    private static final int SO_BINDTODEVICE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define SO_BINDTODEVICE 25
     * }
     */
    public static int SO_BINDTODEVICE() {
        return SO_BINDTODEVICE;
    }
    private static final int SO_ATTACH_FILTER = (int)26L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_FILTER 26
     * }
     */
    public static int SO_ATTACH_FILTER() {
        return SO_ATTACH_FILTER;
    }
    private static final int SO_DETACH_FILTER = (int)27L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_FILTER 27
     * }
     */
    public static int SO_DETACH_FILTER() {
        return SO_DETACH_FILTER;
    }
    private static final int SO_PEERNAME = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERNAME 28
     * }
     */
    public static int SO_PEERNAME() {
        return SO_PEERNAME;
    }
    private static final int SO_ACCEPTCONN = (int)30L;
    /**
     * {@snippet lang=c :
     * #define SO_ACCEPTCONN 30
     * }
     */
    public static int SO_ACCEPTCONN() {
        return SO_ACCEPTCONN;
    }
    private static final int SO_PEERSEC = (int)31L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERSEC 31
     * }
     */
    public static int SO_PEERSEC() {
        return SO_PEERSEC;
    }
    private static final int SO_PASSSEC = (int)34L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSSEC 34
     * }
     */
    public static int SO_PASSSEC() {
        return SO_PASSSEC;
    }
    private static final int SO_MARK = (int)36L;
    /**
     * {@snippet lang=c :
     * #define SO_MARK 36
     * }
     */
    public static int SO_MARK() {
        return SO_MARK;
    }
    private static final int SO_PROTOCOL = (int)38L;
    /**
     * {@snippet lang=c :
     * #define SO_PROTOCOL 38
     * }
     */
    public static int SO_PROTOCOL() {
        return SO_PROTOCOL;
    }
    private static final int SO_DOMAIN = (int)39L;
    /**
     * {@snippet lang=c :
     * #define SO_DOMAIN 39
     * }
     */
    public static int SO_DOMAIN() {
        return SO_DOMAIN;
    }
    private static final int SO_RXQ_OVFL = (int)40L;
    /**
     * {@snippet lang=c :
     * #define SO_RXQ_OVFL 40
     * }
     */
    public static int SO_RXQ_OVFL() {
        return SO_RXQ_OVFL;
    }
    private static final int SO_WIFI_STATUS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define SO_WIFI_STATUS 41
     * }
     */
    public static int SO_WIFI_STATUS() {
        return SO_WIFI_STATUS;
    }
    private static final int SO_PEEK_OFF = (int)42L;
    /**
     * {@snippet lang=c :
     * #define SO_PEEK_OFF 42
     * }
     */
    public static int SO_PEEK_OFF() {
        return SO_PEEK_OFF;
    }
    private static final int SO_NOFCS = (int)43L;
    /**
     * {@snippet lang=c :
     * #define SO_NOFCS 43
     * }
     */
    public static int SO_NOFCS() {
        return SO_NOFCS;
    }
    private static final int SO_LOCK_FILTER = (int)44L;
    /**
     * {@snippet lang=c :
     * #define SO_LOCK_FILTER 44
     * }
     */
    public static int SO_LOCK_FILTER() {
        return SO_LOCK_FILTER;
    }
    private static final int SO_SELECT_ERR_QUEUE = (int)45L;
    /**
     * {@snippet lang=c :
     * #define SO_SELECT_ERR_QUEUE 45
     * }
     */
    public static int SO_SELECT_ERR_QUEUE() {
        return SO_SELECT_ERR_QUEUE;
    }
    private static final int SO_BUSY_POLL = (int)46L;
    /**
     * {@snippet lang=c :
     * #define SO_BUSY_POLL 46
     * }
     */
    public static int SO_BUSY_POLL() {
        return SO_BUSY_POLL;
    }
    private static final int SO_MAX_PACING_RATE = (int)47L;
    /**
     * {@snippet lang=c :
     * #define SO_MAX_PACING_RATE 47
     * }
     */
    public static int SO_MAX_PACING_RATE() {
        return SO_MAX_PACING_RATE;
    }
    private static final int SO_BPF_EXTENSIONS = (int)48L;
    /**
     * {@snippet lang=c :
     * #define SO_BPF_EXTENSIONS 48
     * }
     */
    public static int SO_BPF_EXTENSIONS() {
        return SO_BPF_EXTENSIONS;
    }
    private static final int SO_INCOMING_CPU = (int)49L;
    /**
     * {@snippet lang=c :
     * #define SO_INCOMING_CPU 49
     * }
     */
    public static int SO_INCOMING_CPU() {
        return SO_INCOMING_CPU;
    }
    private static final int SO_ATTACH_BPF = (int)50L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_BPF 50
     * }
     */
    public static int SO_ATTACH_BPF() {
        return SO_ATTACH_BPF;
    }
    private static final int SO_ATTACH_REUSEPORT_CBPF = (int)51L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_REUSEPORT_CBPF 51
     * }
     */
    public static int SO_ATTACH_REUSEPORT_CBPF() {
        return SO_ATTACH_REUSEPORT_CBPF;
    }
    private static final int SO_ATTACH_REUSEPORT_EBPF = (int)52L;
    /**
     * {@snippet lang=c :
     * #define SO_ATTACH_REUSEPORT_EBPF 52
     * }
     */
    public static int SO_ATTACH_REUSEPORT_EBPF() {
        return SO_ATTACH_REUSEPORT_EBPF;
    }
    private static final int SO_CNX_ADVICE = (int)53L;
    /**
     * {@snippet lang=c :
     * #define SO_CNX_ADVICE 53
     * }
     */
    public static int SO_CNX_ADVICE() {
        return SO_CNX_ADVICE;
    }
    private static final int SCM_TIMESTAMPING_OPT_STATS = (int)54L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING_OPT_STATS 54
     * }
     */
    public static int SCM_TIMESTAMPING_OPT_STATS() {
        return SCM_TIMESTAMPING_OPT_STATS;
    }
    private static final int SO_MEMINFO = (int)55L;
    /**
     * {@snippet lang=c :
     * #define SO_MEMINFO 55
     * }
     */
    public static int SO_MEMINFO() {
        return SO_MEMINFO;
    }
    private static final int SO_INCOMING_NAPI_ID = (int)56L;
    /**
     * {@snippet lang=c :
     * #define SO_INCOMING_NAPI_ID 56
     * }
     */
    public static int SO_INCOMING_NAPI_ID() {
        return SO_INCOMING_NAPI_ID;
    }
    private static final int SO_COOKIE = (int)57L;
    /**
     * {@snippet lang=c :
     * #define SO_COOKIE 57
     * }
     */
    public static int SO_COOKIE() {
        return SO_COOKIE;
    }
    private static final int SCM_TIMESTAMPING_PKTINFO = (int)58L;
    /**
     * {@snippet lang=c :
     * #define SCM_TIMESTAMPING_PKTINFO 58
     * }
     */
    public static int SCM_TIMESTAMPING_PKTINFO() {
        return SCM_TIMESTAMPING_PKTINFO;
    }
    private static final int SO_PEERGROUPS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERGROUPS 59
     * }
     */
    public static int SO_PEERGROUPS() {
        return SO_PEERGROUPS;
    }
    private static final int SO_ZEROCOPY = (int)60L;
    /**
     * {@snippet lang=c :
     * #define SO_ZEROCOPY 60
     * }
     */
    public static int SO_ZEROCOPY() {
        return SO_ZEROCOPY;
    }
    private static final int SO_TXTIME = (int)61L;
    /**
     * {@snippet lang=c :
     * #define SO_TXTIME 61
     * }
     */
    public static int SO_TXTIME() {
        return SO_TXTIME;
    }
    private static final int SO_BINDTOIFINDEX = (int)62L;
    /**
     * {@snippet lang=c :
     * #define SO_BINDTOIFINDEX 62
     * }
     */
    public static int SO_BINDTOIFINDEX() {
        return SO_BINDTOIFINDEX;
    }
    private static final int SO_TIMESTAMP_OLD = (int)29L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP_OLD 29
     * }
     */
    public static int SO_TIMESTAMP_OLD() {
        return SO_TIMESTAMP_OLD;
    }
    private static final int SO_TIMESTAMPNS_OLD = (int)35L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS_OLD 35
     * }
     */
    public static int SO_TIMESTAMPNS_OLD() {
        return SO_TIMESTAMPNS_OLD;
    }
    private static final int SO_TIMESTAMPING_OLD = (int)37L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING_OLD 37
     * }
     */
    public static int SO_TIMESTAMPING_OLD() {
        return SO_TIMESTAMPING_OLD;
    }
    private static final int SO_TIMESTAMP_NEW = (int)63L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMP_NEW 63
     * }
     */
    public static int SO_TIMESTAMP_NEW() {
        return SO_TIMESTAMP_NEW;
    }
    private static final int SO_TIMESTAMPNS_NEW = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPNS_NEW 64
     * }
     */
    public static int SO_TIMESTAMPNS_NEW() {
        return SO_TIMESTAMPNS_NEW;
    }
    private static final int SO_TIMESTAMPING_NEW = (int)65L;
    /**
     * {@snippet lang=c :
     * #define SO_TIMESTAMPING_NEW 65
     * }
     */
    public static int SO_TIMESTAMPING_NEW() {
        return SO_TIMESTAMPING_NEW;
    }
    private static final int SO_RCVTIMEO_NEW = (int)66L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVTIMEO_NEW 66
     * }
     */
    public static int SO_RCVTIMEO_NEW() {
        return SO_RCVTIMEO_NEW;
    }
    private static final int SO_SNDTIMEO_NEW = (int)67L;
    /**
     * {@snippet lang=c :
     * #define SO_SNDTIMEO_NEW 67
     * }
     */
    public static int SO_SNDTIMEO_NEW() {
        return SO_SNDTIMEO_NEW;
    }
    private static final int SO_DETACH_REUSEPORT_BPF = (int)68L;
    /**
     * {@snippet lang=c :
     * #define SO_DETACH_REUSEPORT_BPF 68
     * }
     */
    public static int SO_DETACH_REUSEPORT_BPF() {
        return SO_DETACH_REUSEPORT_BPF;
    }
    private static final int SO_PREFER_BUSY_POLL = (int)69L;
    /**
     * {@snippet lang=c :
     * #define SO_PREFER_BUSY_POLL 69
     * }
     */
    public static int SO_PREFER_BUSY_POLL() {
        return SO_PREFER_BUSY_POLL;
    }
    private static final int SO_BUSY_POLL_BUDGET = (int)70L;
    /**
     * {@snippet lang=c :
     * #define SO_BUSY_POLL_BUDGET 70
     * }
     */
    public static int SO_BUSY_POLL_BUDGET() {
        return SO_BUSY_POLL_BUDGET;
    }
    private static final int SO_NETNS_COOKIE = (int)71L;
    /**
     * {@snippet lang=c :
     * #define SO_NETNS_COOKIE 71
     * }
     */
    public static int SO_NETNS_COOKIE() {
        return SO_NETNS_COOKIE;
    }
    private static final int SO_BUF_LOCK = (int)72L;
    /**
     * {@snippet lang=c :
     * #define SO_BUF_LOCK 72
     * }
     */
    public static int SO_BUF_LOCK() {
        return SO_BUF_LOCK;
    }
    private static final int SO_RESERVE_MEM = (int)73L;
    /**
     * {@snippet lang=c :
     * #define SO_RESERVE_MEM 73
     * }
     */
    public static int SO_RESERVE_MEM() {
        return SO_RESERVE_MEM;
    }
    private static final int SO_TXREHASH = (int)74L;
    /**
     * {@snippet lang=c :
     * #define SO_TXREHASH 74
     * }
     */
    public static int SO_TXREHASH() {
        return SO_TXREHASH;
    }
    private static final int SO_RCVMARK = (int)75L;
    /**
     * {@snippet lang=c :
     * #define SO_RCVMARK 75
     * }
     */
    public static int SO_RCVMARK() {
        return SO_RCVMARK;
    }
    private static final int SO_PASSPIDFD = (int)76L;
    /**
     * {@snippet lang=c :
     * #define SO_PASSPIDFD 76
     * }
     */
    public static int SO_PASSPIDFD() {
        return SO_PASSPIDFD;
    }
    private static final int SO_PEERPIDFD = (int)77L;
    /**
     * {@snippet lang=c :
     * #define SO_PEERPIDFD 77
     * }
     */
    public static int SO_PEERPIDFD() {
        return SO_PEERPIDFD;
    }
    private static final int __osockaddr_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __osockaddr_defined 1
     * }
     */
    public static int __osockaddr_defined() {
        return __osockaddr_defined;
    }
    private static final int __USE_KERNEL_IPV6_DEFS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_KERNEL_IPV6_DEFS 0
     * }
     */
    public static int __USE_KERNEL_IPV6_DEFS() {
        return __USE_KERNEL_IPV6_DEFS;
    }
    private static final int IP_OPTIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IP_OPTIONS 4
     * }
     */
    public static int IP_OPTIONS() {
        return IP_OPTIONS;
    }
    private static final int IP_HDRINCL = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IP_HDRINCL 3
     * }
     */
    public static int IP_HDRINCL() {
        return IP_HDRINCL;
    }
    private static final int IP_TOS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IP_TOS 1
     * }
     */
    public static int IP_TOS() {
        return IP_TOS;
    }
    private static final int IP_TTL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IP_TTL 2
     * }
     */
    public static int IP_TTL() {
        return IP_TTL;
    }
    private static final int IP_RECVOPTS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVOPTS 6
     * }
     */
    public static int IP_RECVOPTS() {
        return IP_RECVOPTS;
    }
    private static final int IP_RETOPTS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IP_RETOPTS 7
     * }
     */
    public static int IP_RETOPTS() {
        return IP_RETOPTS;
    }
    private static final int IP_MULTICAST_IF = (int)32L;
    /**
     * {@snippet lang=c :
     * #define IP_MULTICAST_IF 32
     * }
     */
    public static int IP_MULTICAST_IF() {
        return IP_MULTICAST_IF;
    }
    private static final int IP_MULTICAST_TTL = (int)33L;
    /**
     * {@snippet lang=c :
     * #define IP_MULTICAST_TTL 33
     * }
     */
    public static int IP_MULTICAST_TTL() {
        return IP_MULTICAST_TTL;
    }
    private static final int IP_MULTICAST_LOOP = (int)34L;
    /**
     * {@snippet lang=c :
     * #define IP_MULTICAST_LOOP 34
     * }
     */
    public static int IP_MULTICAST_LOOP() {
        return IP_MULTICAST_LOOP;
    }
    private static final int IP_ADD_MEMBERSHIP = (int)35L;
    /**
     * {@snippet lang=c :
     * #define IP_ADD_MEMBERSHIP 35
     * }
     */
    public static int IP_ADD_MEMBERSHIP() {
        return IP_ADD_MEMBERSHIP;
    }
    private static final int IP_DROP_MEMBERSHIP = (int)36L;
    /**
     * {@snippet lang=c :
     * #define IP_DROP_MEMBERSHIP 36
     * }
     */
    public static int IP_DROP_MEMBERSHIP() {
        return IP_DROP_MEMBERSHIP;
    }
    private static final int IP_UNBLOCK_SOURCE = (int)37L;
    /**
     * {@snippet lang=c :
     * #define IP_UNBLOCK_SOURCE 37
     * }
     */
    public static int IP_UNBLOCK_SOURCE() {
        return IP_UNBLOCK_SOURCE;
    }
    private static final int IP_BLOCK_SOURCE = (int)38L;
    /**
     * {@snippet lang=c :
     * #define IP_BLOCK_SOURCE 38
     * }
     */
    public static int IP_BLOCK_SOURCE() {
        return IP_BLOCK_SOURCE;
    }
    private static final int IP_ADD_SOURCE_MEMBERSHIP = (int)39L;
    /**
     * {@snippet lang=c :
     * #define IP_ADD_SOURCE_MEMBERSHIP 39
     * }
     */
    public static int IP_ADD_SOURCE_MEMBERSHIP() {
        return IP_ADD_SOURCE_MEMBERSHIP;
    }
    private static final int IP_DROP_SOURCE_MEMBERSHIP = (int)40L;
    /**
     * {@snippet lang=c :
     * #define IP_DROP_SOURCE_MEMBERSHIP 40
     * }
     */
    public static int IP_DROP_SOURCE_MEMBERSHIP() {
        return IP_DROP_SOURCE_MEMBERSHIP;
    }
    private static final int IP_MSFILTER = (int)41L;
    /**
     * {@snippet lang=c :
     * #define IP_MSFILTER 41
     * }
     */
    public static int IP_MSFILTER() {
        return IP_MSFILTER;
    }
    private static final int MCAST_JOIN_GROUP = (int)42L;
    /**
     * {@snippet lang=c :
     * #define MCAST_JOIN_GROUP 42
     * }
     */
    public static int MCAST_JOIN_GROUP() {
        return MCAST_JOIN_GROUP;
    }
    private static final int MCAST_BLOCK_SOURCE = (int)43L;
    /**
     * {@snippet lang=c :
     * #define MCAST_BLOCK_SOURCE 43
     * }
     */
    public static int MCAST_BLOCK_SOURCE() {
        return MCAST_BLOCK_SOURCE;
    }
    private static final int MCAST_UNBLOCK_SOURCE = (int)44L;
    /**
     * {@snippet lang=c :
     * #define MCAST_UNBLOCK_SOURCE 44
     * }
     */
    public static int MCAST_UNBLOCK_SOURCE() {
        return MCAST_UNBLOCK_SOURCE;
    }
    private static final int MCAST_LEAVE_GROUP = (int)45L;
    /**
     * {@snippet lang=c :
     * #define MCAST_LEAVE_GROUP 45
     * }
     */
    public static int MCAST_LEAVE_GROUP() {
        return MCAST_LEAVE_GROUP;
    }
    private static final int MCAST_JOIN_SOURCE_GROUP = (int)46L;
    /**
     * {@snippet lang=c :
     * #define MCAST_JOIN_SOURCE_GROUP 46
     * }
     */
    public static int MCAST_JOIN_SOURCE_GROUP() {
        return MCAST_JOIN_SOURCE_GROUP;
    }
    private static final int MCAST_LEAVE_SOURCE_GROUP = (int)47L;
    /**
     * {@snippet lang=c :
     * #define MCAST_LEAVE_SOURCE_GROUP 47
     * }
     */
    public static int MCAST_LEAVE_SOURCE_GROUP() {
        return MCAST_LEAVE_SOURCE_GROUP;
    }
    private static final int MCAST_MSFILTER = (int)48L;
    /**
     * {@snippet lang=c :
     * #define MCAST_MSFILTER 48
     * }
     */
    public static int MCAST_MSFILTER() {
        return MCAST_MSFILTER;
    }
    private static final int IP_MULTICAST_ALL = (int)49L;
    /**
     * {@snippet lang=c :
     * #define IP_MULTICAST_ALL 49
     * }
     */
    public static int IP_MULTICAST_ALL() {
        return IP_MULTICAST_ALL;
    }
    private static final int IP_UNICAST_IF = (int)50L;
    /**
     * {@snippet lang=c :
     * #define IP_UNICAST_IF 50
     * }
     */
    public static int IP_UNICAST_IF() {
        return IP_UNICAST_IF;
    }
    private static final int MCAST_EXCLUDE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define MCAST_EXCLUDE 0
     * }
     */
    public static int MCAST_EXCLUDE() {
        return MCAST_EXCLUDE;
    }
    private static final int MCAST_INCLUDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define MCAST_INCLUDE 1
     * }
     */
    public static int MCAST_INCLUDE() {
        return MCAST_INCLUDE;
    }
    private static final int IP_ROUTER_ALERT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IP_ROUTER_ALERT 5
     * }
     */
    public static int IP_ROUTER_ALERT() {
        return IP_ROUTER_ALERT;
    }
    private static final int IP_PKTINFO = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IP_PKTINFO 8
     * }
     */
    public static int IP_PKTINFO() {
        return IP_PKTINFO;
    }
    private static final int IP_PKTOPTIONS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define IP_PKTOPTIONS 9
     * }
     */
    public static int IP_PKTOPTIONS() {
        return IP_PKTOPTIONS;
    }
    private static final int IP_PMTUDISC = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC 10
     * }
     */
    public static int IP_PMTUDISC() {
        return IP_PMTUDISC;
    }
    private static final int IP_MTU_DISCOVER = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IP_MTU_DISCOVER 10
     * }
     */
    public static int IP_MTU_DISCOVER() {
        return IP_MTU_DISCOVER;
    }
    private static final int IP_RECVERR = (int)11L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVERR 11
     * }
     */
    public static int IP_RECVERR() {
        return IP_RECVERR;
    }
    private static final int IP_RECVTTL = (int)12L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVTTL 12
     * }
     */
    public static int IP_RECVTTL() {
        return IP_RECVTTL;
    }
    private static final int IP_RECVTOS = (int)13L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVTOS 13
     * }
     */
    public static int IP_RECVTOS() {
        return IP_RECVTOS;
    }
    private static final int IP_MTU = (int)14L;
    /**
     * {@snippet lang=c :
     * #define IP_MTU 14
     * }
     */
    public static int IP_MTU() {
        return IP_MTU;
    }
    private static final int IP_FREEBIND = (int)15L;
    /**
     * {@snippet lang=c :
     * #define IP_FREEBIND 15
     * }
     */
    public static int IP_FREEBIND() {
        return IP_FREEBIND;
    }
    private static final int IP_IPSEC_POLICY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define IP_IPSEC_POLICY 16
     * }
     */
    public static int IP_IPSEC_POLICY() {
        return IP_IPSEC_POLICY;
    }
    private static final int IP_XFRM_POLICY = (int)17L;
    /**
     * {@snippet lang=c :
     * #define IP_XFRM_POLICY 17
     * }
     */
    public static int IP_XFRM_POLICY() {
        return IP_XFRM_POLICY;
    }
    private static final int IP_PASSSEC = (int)18L;
    /**
     * {@snippet lang=c :
     * #define IP_PASSSEC 18
     * }
     */
    public static int IP_PASSSEC() {
        return IP_PASSSEC;
    }
    private static final int IP_TRANSPARENT = (int)19L;
    /**
     * {@snippet lang=c :
     * #define IP_TRANSPARENT 19
     * }
     */
    public static int IP_TRANSPARENT() {
        return IP_TRANSPARENT;
    }
    private static final int IP_ORIGDSTADDR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define IP_ORIGDSTADDR 20
     * }
     */
    public static int IP_ORIGDSTADDR() {
        return IP_ORIGDSTADDR;
    }
    private static final int IP_MINTTL = (int)21L;
    /**
     * {@snippet lang=c :
     * #define IP_MINTTL 21
     * }
     */
    public static int IP_MINTTL() {
        return IP_MINTTL;
    }
    private static final int IP_NODEFRAG = (int)22L;
    /**
     * {@snippet lang=c :
     * #define IP_NODEFRAG 22
     * }
     */
    public static int IP_NODEFRAG() {
        return IP_NODEFRAG;
    }
    private static final int IP_CHECKSUM = (int)23L;
    /**
     * {@snippet lang=c :
     * #define IP_CHECKSUM 23
     * }
     */
    public static int IP_CHECKSUM() {
        return IP_CHECKSUM;
    }
    private static final int IP_BIND_ADDRESS_NO_PORT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define IP_BIND_ADDRESS_NO_PORT 24
     * }
     */
    public static int IP_BIND_ADDRESS_NO_PORT() {
        return IP_BIND_ADDRESS_NO_PORT;
    }
    private static final int IP_RECVFRAGSIZE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVFRAGSIZE 25
     * }
     */
    public static int IP_RECVFRAGSIZE() {
        return IP_RECVFRAGSIZE;
    }
    private static final int IP_RECVERR_RFC4884 = (int)26L;
    /**
     * {@snippet lang=c :
     * #define IP_RECVERR_RFC4884 26
     * }
     */
    public static int IP_RECVERR_RFC4884() {
        return IP_RECVERR_RFC4884;
    }
    private static final int IP_PMTUDISC_DONT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_DONT 0
     * }
     */
    public static int IP_PMTUDISC_DONT() {
        return IP_PMTUDISC_DONT;
    }
    private static final int IP_PMTUDISC_WANT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_WANT 1
     * }
     */
    public static int IP_PMTUDISC_WANT() {
        return IP_PMTUDISC_WANT;
    }
    private static final int IP_PMTUDISC_DO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_DO 2
     * }
     */
    public static int IP_PMTUDISC_DO() {
        return IP_PMTUDISC_DO;
    }
    private static final int IP_PMTUDISC_PROBE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_PROBE 3
     * }
     */
    public static int IP_PMTUDISC_PROBE() {
        return IP_PMTUDISC_PROBE;
    }
    private static final int IP_PMTUDISC_INTERFACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_INTERFACE 4
     * }
     */
    public static int IP_PMTUDISC_INTERFACE() {
        return IP_PMTUDISC_INTERFACE;
    }
    private static final int IP_PMTUDISC_OMIT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IP_PMTUDISC_OMIT 5
     * }
     */
    public static int IP_PMTUDISC_OMIT() {
        return IP_PMTUDISC_OMIT;
    }
    private static final int IP_LOCAL_PORT_RANGE = (int)51L;
    /**
     * {@snippet lang=c :
     * #define IP_LOCAL_PORT_RANGE 51
     * }
     */
    public static int IP_LOCAL_PORT_RANGE() {
        return IP_LOCAL_PORT_RANGE;
    }
    private static final int IP_PROTOCOL = (int)52L;
    /**
     * {@snippet lang=c :
     * #define IP_PROTOCOL 52
     * }
     */
    public static int IP_PROTOCOL() {
        return IP_PROTOCOL;
    }
    private static final int SOL_IP = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SOL_IP 0
     * }
     */
    public static int SOL_IP() {
        return SOL_IP;
    }
    private static final int IP_DEFAULT_MULTICAST_TTL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IP_DEFAULT_MULTICAST_TTL 1
     * }
     */
    public static int IP_DEFAULT_MULTICAST_TTL() {
        return IP_DEFAULT_MULTICAST_TTL;
    }
    private static final int IP_DEFAULT_MULTICAST_LOOP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IP_DEFAULT_MULTICAST_LOOP 1
     * }
     */
    public static int IP_DEFAULT_MULTICAST_LOOP() {
        return IP_DEFAULT_MULTICAST_LOOP;
    }
    private static final int IP_MAX_MEMBERSHIPS = (int)20L;
    /**
     * {@snippet lang=c :
     * #define IP_MAX_MEMBERSHIPS 20
     * }
     */
    public static int IP_MAX_MEMBERSHIPS() {
        return IP_MAX_MEMBERSHIPS;
    }
    private static final int IPV6_ADDRFORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ADDRFORM 1
     * }
     */
    public static int IPV6_ADDRFORM() {
        return IPV6_ADDRFORM;
    }
    private static final int IPV6_2292PKTINFO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292PKTINFO 2
     * }
     */
    public static int IPV6_2292PKTINFO() {
        return IPV6_2292PKTINFO;
    }
    private static final int IPV6_2292HOPOPTS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292HOPOPTS 3
     * }
     */
    public static int IPV6_2292HOPOPTS() {
        return IPV6_2292HOPOPTS;
    }
    private static final int IPV6_2292DSTOPTS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292DSTOPTS 4
     * }
     */
    public static int IPV6_2292DSTOPTS() {
        return IPV6_2292DSTOPTS;
    }
    private static final int IPV6_2292RTHDR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292RTHDR 5
     * }
     */
    public static int IPV6_2292RTHDR() {
        return IPV6_2292RTHDR;
    }
    private static final int IPV6_2292PKTOPTIONS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292PKTOPTIONS 6
     * }
     */
    public static int IPV6_2292PKTOPTIONS() {
        return IPV6_2292PKTOPTIONS;
    }
    private static final int IPV6_CHECKSUM = (int)7L;
    /**
     * {@snippet lang=c :
     * #define IPV6_CHECKSUM 7
     * }
     */
    public static int IPV6_CHECKSUM() {
        return IPV6_CHECKSUM;
    }
    private static final int IPV6_2292HOPLIMIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IPV6_2292HOPLIMIT 8
     * }
     */
    public static int IPV6_2292HOPLIMIT() {
        return IPV6_2292HOPLIMIT;
    }
    private static final int IPV6_NEXTHOP = (int)9L;
    /**
     * {@snippet lang=c :
     * #define IPV6_NEXTHOP 9
     * }
     */
    public static int IPV6_NEXTHOP() {
        return IPV6_NEXTHOP;
    }
    private static final int IPV6_AUTHHDR = (int)10L;
    /**
     * {@snippet lang=c :
     * #define IPV6_AUTHHDR 10
     * }
     */
    public static int IPV6_AUTHHDR() {
        return IPV6_AUTHHDR;
    }
    private static final int IPV6_UNICAST_HOPS = (int)16L;
    /**
     * {@snippet lang=c :
     * #define IPV6_UNICAST_HOPS 16
     * }
     */
    public static int IPV6_UNICAST_HOPS() {
        return IPV6_UNICAST_HOPS;
    }
    private static final int IPV6_MULTICAST_IF = (int)17L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MULTICAST_IF 17
     * }
     */
    public static int IPV6_MULTICAST_IF() {
        return IPV6_MULTICAST_IF;
    }
    private static final int IPV6_MULTICAST_HOPS = (int)18L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MULTICAST_HOPS 18
     * }
     */
    public static int IPV6_MULTICAST_HOPS() {
        return IPV6_MULTICAST_HOPS;
    }
    private static final int IPV6_MULTICAST_LOOP = (int)19L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MULTICAST_LOOP 19
     * }
     */
    public static int IPV6_MULTICAST_LOOP() {
        return IPV6_MULTICAST_LOOP;
    }
    private static final int IPV6_JOIN_GROUP = (int)20L;
    /**
     * {@snippet lang=c :
     * #define IPV6_JOIN_GROUP 20
     * }
     */
    public static int IPV6_JOIN_GROUP() {
        return IPV6_JOIN_GROUP;
    }
    private static final int IPV6_LEAVE_GROUP = (int)21L;
    /**
     * {@snippet lang=c :
     * #define IPV6_LEAVE_GROUP 21
     * }
     */
    public static int IPV6_LEAVE_GROUP() {
        return IPV6_LEAVE_GROUP;
    }
    private static final int IPV6_ROUTER_ALERT = (int)22L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ROUTER_ALERT 22
     * }
     */
    public static int IPV6_ROUTER_ALERT() {
        return IPV6_ROUTER_ALERT;
    }
    private static final int IPV6_MTU_DISCOVER = (int)23L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MTU_DISCOVER 23
     * }
     */
    public static int IPV6_MTU_DISCOVER() {
        return IPV6_MTU_DISCOVER;
    }
    private static final int IPV6_MTU = (int)24L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MTU 24
     * }
     */
    public static int IPV6_MTU() {
        return IPV6_MTU;
    }
    private static final int IPV6_RECVERR = (int)25L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVERR 25
     * }
     */
    public static int IPV6_RECVERR() {
        return IPV6_RECVERR;
    }
    private static final int IPV6_V6ONLY = (int)26L;
    /**
     * {@snippet lang=c :
     * #define IPV6_V6ONLY 26
     * }
     */
    public static int IPV6_V6ONLY() {
        return IPV6_V6ONLY;
    }
    private static final int IPV6_JOIN_ANYCAST = (int)27L;
    /**
     * {@snippet lang=c :
     * #define IPV6_JOIN_ANYCAST 27
     * }
     */
    public static int IPV6_JOIN_ANYCAST() {
        return IPV6_JOIN_ANYCAST;
    }
    private static final int IPV6_LEAVE_ANYCAST = (int)28L;
    /**
     * {@snippet lang=c :
     * #define IPV6_LEAVE_ANYCAST 28
     * }
     */
    public static int IPV6_LEAVE_ANYCAST() {
        return IPV6_LEAVE_ANYCAST;
    }
    private static final int IPV6_MULTICAST_ALL = (int)29L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MULTICAST_ALL 29
     * }
     */
    public static int IPV6_MULTICAST_ALL() {
        return IPV6_MULTICAST_ALL;
    }
    private static final int IPV6_ROUTER_ALERT_ISOLATE = (int)30L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ROUTER_ALERT_ISOLATE 30
     * }
     */
    public static int IPV6_ROUTER_ALERT_ISOLATE() {
        return IPV6_ROUTER_ALERT_ISOLATE;
    }
    private static final int IPV6_RECVERR_RFC4884 = (int)31L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVERR_RFC4884 31
     * }
     */
    public static int IPV6_RECVERR_RFC4884() {
        return IPV6_RECVERR_RFC4884;
    }
    private static final int IPV6_IPSEC_POLICY = (int)34L;
    /**
     * {@snippet lang=c :
     * #define IPV6_IPSEC_POLICY 34
     * }
     */
    public static int IPV6_IPSEC_POLICY() {
        return IPV6_IPSEC_POLICY;
    }
    private static final int IPV6_XFRM_POLICY = (int)35L;
    /**
     * {@snippet lang=c :
     * #define IPV6_XFRM_POLICY 35
     * }
     */
    public static int IPV6_XFRM_POLICY() {
        return IPV6_XFRM_POLICY;
    }
    private static final int IPV6_HDRINCL = (int)36L;
    /**
     * {@snippet lang=c :
     * #define IPV6_HDRINCL 36
     * }
     */
    public static int IPV6_HDRINCL() {
        return IPV6_HDRINCL;
    }
    private static final int IPV6_RECVPKTINFO = (int)49L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVPKTINFO 49
     * }
     */
    public static int IPV6_RECVPKTINFO() {
        return IPV6_RECVPKTINFO;
    }
    private static final int IPV6_PKTINFO = (int)50L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PKTINFO 50
     * }
     */
    public static int IPV6_PKTINFO() {
        return IPV6_PKTINFO;
    }
    private static final int IPV6_RECVHOPLIMIT = (int)51L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVHOPLIMIT 51
     * }
     */
    public static int IPV6_RECVHOPLIMIT() {
        return IPV6_RECVHOPLIMIT;
    }
    private static final int IPV6_HOPLIMIT = (int)52L;
    /**
     * {@snippet lang=c :
     * #define IPV6_HOPLIMIT 52
     * }
     */
    public static int IPV6_HOPLIMIT() {
        return IPV6_HOPLIMIT;
    }
    private static final int IPV6_RECVHOPOPTS = (int)53L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVHOPOPTS 53
     * }
     */
    public static int IPV6_RECVHOPOPTS() {
        return IPV6_RECVHOPOPTS;
    }
    private static final int IPV6_HOPOPTS = (int)54L;
    /**
     * {@snippet lang=c :
     * #define IPV6_HOPOPTS 54
     * }
     */
    public static int IPV6_HOPOPTS() {
        return IPV6_HOPOPTS;
    }
    private static final int IPV6_RTHDRDSTOPTS = (int)55L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDRDSTOPTS 55
     * }
     */
    public static int IPV6_RTHDRDSTOPTS() {
        return IPV6_RTHDRDSTOPTS;
    }
    private static final int IPV6_RECVRTHDR = (int)56L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVRTHDR 56
     * }
     */
    public static int IPV6_RECVRTHDR() {
        return IPV6_RECVRTHDR;
    }
    private static final int IPV6_RTHDR = (int)57L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDR 57
     * }
     */
    public static int IPV6_RTHDR() {
        return IPV6_RTHDR;
    }
    private static final int IPV6_RECVDSTOPTS = (int)58L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVDSTOPTS 58
     * }
     */
    public static int IPV6_RECVDSTOPTS() {
        return IPV6_RECVDSTOPTS;
    }
    private static final int IPV6_DSTOPTS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define IPV6_DSTOPTS 59
     * }
     */
    public static int IPV6_DSTOPTS() {
        return IPV6_DSTOPTS;
    }
    private static final int IPV6_RECVPATHMTU = (int)60L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVPATHMTU 60
     * }
     */
    public static int IPV6_RECVPATHMTU() {
        return IPV6_RECVPATHMTU;
    }
    private static final int IPV6_PATHMTU = (int)61L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PATHMTU 61
     * }
     */
    public static int IPV6_PATHMTU() {
        return IPV6_PATHMTU;
    }
    private static final int IPV6_DONTFRAG = (int)62L;
    /**
     * {@snippet lang=c :
     * #define IPV6_DONTFRAG 62
     * }
     */
    public static int IPV6_DONTFRAG() {
        return IPV6_DONTFRAG;
    }
    private static final int IPV6_RECVTCLASS = (int)66L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVTCLASS 66
     * }
     */
    public static int IPV6_RECVTCLASS() {
        return IPV6_RECVTCLASS;
    }
    private static final int IPV6_TCLASS = (int)67L;
    /**
     * {@snippet lang=c :
     * #define IPV6_TCLASS 67
     * }
     */
    public static int IPV6_TCLASS() {
        return IPV6_TCLASS;
    }
    private static final int IPV6_AUTOFLOWLABEL = (int)70L;
    /**
     * {@snippet lang=c :
     * #define IPV6_AUTOFLOWLABEL 70
     * }
     */
    public static int IPV6_AUTOFLOWLABEL() {
        return IPV6_AUTOFLOWLABEL;
    }
    private static final int IPV6_ADDR_PREFERENCES = (int)72L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ADDR_PREFERENCES 72
     * }
     */
    public static int IPV6_ADDR_PREFERENCES() {
        return IPV6_ADDR_PREFERENCES;
    }
    private static final int IPV6_MINHOPCOUNT = (int)73L;
    /**
     * {@snippet lang=c :
     * #define IPV6_MINHOPCOUNT 73
     * }
     */
    public static int IPV6_MINHOPCOUNT() {
        return IPV6_MINHOPCOUNT;
    }
    private static final int IPV6_ORIGDSTADDR = (int)74L;
    /**
     * {@snippet lang=c :
     * #define IPV6_ORIGDSTADDR 74
     * }
     */
    public static int IPV6_ORIGDSTADDR() {
        return IPV6_ORIGDSTADDR;
    }
    private static final int IPV6_TRANSPARENT = (int)75L;
    /**
     * {@snippet lang=c :
     * #define IPV6_TRANSPARENT 75
     * }
     */
    public static int IPV6_TRANSPARENT() {
        return IPV6_TRANSPARENT;
    }
    private static final int IPV6_UNICAST_IF = (int)76L;
    /**
     * {@snippet lang=c :
     * #define IPV6_UNICAST_IF 76
     * }
     */
    public static int IPV6_UNICAST_IF() {
        return IPV6_UNICAST_IF;
    }
    private static final int IPV6_RECVFRAGSIZE = (int)77L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RECVFRAGSIZE 77
     * }
     */
    public static int IPV6_RECVFRAGSIZE() {
        return IPV6_RECVFRAGSIZE;
    }
    private static final int IPV6_FREEBIND = (int)78L;
    /**
     * {@snippet lang=c :
     * #define IPV6_FREEBIND 78
     * }
     */
    public static int IPV6_FREEBIND() {
        return IPV6_FREEBIND;
    }
    private static final int IPV6_PMTUDISC_DONT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_DONT 0
     * }
     */
    public static int IPV6_PMTUDISC_DONT() {
        return IPV6_PMTUDISC_DONT;
    }
    private static final int IPV6_PMTUDISC_WANT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_WANT 1
     * }
     */
    public static int IPV6_PMTUDISC_WANT() {
        return IPV6_PMTUDISC_WANT;
    }
    private static final int IPV6_PMTUDISC_DO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_DO 2
     * }
     */
    public static int IPV6_PMTUDISC_DO() {
        return IPV6_PMTUDISC_DO;
    }
    private static final int IPV6_PMTUDISC_PROBE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_PROBE 3
     * }
     */
    public static int IPV6_PMTUDISC_PROBE() {
        return IPV6_PMTUDISC_PROBE;
    }
    private static final int IPV6_PMTUDISC_INTERFACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_INTERFACE 4
     * }
     */
    public static int IPV6_PMTUDISC_INTERFACE() {
        return IPV6_PMTUDISC_INTERFACE;
    }
    private static final int IPV6_PMTUDISC_OMIT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IPV6_PMTUDISC_OMIT 5
     * }
     */
    public static int IPV6_PMTUDISC_OMIT() {
        return IPV6_PMTUDISC_OMIT;
    }
    private static final int SOL_IPV6 = (int)41L;
    /**
     * {@snippet lang=c :
     * #define SOL_IPV6 41
     * }
     */
    public static int SOL_IPV6() {
        return SOL_IPV6;
    }
    private static final int SOL_ICMPV6 = (int)58L;
    /**
     * {@snippet lang=c :
     * #define SOL_ICMPV6 58
     * }
     */
    public static int SOL_ICMPV6() {
        return SOL_ICMPV6;
    }
    private static final int IPV6_RTHDR_LOOSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDR_LOOSE 0
     * }
     */
    public static int IPV6_RTHDR_LOOSE() {
        return IPV6_RTHDR_LOOSE;
    }
    private static final int IPV6_RTHDR_STRICT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDR_STRICT 1
     * }
     */
    public static int IPV6_RTHDR_STRICT() {
        return IPV6_RTHDR_STRICT;
    }
    private static final int IPV6_RTHDR_TYPE_0 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define IPV6_RTHDR_TYPE_0 0
     * }
     */
    public static int IPV6_RTHDR_TYPE_0() {
        return IPV6_RTHDR_TYPE_0;
    }
    private static final int IN_CLASSA_NSHIFT = (int)24L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSA_NSHIFT 24
     * }
     */
    public static int IN_CLASSA_NSHIFT() {
        return IN_CLASSA_NSHIFT;
    }
    private static final int IN_CLASSA_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSA_MAX 128
     * }
     */
    public static int IN_CLASSA_MAX() {
        return IN_CLASSA_MAX;
    }
    private static final int IN_CLASSB_NSHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSB_NSHIFT 16
     * }
     */
    public static int IN_CLASSB_NSHIFT() {
        return IN_CLASSB_NSHIFT;
    }
    private static final int IN_CLASSB_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSB_MAX 65536
     * }
     */
    public static int IN_CLASSB_MAX() {
        return IN_CLASSB_MAX;
    }
    private static final int IN_CLASSC_NSHIFT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define IN_CLASSC_NSHIFT 8
     * }
     */
    public static int IN_CLASSC_NSHIFT() {
        return IN_CLASSC_NSHIFT;
    }
    private static final int IN_LOOPBACKNET = (int)127L;
    /**
     * {@snippet lang=c :
     * #define IN_LOOPBACKNET 127
     * }
     */
    public static int IN_LOOPBACKNET() {
        return IN_LOOPBACKNET;
    }
    private static final int INET_ADDRSTRLEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define INET_ADDRSTRLEN 16
     * }
     */
    public static int INET_ADDRSTRLEN() {
        return INET_ADDRSTRLEN;
    }
    private static final int INET6_ADDRSTRLEN = (int)46L;
    /**
     * {@snippet lang=c :
     * #define INET6_ADDRSTRLEN 46
     * }
     */
    public static int INET6_ADDRSTRLEN() {
        return INET6_ADDRSTRLEN;
    }
    private static final int _RPC_NETDB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _RPC_NETDB_H 1
     * }
     */
    public static int _RPC_NETDB_H() {
        return _RPC_NETDB_H;
    }
    private static final int HOST_NOT_FOUND = (int)1L;
    /**
     * {@snippet lang=c :
     * #define HOST_NOT_FOUND 1
     * }
     */
    public static int HOST_NOT_FOUND() {
        return HOST_NOT_FOUND;
    }
    private static final int TRY_AGAIN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TRY_AGAIN 2
     * }
     */
    public static int TRY_AGAIN() {
        return TRY_AGAIN;
    }
    private static final int NO_RECOVERY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define NO_RECOVERY 3
     * }
     */
    public static int NO_RECOVERY() {
        return NO_RECOVERY;
    }
    private static final int NO_DATA = (int)4L;
    /**
     * {@snippet lang=c :
     * #define NO_DATA 4
     * }
     */
    public static int NO_DATA() {
        return NO_DATA;
    }
    private static final int NETDB_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define NETDB_SUCCESS 0
     * }
     */
    public static int NETDB_SUCCESS() {
        return NETDB_SUCCESS;
    }
    private static final int IPPORT_RESERVED = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define IPPORT_RESERVED 1024
     * }
     */
    public static int IPPORT_RESERVED() {
        return IPPORT_RESERVED;
    }
    private static final int AI_PASSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AI_PASSIVE 1
     * }
     */
    public static int AI_PASSIVE() {
        return AI_PASSIVE;
    }
    private static final int AI_CANONNAME = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AI_CANONNAME 2
     * }
     */
    public static int AI_CANONNAME() {
        return AI_CANONNAME;
    }
    private static final int AI_NUMERICHOST = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AI_NUMERICHOST 4
     * }
     */
    public static int AI_NUMERICHOST() {
        return AI_NUMERICHOST;
    }
    private static final int AI_V4MAPPED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AI_V4MAPPED 8
     * }
     */
    public static int AI_V4MAPPED() {
        return AI_V4MAPPED;
    }
    private static final int AI_ALL = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AI_ALL 16
     * }
     */
    public static int AI_ALL() {
        return AI_ALL;
    }
    private static final int AI_ADDRCONFIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AI_ADDRCONFIG 32
     * }
     */
    public static int AI_ADDRCONFIG() {
        return AI_ADDRCONFIG;
    }
    private static final int AI_NUMERICSERV = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define AI_NUMERICSERV 1024
     * }
     */
    public static int AI_NUMERICSERV() {
        return AI_NUMERICSERV;
    }
    private static final int NI_MAXHOST = (int)1025L;
    /**
     * {@snippet lang=c :
     * #define NI_MAXHOST 1025
     * }
     */
    public static int NI_MAXHOST() {
        return NI_MAXHOST;
    }
    private static final int NI_MAXSERV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define NI_MAXSERV 32
     * }
     */
    public static int NI_MAXSERV() {
        return NI_MAXSERV;
    }
    private static final int NI_NUMERICHOST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define NI_NUMERICHOST 1
     * }
     */
    public static int NI_NUMERICHOST() {
        return NI_NUMERICHOST;
    }
    private static final int NI_NUMERICSERV = (int)2L;
    /**
     * {@snippet lang=c :
     * #define NI_NUMERICSERV 2
     * }
     */
    public static int NI_NUMERICSERV() {
        return NI_NUMERICSERV;
    }
    private static final int NI_NOFQDN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define NI_NOFQDN 4
     * }
     */
    public static int NI_NOFQDN() {
        return NI_NOFQDN;
    }
    private static final int NI_NAMEREQD = (int)8L;
    /**
     * {@snippet lang=c :
     * #define NI_NAMEREQD 8
     * }
     */
    public static int NI_NAMEREQD() {
        return NI_NAMEREQD;
    }
    private static final int NI_DGRAM = (int)16L;
    /**
     * {@snippet lang=c :
     * #define NI_DGRAM 16
     * }
     */
    public static int NI_DGRAM() {
        return NI_DGRAM;
    }
    private static final int _PWD_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _PWD_H 1
     * }
     */
    public static int _PWD_H() {
        return _PWD_H;
    }
    private static final int NSS_BUFLEN_PASSWD = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define NSS_BUFLEN_PASSWD 1024
     * }
     */
    public static int NSS_BUFLEN_PASSWD() {
        return NSS_BUFLEN_PASSWD;
    }
    private static final int _SHADOW_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SHADOW_H 1
     * }
     */
    public static int _SHADOW_H() {
        return _SHADOW_H;
    }
    private static final int __LINUX_PAM__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __LINUX_PAM__ 1
     * }
     */
    public static int __LINUX_PAM__() {
        return __LINUX_PAM__;
    }
    private static final int __LINUX_PAM_MINOR__ = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LINUX_PAM_MINOR__ 0
     * }
     */
    public static int __LINUX_PAM_MINOR__() {
        return __LINUX_PAM_MINOR__;
    }
    private static final int PAM_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define PAM_SUCCESS 0
     * }
     */
    public static int PAM_SUCCESS() {
        return PAM_SUCCESS;
    }
    private static final int PAM_OPEN_ERR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PAM_OPEN_ERR 1
     * }
     */
    public static int PAM_OPEN_ERR() {
        return PAM_OPEN_ERR;
    }
    private static final int PAM_SYMBOL_ERR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PAM_SYMBOL_ERR 2
     * }
     */
    public static int PAM_SYMBOL_ERR() {
        return PAM_SYMBOL_ERR;
    }
    private static final int PAM_SERVICE_ERR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PAM_SERVICE_ERR 3
     * }
     */
    public static int PAM_SERVICE_ERR() {
        return PAM_SERVICE_ERR;
    }
    private static final int PAM_SYSTEM_ERR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PAM_SYSTEM_ERR 4
     * }
     */
    public static int PAM_SYSTEM_ERR() {
        return PAM_SYSTEM_ERR;
    }
    private static final int PAM_BUF_ERR = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PAM_BUF_ERR 5
     * }
     */
    public static int PAM_BUF_ERR() {
        return PAM_BUF_ERR;
    }
    private static final int PAM_PERM_DENIED = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PAM_PERM_DENIED 6
     * }
     */
    public static int PAM_PERM_DENIED() {
        return PAM_PERM_DENIED;
    }
    private static final int PAM_AUTH_ERR = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTH_ERR 7
     * }
     */
    public static int PAM_AUTH_ERR() {
        return PAM_AUTH_ERR;
    }
    private static final int PAM_CRED_INSUFFICIENT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PAM_CRED_INSUFFICIENT 8
     * }
     */
    public static int PAM_CRED_INSUFFICIENT() {
        return PAM_CRED_INSUFFICIENT;
    }
    private static final int PAM_AUTHINFO_UNAVAIL = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTHINFO_UNAVAIL 9
     * }
     */
    public static int PAM_AUTHINFO_UNAVAIL() {
        return PAM_AUTHINFO_UNAVAIL;
    }
    private static final int PAM_USER_UNKNOWN = (int)10L;
    /**
     * {@snippet lang=c :
     * #define PAM_USER_UNKNOWN 10
     * }
     */
    public static int PAM_USER_UNKNOWN() {
        return PAM_USER_UNKNOWN;
    }
    private static final int PAM_MAXTRIES = (int)11L;
    /**
     * {@snippet lang=c :
     * #define PAM_MAXTRIES 11
     * }
     */
    public static int PAM_MAXTRIES() {
        return PAM_MAXTRIES;
    }
    private static final int PAM_NEW_AUTHTOK_REQD = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PAM_NEW_AUTHTOK_REQD 12
     * }
     */
    public static int PAM_NEW_AUTHTOK_REQD() {
        return PAM_NEW_AUTHTOK_REQD;
    }
    private static final int PAM_ACCT_EXPIRED = (int)13L;
    /**
     * {@snippet lang=c :
     * #define PAM_ACCT_EXPIRED 13
     * }
     */
    public static int PAM_ACCT_EXPIRED() {
        return PAM_ACCT_EXPIRED;
    }
    private static final int PAM_SESSION_ERR = (int)14L;
    /**
     * {@snippet lang=c :
     * #define PAM_SESSION_ERR 14
     * }
     */
    public static int PAM_SESSION_ERR() {
        return PAM_SESSION_ERR;
    }
    private static final int PAM_CRED_UNAVAIL = (int)15L;
    /**
     * {@snippet lang=c :
     * #define PAM_CRED_UNAVAIL 15
     * }
     */
    public static int PAM_CRED_UNAVAIL() {
        return PAM_CRED_UNAVAIL;
    }
    private static final int PAM_CRED_EXPIRED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define PAM_CRED_EXPIRED 16
     * }
     */
    public static int PAM_CRED_EXPIRED() {
        return PAM_CRED_EXPIRED;
    }
    private static final int PAM_CRED_ERR = (int)17L;
    /**
     * {@snippet lang=c :
     * #define PAM_CRED_ERR 17
     * }
     */
    public static int PAM_CRED_ERR() {
        return PAM_CRED_ERR;
    }
    private static final int PAM_NO_MODULE_DATA = (int)18L;
    /**
     * {@snippet lang=c :
     * #define PAM_NO_MODULE_DATA 18
     * }
     */
    public static int PAM_NO_MODULE_DATA() {
        return PAM_NO_MODULE_DATA;
    }
    private static final int PAM_CONV_ERR = (int)19L;
    /**
     * {@snippet lang=c :
     * #define PAM_CONV_ERR 19
     * }
     */
    public static int PAM_CONV_ERR() {
        return PAM_CONV_ERR;
    }
    private static final int PAM_AUTHTOK_ERR = (int)20L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTHTOK_ERR 20
     * }
     */
    public static int PAM_AUTHTOK_ERR() {
        return PAM_AUTHTOK_ERR;
    }
    private static final int PAM_AUTHTOK_RECOVERY_ERR = (int)21L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTHTOK_RECOVERY_ERR 21
     * }
     */
    public static int PAM_AUTHTOK_RECOVERY_ERR() {
        return PAM_AUTHTOK_RECOVERY_ERR;
    }
    private static final int PAM_AUTHTOK_LOCK_BUSY = (int)22L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTHTOK_LOCK_BUSY 22
     * }
     */
    public static int PAM_AUTHTOK_LOCK_BUSY() {
        return PAM_AUTHTOK_LOCK_BUSY;
    }
    private static final int PAM_AUTHTOK_DISABLE_AGING = (int)23L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTHTOK_DISABLE_AGING 23
     * }
     */
    public static int PAM_AUTHTOK_DISABLE_AGING() {
        return PAM_AUTHTOK_DISABLE_AGING;
    }
    private static final int PAM_TRY_AGAIN = (int)24L;
    /**
     * {@snippet lang=c :
     * #define PAM_TRY_AGAIN 24
     * }
     */
    public static int PAM_TRY_AGAIN() {
        return PAM_TRY_AGAIN;
    }
    private static final int PAM_IGNORE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define PAM_IGNORE 25
     * }
     */
    public static int PAM_IGNORE() {
        return PAM_IGNORE;
    }
    private static final int PAM_ABORT = (int)26L;
    /**
     * {@snippet lang=c :
     * #define PAM_ABORT 26
     * }
     */
    public static int PAM_ABORT() {
        return PAM_ABORT;
    }
    private static final int PAM_AUTHTOK_EXPIRED = (int)27L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTHTOK_EXPIRED 27
     * }
     */
    public static int PAM_AUTHTOK_EXPIRED() {
        return PAM_AUTHTOK_EXPIRED;
    }
    private static final int PAM_MODULE_UNKNOWN = (int)28L;
    /**
     * {@snippet lang=c :
     * #define PAM_MODULE_UNKNOWN 28
     * }
     */
    public static int PAM_MODULE_UNKNOWN() {
        return PAM_MODULE_UNKNOWN;
    }
    private static final int PAM_BAD_ITEM = (int)29L;
    /**
     * {@snippet lang=c :
     * #define PAM_BAD_ITEM 29
     * }
     */
    public static int PAM_BAD_ITEM() {
        return PAM_BAD_ITEM;
    }
    private static final int PAM_CONV_AGAIN = (int)30L;
    /**
     * {@snippet lang=c :
     * #define PAM_CONV_AGAIN 30
     * }
     */
    public static int PAM_CONV_AGAIN() {
        return PAM_CONV_AGAIN;
    }
    private static final int PAM_INCOMPLETE = (int)31L;
    /**
     * {@snippet lang=c :
     * #define PAM_INCOMPLETE 31
     * }
     */
    public static int PAM_INCOMPLETE() {
        return PAM_INCOMPLETE;
    }
    private static final int _PAM_RETURN_VALUES = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _PAM_RETURN_VALUES 32
     * }
     */
    public static int _PAM_RETURN_VALUES() {
        return _PAM_RETURN_VALUES;
    }
    private static final int PAM_SERVICE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PAM_SERVICE 1
     * }
     */
    public static int PAM_SERVICE() {
        return PAM_SERVICE;
    }
    private static final int PAM_USER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PAM_USER 2
     * }
     */
    public static int PAM_USER() {
        return PAM_USER;
    }
    private static final int PAM_TTY = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PAM_TTY 3
     * }
     */
    public static int PAM_TTY() {
        return PAM_TTY;
    }
    private static final int PAM_RHOST = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PAM_RHOST 4
     * }
     */
    public static int PAM_RHOST() {
        return PAM_RHOST;
    }
    private static final int PAM_CONV = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PAM_CONV 5
     * }
     */
    public static int PAM_CONV() {
        return PAM_CONV;
    }
    private static final int PAM_AUTHTOK = (int)6L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTHTOK 6
     * }
     */
    public static int PAM_AUTHTOK() {
        return PAM_AUTHTOK;
    }
    private static final int PAM_OLDAUTHTOK = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PAM_OLDAUTHTOK 7
     * }
     */
    public static int PAM_OLDAUTHTOK() {
        return PAM_OLDAUTHTOK;
    }
    private static final int PAM_RUSER = (int)8L;
    /**
     * {@snippet lang=c :
     * #define PAM_RUSER 8
     * }
     */
    public static int PAM_RUSER() {
        return PAM_RUSER;
    }
    private static final int PAM_USER_PROMPT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define PAM_USER_PROMPT 9
     * }
     */
    public static int PAM_USER_PROMPT() {
        return PAM_USER_PROMPT;
    }
    private static final int PAM_FAIL_DELAY = (int)10L;
    /**
     * {@snippet lang=c :
     * #define PAM_FAIL_DELAY 10
     * }
     */
    public static int PAM_FAIL_DELAY() {
        return PAM_FAIL_DELAY;
    }
    private static final int PAM_XDISPLAY = (int)11L;
    /**
     * {@snippet lang=c :
     * #define PAM_XDISPLAY 11
     * }
     */
    public static int PAM_XDISPLAY() {
        return PAM_XDISPLAY;
    }
    private static final int PAM_XAUTHDATA = (int)12L;
    /**
     * {@snippet lang=c :
     * #define PAM_XAUTHDATA 12
     * }
     */
    public static int PAM_XAUTHDATA() {
        return PAM_XAUTHDATA;
    }
    private static final int PAM_AUTHTOK_TYPE = (int)13L;
    /**
     * {@snippet lang=c :
     * #define PAM_AUTHTOK_TYPE 13
     * }
     */
    public static int PAM_AUTHTOK_TYPE() {
        return PAM_AUTHTOK_TYPE;
    }
    private static final int PAM_DATA_SILENT = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define PAM_DATA_SILENT 1073741824
     * }
     */
    public static int PAM_DATA_SILENT() {
        return PAM_DATA_SILENT;
    }
    private static final int PAM_PROMPT_ECHO_OFF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PAM_PROMPT_ECHO_OFF 1
     * }
     */
    public static int PAM_PROMPT_ECHO_OFF() {
        return PAM_PROMPT_ECHO_OFF;
    }
    private static final int PAM_PROMPT_ECHO_ON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PAM_PROMPT_ECHO_ON 2
     * }
     */
    public static int PAM_PROMPT_ECHO_ON() {
        return PAM_PROMPT_ECHO_ON;
    }
    private static final int PAM_ERROR_MSG = (int)3L;
    /**
     * {@snippet lang=c :
     * #define PAM_ERROR_MSG 3
     * }
     */
    public static int PAM_ERROR_MSG() {
        return PAM_ERROR_MSG;
    }
    private static final int PAM_TEXT_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PAM_TEXT_INFO 4
     * }
     */
    public static int PAM_TEXT_INFO() {
        return PAM_TEXT_INFO;
    }
    private static final int PAM_RADIO_TYPE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define PAM_RADIO_TYPE 5
     * }
     */
    public static int PAM_RADIO_TYPE() {
        return PAM_RADIO_TYPE;
    }
    private static final int PAM_BINARY_PROMPT = (int)7L;
    /**
     * {@snippet lang=c :
     * #define PAM_BINARY_PROMPT 7
     * }
     */
    public static int PAM_BINARY_PROMPT() {
        return PAM_BINARY_PROMPT;
    }
    private static final int PAM_MAX_NUM_MSG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define PAM_MAX_NUM_MSG 32
     * }
     */
    public static int PAM_MAX_NUM_MSG() {
        return PAM_MAX_NUM_MSG;
    }
    private static final int PAM_MAX_MSG_SIZE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define PAM_MAX_MSG_SIZE 512
     * }
     */
    public static int PAM_MAX_MSG_SIZE() {
        return PAM_MAX_MSG_SIZE;
    }
    private static final int PAM_MAX_RESP_SIZE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define PAM_MAX_RESP_SIZE 512
     * }
     */
    public static int PAM_MAX_RESP_SIZE() {
        return PAM_MAX_RESP_SIZE;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = nss_proto_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = nss_proto_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = nss_proto_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = nss_proto_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = nss_proto_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = nss_proto_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = nss_proto_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = nss_proto_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = nss_proto_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = nss_proto_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = nss_proto_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = nss_proto_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = nss_proto_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = nss_proto_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = nss_proto_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = nss_proto_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = nss_proto_h.C_INT;

    private static class setaliasent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setaliasent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setaliasent()
     * }
     */
    public static FunctionDescriptor setaliasent$descriptor() {
        return setaliasent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setaliasent()
     * }
     */
    public static MethodHandle setaliasent$handle() {
        return setaliasent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setaliasent()
     * }
     */
    public static MemorySegment setaliasent$address() {
        return setaliasent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setaliasent()
     * }
     */
    public static void setaliasent() {
        var mh$ = setaliasent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setaliasent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endaliasent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("endaliasent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void endaliasent()
     * }
     */
    public static FunctionDescriptor endaliasent$descriptor() {
        return endaliasent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void endaliasent()
     * }
     */
    public static MethodHandle endaliasent$handle() {
        return endaliasent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void endaliasent()
     * }
     */
    public static MemorySegment endaliasent$address() {
        return endaliasent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void endaliasent()
     * }
     */
    public static void endaliasent() {
        var mh$ = endaliasent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endaliasent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaliasent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getaliasent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct aliasent *getaliasent()
     * }
     */
    public static FunctionDescriptor getaliasent$descriptor() {
        return getaliasent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct aliasent *getaliasent()
     * }
     */
    public static MethodHandle getaliasent$handle() {
        return getaliasent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct aliasent *getaliasent()
     * }
     */
    public static MemorySegment getaliasent$address() {
        return getaliasent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct aliasent *getaliasent()
     * }
     */
    public static MemorySegment getaliasent() {
        var mh$ = getaliasent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaliasent");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaliasent_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getaliasent_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getaliasent_r(struct aliasent *restrict __result_buf, char *restrict __buffer, size_t __buflen, struct aliasent **restrict __result)
     * }
     */
    public static FunctionDescriptor getaliasent_r$descriptor() {
        return getaliasent_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getaliasent_r(struct aliasent *restrict __result_buf, char *restrict __buffer, size_t __buflen, struct aliasent **restrict __result)
     * }
     */
    public static MethodHandle getaliasent_r$handle() {
        return getaliasent_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getaliasent_r(struct aliasent *restrict __result_buf, char *restrict __buffer, size_t __buflen, struct aliasent **restrict __result)
     * }
     */
    public static MemorySegment getaliasent_r$address() {
        return getaliasent_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getaliasent_r(struct aliasent *restrict __result_buf, char *restrict __buffer, size_t __buflen, struct aliasent **restrict __result)
     * }
     */
    public static int getaliasent_r(MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getaliasent_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaliasent_r", __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaliasbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getaliasbyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct aliasent *getaliasbyname(const char *__name)
     * }
     */
    public static FunctionDescriptor getaliasbyname$descriptor() {
        return getaliasbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct aliasent *getaliasbyname(const char *__name)
     * }
     */
    public static MethodHandle getaliasbyname$handle() {
        return getaliasbyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct aliasent *getaliasbyname(const char *__name)
     * }
     */
    public static MemorySegment getaliasbyname$address() {
        return getaliasbyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct aliasent *getaliasbyname(const char *__name)
     * }
     */
    public static MemorySegment getaliasbyname(MemorySegment __name) {
        var mh$ = getaliasbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaliasbyname", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getaliasbyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getaliasbyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getaliasbyname_r(const char *restrict __name, struct aliasent *restrict __result_buf, char *restrict __buffer, size_t __buflen, struct aliasent **restrict __result)
     * }
     */
    public static FunctionDescriptor getaliasbyname_r$descriptor() {
        return getaliasbyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getaliasbyname_r(const char *restrict __name, struct aliasent *restrict __result_buf, char *restrict __buffer, size_t __buflen, struct aliasent **restrict __result)
     * }
     */
    public static MethodHandle getaliasbyname_r$handle() {
        return getaliasbyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getaliasbyname_r(const char *restrict __name, struct aliasent *restrict __result_buf, char *restrict __buffer, size_t __buflen, struct aliasent **restrict __result)
     * }
     */
    public static MemorySegment getaliasbyname_r$address() {
        return getaliasbyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getaliasbyname_r(const char *restrict __name, struct aliasent *restrict __result_buf, char *restrict __buffer, size_t __buflen, struct aliasent **restrict __result)
     * }
     */
    public static int getaliasbyname_r(MemorySegment __name, MemorySegment __result_buf, MemorySegment __buffer, long __buflen, MemorySegment __result) {
        var mh$ = getaliasbyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getaliasbyname_r", __name, __result_buf, __buffer, __buflen, __result);
            }
            return (int)mh$.invokeExact(__name, __result_buf, __buffer, __buflen, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = nss_proto_h.C_POINTER;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = nss_proto_h.C_POINTER;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = nss_proto_h.C_POINTER;
        public static final MemorySegment SEGMENT = nss_proto_h.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopencookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            _IO_cookie_io_functions_t.layout()
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fopencookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static FunctionDescriptor fopencookie$descriptor() {
        return fopencookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MethodHandle fopencookie$handle() {
        return fopencookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie$address() {
        return fopencookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie(MemorySegment __magic_cookie, MemorySegment __modes, MemorySegment __io_funcs) {
        var mh$ = fopencookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopencookie", __magic_cookie, __modes, __io_funcs);
            }
            return (MemorySegment)mh$.invokeExact(__magic_cookie, __modes, __io_funcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_LONG
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER,
                nss_proto_h.C_LONG,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int) spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static int vasprintf(MemorySegment __ptr, MemorySegment __f, MemorySegment __arg) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", __ptr, __f, __arg);
            }
            return (int)mh$.invokeExact(__ptr, __f, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class __asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("__asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static __asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int) spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                nss_proto_h.C_INT,
                nss_proto_h.C_POINTER,
                nss_proto_h.C_POINTER
            );
        private static final MemorySegment ADDR = nss_proto_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = nss_proto_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = nss_proto_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = nss_proto_h.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_LONG,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_LONG,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_POINTER,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _ISupper = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISupper = 256
     * }
     */
    public static int _ISupper() {
        return _ISupper;
    }
    private static final int _ISlower = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISlower = 512
     * }
     */
    public static int _ISlower() {
        return _ISlower;
    }
    private static final int _ISalpha = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISalpha = 1024
     * }
     */
    public static int _ISalpha() {
        return _ISalpha;
    }
    private static final int _ISdigit = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISdigit = 2048
     * }
     */
    public static int _ISdigit() {
        return _ISdigit;
    }
    private static final int _ISxdigit = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISxdigit = 4096
     * }
     */
    public static int _ISxdigit() {
        return _ISxdigit;
    }
    private static final int _ISspace = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISspace = 8192
     * }
     */
    public static int _ISspace() {
        return _ISspace;
    }
    private static final int _ISprint = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISprint = 16384
     * }
     */
    public static int _ISprint() {
        return _ISprint;
    }
    private static final int _ISgraph = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISgraph = 32768
     * }
     */
    public static int _ISgraph() {
        return _ISgraph;
    }
    private static final int _ISblank = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISblank = 1
     * }
     */
    public static int _ISblank() {
        return _ISblank;
    }
    private static final int _IScntrl = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._IScntrl = 2
     * }
     */
    public static int _IScntrl() {
        return _IScntrl;
    }
    private static final int _ISpunct = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISpunct = 4
     * }
     */
    public static int _ISpunct() {
        return _ISpunct;
    }
    private static final int _ISalnum = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._ISalnum = 8
     * }
     */
    public static int _ISalnum() {
        return _ISalnum;
    }

    private static class __ctype_b_loc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__ctype_b_loc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const unsigned short **__ctype_b_loc()
     * }
     */
    public static FunctionDescriptor __ctype_b_loc$descriptor() {
        return __ctype_b_loc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const unsigned short **__ctype_b_loc()
     * }
     */
    public static MethodHandle __ctype_b_loc$handle() {
        return __ctype_b_loc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const unsigned short **__ctype_b_loc()
     * }
     */
    public static MemorySegment __ctype_b_loc$address() {
        return __ctype_b_loc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const unsigned short **__ctype_b_loc()
     * }
     */
    public static MemorySegment __ctype_b_loc() {
        var mh$ = __ctype_b_loc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_b_loc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctype_tolower_loc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__ctype_tolower_loc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const __int32_t **__ctype_tolower_loc()
     * }
     */
    public static FunctionDescriptor __ctype_tolower_loc$descriptor() {
        return __ctype_tolower_loc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const __int32_t **__ctype_tolower_loc()
     * }
     */
    public static MethodHandle __ctype_tolower_loc$handle() {
        return __ctype_tolower_loc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const __int32_t **__ctype_tolower_loc()
     * }
     */
    public static MemorySegment __ctype_tolower_loc$address() {
        return __ctype_tolower_loc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const __int32_t **__ctype_tolower_loc()
     * }
     */
    public static MemorySegment __ctype_tolower_loc() {
        var mh$ = __ctype_tolower_loc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_tolower_loc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __ctype_toupper_loc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_POINTER    );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("__ctype_toupper_loc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const __int32_t **__ctype_toupper_loc()
     * }
     */
    public static FunctionDescriptor __ctype_toupper_loc$descriptor() {
        return __ctype_toupper_loc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const __int32_t **__ctype_toupper_loc()
     * }
     */
    public static MethodHandle __ctype_toupper_loc$handle() {
        return __ctype_toupper_loc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const __int32_t **__ctype_toupper_loc()
     * }
     */
    public static MemorySegment __ctype_toupper_loc$address() {
        return __ctype_toupper_loc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const __int32_t **__ctype_toupper_loc()
     * }
     */
    public static MemorySegment __ctype_toupper_loc() {
        var mh$ = __ctype_toupper_loc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_toupper_loc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isalnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isalnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isalnum(int)
     * }
     */
    public static FunctionDescriptor isalnum$descriptor() {
        return isalnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isalnum(int)
     * }
     */
    public static MethodHandle isalnum$handle() {
        return isalnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isalnum(int)
     * }
     */
    public static MemorySegment isalnum$address() {
        return isalnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isalnum(int)
     * }
     */
    public static int isalnum(int x0) {
        var mh$ = isalnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isalnum", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isalpha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isalpha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isalpha(int)
     * }
     */
    public static FunctionDescriptor isalpha$descriptor() {
        return isalpha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isalpha(int)
     * }
     */
    public static MethodHandle isalpha$handle() {
        return isalpha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isalpha(int)
     * }
     */
    public static MemorySegment isalpha$address() {
        return isalpha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isalpha(int)
     * }
     */
    public static int isalpha(int x0) {
        var mh$ = isalpha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isalpha", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iscntrl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("iscntrl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int iscntrl(int)
     * }
     */
    public static FunctionDescriptor iscntrl$descriptor() {
        return iscntrl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int iscntrl(int)
     * }
     */
    public static MethodHandle iscntrl$handle() {
        return iscntrl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int iscntrl(int)
     * }
     */
    public static MemorySegment iscntrl$address() {
        return iscntrl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int iscntrl(int)
     * }
     */
    public static int iscntrl(int x0) {
        var mh$ = iscntrl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iscntrl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isdigit(int)
     * }
     */
    public static FunctionDescriptor isdigit$descriptor() {
        return isdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isdigit(int)
     * }
     */
    public static MethodHandle isdigit$handle() {
        return isdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isdigit(int)
     * }
     */
    public static MemorySegment isdigit$address() {
        return isdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isdigit(int)
     * }
     */
    public static int isdigit(int x0) {
        var mh$ = isdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isdigit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class islower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("islower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int islower(int)
     * }
     */
    public static FunctionDescriptor islower$descriptor() {
        return islower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int islower(int)
     * }
     */
    public static MethodHandle islower$handle() {
        return islower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int islower(int)
     * }
     */
    public static MemorySegment islower$address() {
        return islower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int islower(int)
     * }
     */
    public static int islower(int x0) {
        var mh$ = islower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("islower", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isgraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isgraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isgraph(int)
     * }
     */
    public static FunctionDescriptor isgraph$descriptor() {
        return isgraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isgraph(int)
     * }
     */
    public static MethodHandle isgraph$handle() {
        return isgraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isgraph(int)
     * }
     */
    public static MemorySegment isgraph$address() {
        return isgraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isgraph(int)
     * }
     */
    public static int isgraph(int x0) {
        var mh$ = isgraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isgraph", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isprint(int)
     * }
     */
    public static FunctionDescriptor isprint$descriptor() {
        return isprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isprint(int)
     * }
     */
    public static MethodHandle isprint$handle() {
        return isprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isprint(int)
     * }
     */
    public static MemorySegment isprint$address() {
        return isprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isprint(int)
     * }
     */
    public static int isprint(int x0) {
        var mh$ = isprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isprint", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ispunct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("ispunct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ispunct(int)
     * }
     */
    public static FunctionDescriptor ispunct$descriptor() {
        return ispunct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ispunct(int)
     * }
     */
    public static MethodHandle ispunct$handle() {
        return ispunct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ispunct(int)
     * }
     */
    public static MemorySegment ispunct$address() {
        return ispunct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ispunct(int)
     * }
     */
    public static int ispunct(int x0) {
        var mh$ = ispunct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ispunct", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isspace(int)
     * }
     */
    public static FunctionDescriptor isspace$descriptor() {
        return isspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isspace(int)
     * }
     */
    public static MethodHandle isspace$handle() {
        return isspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isspace(int)
     * }
     */
    public static MemorySegment isspace$address() {
        return isspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isspace(int)
     * }
     */
    public static int isspace(int x0) {
        var mh$ = isspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isspace", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isupper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isupper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isupper(int)
     * }
     */
    public static FunctionDescriptor isupper$descriptor() {
        return isupper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isupper(int)
     * }
     */
    public static MethodHandle isupper$handle() {
        return isupper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isupper(int)
     * }
     */
    public static MemorySegment isupper$address() {
        return isupper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isupper(int)
     * }
     */
    public static int isupper(int x0) {
        var mh$ = isupper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isupper", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isxdigit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("isxdigit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int isxdigit(int)
     * }
     */
    public static FunctionDescriptor isxdigit$descriptor() {
        return isxdigit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int isxdigit(int)
     * }
     */
    public static MethodHandle isxdigit$handle() {
        return isxdigit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int isxdigit(int)
     * }
     */
    public static MemorySegment isxdigit$address() {
        return isxdigit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int isxdigit(int)
     * }
     */
    public static int isxdigit(int x0) {
        var mh$ = isxdigit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isxdigit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tolower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            nss_proto_h.C_INT,
            nss_proto_h.C_INT
        );

        public static final MemorySegment ADDR = nss_proto_h.findOrThrow("tolower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int tolower(int __c)
     * }
     */
    public static FunctionDescriptor tolower$descriptor() {
        return tolower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int tolower(int __c)
     * }
     */
    public static MethodHandle tolower$handle() {
        return tolower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int tolower(int __c)
     * }
     */
    public static MemorySegment tolower$address() {
        return tolower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int tolower(int __c)
     * }
     */
    public static int tolower(int __c) {
        var mh$ = tolower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tolower", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

